/*
   This file is provided under the LGPL license ver 2.1.
   Written by Katsumi.
   http://hp.vector.co.jp/authors/VA016157/
   kmorimatsu@users.sourceforge.jp
*/

#include "compiler.h"

/*
	This file provide functions for handling data used when compiling.
	The data is inserted between g_objmax and file cache.
	Data format (32 bit):
		MSB                LSB
		 +----+----+--------+
		 |type|len | data16 |
		 +----+----+--------+
		where,
			type:   data type number (unsigned char)
			len:    length of data area in number of words (unsigned char)
			data16: general 16 bit data (short)
*/

#define g_cmpdata g_objmax

static int* g_cmpdata_end;
static int* g_cmpdata_point;

/*
	Initialize routine must be called when starting compiler.
*/
void cmpdata_init(){
	g_cmpdata_end=g_objmax;
	g_cmpdata_point=g_objmax;
}

/*
	Function to insert a data. The data must be defined by a pointer to int array.
		unsigned char type: Data type number (0-255)
		short data16:       16 bit data. If not required, set 0.
		int* data:          Pointer to data array. If not requird, set 0.
		unsigned char num:  Length of above data array. If not required, set 0.
*/
char* cmpdata_insert(unsigned char type, short data16, int* data, unsigned char num){
	unsigned char i;
	g_cmpdata-=num+1;
	if (g_cmpdata<g_object+g_objpos) return ERR_NE_BINARY;
	g_cmpdata[0]=(type<<24)|(num+1)<<16|data16;
	for(i=0;i<num;i++){
		g_cmpdata[i+1]=data[i];
	}
	return 0;
}

/*
	Reset data point. Next search will be from the beginning.
*/

void cmpdata_reset(){
	g_cmpdata_point=g_cmpdata;
}

/*
	Find the next record with defined type. Return the pointer to the record.
*/
int* cmpdata_find(unsigned char type){
	int* ret;
	while(g_cmpdata_point<g_cmpdata_end){
		// Remember return value
		ret=g_cmpdata_point;
		// Move the point to next
		g_cmpdata_point+=(ret[0]&0x00ff0000)>>16;
		// Check if type is the same. If the same, return.
		if ((ret[0]>>24)==type) return ret;
	}
	return 0;
}

/*
	Find the record from beginning.
*/

int* cmpdata_findfirst(unsigned char type){
	cmpdata_reset();
	return cmpdata_find(type);
}
/*
   This file is provided under the LGPL license ver 2.1.
   Written by Katsumi.
   http://hp.vector.co.jp/authors/VA016157/
   kmorimatsu@users.sourceforge.jp
*/

#include "compiler.h"


#pragma GCC optimize ("-O1")
void __attribute__((nomips16)) start_program(void* addr, void* memory){
	static unsigned int stored_sp;
	// Store s0-s7, fp, and ra in stacks
	asm volatile("#":::"s0");
	asm volatile("#":::"s1");
	asm volatile("#":::"s2");
	asm volatile("#":::"s3");
	asm volatile("#":::"s4");
	asm volatile("#":::"s5");
	asm volatile("#":::"s6");
	asm volatile("#":::"s7");
	asm volatile("#":::"30");
	asm volatile("#":::"ra");
	// Store sp in stored_sp
	asm volatile("la $v0,%0"::"i"(&stored_sp));
	asm volatile("sw $sp,0($v0)");
	// Shift sp for safety
	asm volatile("addiu $sp,$sp,-8");
	// Register vector for unexpected NEXT/RETURN
	asm volatile("la $v0,%0"::"i"(&err_unexp_next));
	asm volatile("sw $v0,4($sp)");
	// Store end address in g_end_addr
	asm volatile("la $v0,%0"::"i"(&g_end_addr));
	asm volatile("la $v1,label");
	asm volatile("sw $v1,0($v0)");
	// Set s7 for easy calling call_library()
	asm volatile("la $s7,%0"::"i"(&call_library));
	// Set fp and execute program
	asm volatile("addu $30,$zero,$a1");
	asm volatile("jr $a0");
	// Restore sp from stored_sp
	asm volatile("label:");
	asm volatile("la $v0,%0"::"i"(&stored_sp));
	asm volatile("lw $sp,0($v0)");
	// Restore registers from stack and return
	return;
}

#pragma optimization_level 1
int __attribute__((nomips16)) get_gp(void){
	asm volatile("addu $v0,$gp,$zero");
}

int __attribute__((nomips16))get_fp(void){
	asm volatile("addu $v0,$30,$zero");
}


void shift_obj(int* src, int* dst, int len){
	int i;
	if (dst<src) {
		for(i=0;i<len;i++){
			dst[i]=src[i];
		}
	} else if (src<dst) {
		for(i=len-1;0<=i;i--){
			dst[i]=src[i];
		}
	}
}

int strncmp(char* str1, char* str2, int len){
	int i;
	for (i=0;i<len;i++) {
		if (str1[i]>str2[i]) return 1;
		if (str1[i]<str2[i]) return -1;
	}
	return 0;
}

int nextCodeIs(char* str){
	int len;
	next_position();
	for(len=0;str[len];len++);
	if (!strncmp(g_source+g_srcpos,str,len)) {
		if ('A'<=str[len-1] && str[len-1]<='Z') {
			// When the last character of str is alphabet, 
			// the next character in source must be space, enter, or ':'.
			if (0x20<g_source[g_srcpos+len] && g_source[g_srcpos+len]!=':') return 0;
		}
		// String matches in the current position in source.
		g_srcpos+=len;
		return len;
	} else {
		// String didn't match.
		return 0;
	}
}

int endOfStatement(){
	unsigned char b;
	next_position();
	b=g_source[g_srcpos];
	return (b<0x20 || b==':') ? 1:0;
}

char* compile_line(void){
	char b1;
	char* err;
	g_line++;
	g_fileline++;
	// Check if line number exists
	next_position();
	b1=g_source[g_srcpos];
	if (b1<0x20) {
		// The end of line.
		// Don't add $s6-setting command.
		if (g_source[g_srcpos]==0x0D && g_source[g_srcpos+1]==0x0A) g_srcpos++;
		g_srcpos++;
		return 0;
	} else if ('0'<=b1 && b1<='9') {
		// Line number exists
		err=get_label();
		if (err) return err;
		g_line=g_label;
	}
	// Store line number in $s6
	if (!(g_line&0xFFFF0000)) {
		// Line number must be less than 65536.
		// If not, it is invalid number.
		// Check existing line with the same number here.
		if (search_label(g_line)) {
			// Error: duplicate lines
			printstr("Line ");
			printstr(resolve_label(g_line));
			return ERR_MULTIPLE_LABEL;
		}
		check_obj_space(1);
		g_object[g_objpos++]=0x34160000|g_line; //ori         s6,zero,xxxx;
	}
	while(g_source[g_srcpos]!=0x0D && g_source[g_srcpos]!=0x0A){
		err=statement();
		if (err) return err;
		next_position();
		if (g_source[g_srcpos]==':') {
			g_srcpos++;
			next_position();
		}
	}
	if (g_source[g_srcpos]==0x0D && g_source[g_srcpos+1]==0x0A) g_srcpos++;
	g_srcpos++;
	return 0;
}
/*
   This file is provided under the LGPL license ver 2.1.
   Written by K.Tanaka & Katsumi
   http://www.ze.em-net.ne.jp/~kenken/index.html
   http://hp.vector.co.jp/authors/VA016157/
*/

#ifdef __DEBUG

#include <xc.h>
#include "api.h"
#include "main.h"
#include "compiler.h"

/*
	Enable following line when debugging binary object.
*/
//#include "debugdump.h"


// Pseudo reading config setting for debug mode
unsigned int g_DEVCFG1=0xFF7F4DDB;

// Construct jump assembly in boot area.
const unsigned int _debug_boot[] __attribute__((address(0xBFC00000))) ={
	0x0B401C00,//   j           0x9d007000
	0x00000000,//   nop         
};

// Use DEBUG.HEX as file name of this program.
const unsigned char _debug_filename[] __attribute__((address(FILENAME_FLASH_ADDRESS))) ="DEBUG.HEX";

static const char initext[];
static const char bastext[];

static char* readtext;
static int filepos;

/*
	Debug dump
	In debugdump.h:
		__DEBUGDUMP is defined.
		__DEBUGDUMP_FREEAREA is defined as start address of free area (1st argument of set_free_area() function)
		const unsigned char dump[] is initialized.
*/
#ifdef __DEBUGDUMP
int debugDump(){
	int i;
	for(i=0;i<sizeof dump;i++){
		RAM[i]=dump[i];
	}

	g_objpos=(__DEBUGDUMP_FREEAREA-(unsigned int)g_object)/4;

	// Initialize parameters
	g_pcg_font=0;
	g_use_graphic=0;
	g_graphic_area=0;
	clearscreen();
	setcursor(0,0,7);	

	printstr("BASIC "BASVER"\n");
	wait60thsec(15);
	// Initialize music
	init_music();

	printstr("Compiling...");

	// Initialize the other parameters
	// Random seed
	g_rnd_seed=0x92D68CA2; //2463534242
	// Clear variables
	for(i=0;i<ALLOC_BLOCK_NUM;i++){
		g_var_mem[i]=0;
		g_var_size[i]=0;
	}
	// Clear key input buffer
	for(i=0;i<256;i++){
		ps2keystatus[i]=0;
	}
	// Reset data/read.
	reset_dataread();

	// Assign memory
	set_free_area((void*)(g_object+g_objpos),(void*)(&RAM[RAMSIZE]));
	// Execute program
	// Start program from the beginning of RAM.
	// Work area (used for A-Z values) is next to the object code area.
	start_program((void*)(&(RAM[0])),(void*)(&g_var_mem[0]));
	printstr("\nOK\n");
	set_graphmode(0);
	g_use_graphic=0;

	return 1;
}
#else
int debugDump(){
	return 0;
}
#endif

/*
    Override libsdfsio functions.
    Here, don't use SD card, but the vertual files 
    (initext[] and bastext[]) are used. 
*/

FSFILE fsfile;

size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream){
	char b;
	size_t ret=0;
	if (!readtext) return 0;
	while(b=readtext[filepos]){
		filepos++;
		((char*)ptr)[ret]=b;
		ret++;
		if (n<=ret) break;
	}
	return ret;
}
FSFILE* FSfopen(const char * fileName, const char *mode){
	int i;
	for(i=0;i<13;i++){
		if (fileName[i]=='.') break;
	}
	if (i==13) {
		// Unknown file name
		// Force BAS file
		readtext=(char*)&bastext[0];
	} else if (fileName[i+1]=='I' && fileName[i+2]=='N' && fileName[i+3]=='I') {
		// INI file
		readtext=(char*)&initext[0];
	} else if (fileName[i+1]=='B' && fileName[i+2]=='A' && fileName[i+3]=='S') {
		// BAS file
		readtext=(char*)&bastext[0];
		// Try debugDump.
		if (debugDump()) return 0;
	} else {
		readtext=0;
		return 0;
	}
	filepos=0;
	return &fsfile;
}
int FSfeof( FSFILE * stream ){
	return readtext[filepos]?1:0;
}
int FSfclose(FSFILE *fo){
	return 0;
}
int FSInit(void){
	return 1;
}
int FSremove (const char * fileName){
	return 0;
}
size_t FSfwrite(const void *ptr, size_t size, size_t n, FSFILE *stream){
	return 0;
}

int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec){
	return 0;
}
int FindNext (SearchRec * rec){
	return 0;
}
int FSmkdir (char * path){
	return 0;
}
char * FSgetcwd (char * path, int numchars){
	return 0;
}
int FSchdir (char * path){
	return 0;
}
long FSftell (FSFILE * fo){
	return 0;
}
int FSfseek(FSFILE *stream, long offset, int whence){
	return 0;
}
/*
    ps2init() is not called.
    Instead, not_ps2init_but_init_Timer1() is called.
    Timer1 is used to update drawcount and drawing gloval variables.
*/

int not_ps2init_but_init_Timer1(){
	PR1=0x0FFF;
	TMR1=0;
	IFS0bits.T1IF=0;
	T1CON=0x8000;
	// Timer1 interrupt: priority 4
	IPC1bits.T1IP=4;
	IPC1bits.T1IS=0;
	IEC0bits.T1IE=1;

	return 0;
}

#pragma interrupt timer1Int IPL4SOFT vector 4

void timer1Int(){
	IFS0bits.T1IF=0;
	if (drawing) {
		drawing=0;
		drawcount++;
	} else {
		drawing=1;
	}
}

/*
    initext[] and bastext[] are vertual files 
    as "MACHIKAN.INI" and "DEBUG.BAS".
*/


static const char initext[]=
"#PRINT\n"
"#PRINT\n";


static const char bastext[]=
"CLS\n"
"USEVAR T01,T02,T03,T04,T05,T06,T07,T08\n"
"T01$=hex$(123)\n"
"PRINT T01$,\n"
"GOSUB SUB\n"
"PRINT T01$,\n"
"END\n"
"LABEL SUB\n"
"VAR T01,T02,T03,T04,T05,T06,T07,T08,A,B,C,D,E\n"
"PRINT T01,\n"
"T01=456\n"
"PRINT T01,\n"
"RETURN\n"
"\n"
"\n";

/*
    Test function for constructing assemblies from C codes.
*/

int _debug_test(int a0, int a1, int a2, int a3, int param4, int param5){
//	if (a0<0xa0008192) return 0xa0000000;
	asm volatile("addiu $sp,$sp,-4");
	return a2+a3;
}

/*
	Break point used for debugging object code.

g_object[g_objpos++]=0x0000000d;// break 0x0

*/

#endif // __DEBUG
/*
   This file is provided under the LGPL license ver 2.1.
   Written by K.Tanaka
   http://www.ze.em-net.ne.jp/~kenken/index.html
*/

#include <xc.h>
#include "api.h"
#include "editor.h"
#include "keyinput.h"
#include "compiler.h"
#include "main.h"

struct _TBUF{
//リンク付きのテキストバッファ
	struct _TBUF *prev;//前方へのリンク。NULLの場合先頭または空き
	struct _TBUF *next;//後方へのリンク。NULLの場合最後
	unsigned short n;//現在の使用バイト数
	unsigned char Buf[TBUFSIZE];//バッファ
} ;
typedef struct _TBUF _tbuf;

//_tbuf TextBuffer[TBUFMAXLINE]; //テキストバッファ
_tbuf *TextBuffer; //実体は配列RAM[]の中に確保する

_tbuf *TBufstart; //テキストバッファの先頭位置
_tbuf *cursorbp; //現在のカーソル位置のテキストバッファ
unsigned short cursorix; //現在のカーソル位置のテキストバッファ先頭からの位置
_tbuf *disptopbp; //現在表示中画面左上のテキストバッファ
unsigned short disptopix; //現在表示中画面左上のテキストバッファ先頭からの位置
int num; //現在バッファ内に格納されている文字数
int cx,cy; //カーソル座標
int cx2; //上下移動時の仮カーソルX座標
_tbuf *cursorbp1; //範囲選択時のカーソルスタート位置のテキストバッファ、範囲選択モードでない場合NULL
unsigned short cursorix1; //範囲選択時のカーソルスタート位置のテキストバッファ先頭からの位置
int cx1,cy1; //範囲選択時のカーソルスタート座標
int line_no; //現在のカーソル位置の行
int line_no1; //範囲選択時のカーソルスタート位置の行

// カーソル関連位置の一時避難用
_tbuf *cursorbp_t;
unsigned short cursorix_t;
_tbuf *disptopbp_t;
unsigned short disptopix_t;
int cx_t,cy_t,line_no_t;

//unsigned char clipboard[WIDTH_X2*EDITWIDTHY]; //クリップボード、最大サイズは編集画面領域と同じ
unsigned char *clipboard; //実体は配列RAM[]の中に確保する

int clipsize; //現在クリップボードに格納されている文字数
int edited; //保存後に変更されたかを表すフラグ

//配列RAM[]内にメモリ動的確保するためのポインタ
char *editormallocp;

//unsigned char filebuf[FILEBUFSIZE]; //ファイルアクセス用バッファ
unsigned char *filebuf; //実体は配列RAM[]の中に確保する

//unsigned char cwdpath[PATHNAMEMAX]; //現在のディレクトリのパス名
unsigned char *cwdpath; //実体は配列RAM[]の中に確保する

unsigned char currentfile[13],tempfile[13]; //編集中のファイル名、一時ファイル名

//unsigned char filenames[MAXFILENUM][13]; //ロード時のファイル名一覧バッファ
unsigned char (*filenames)[13]; //実体は配列RAM[]の中に確保する

//unsigned char undobuf[UNDOBUFSIZE]; //アンドゥ用バッファ
unsigned char *undobuf; //実体は配列RAM[]の中に確保する
unsigned char *undobuf_top; //アンドゥ用バッファの先頭を指すポインタ
int undobuf_used; //アンドゥ用バッファ使用量

const unsigned char Message1[]="Hit Any Key\n";
const unsigned char Message2[]="File System Error\n";
const unsigned char Message3[]="Retry:[Enter] / Quit:[ESC]\n";
const unsigned char ROOTDIR[]="\\";

unsigned char * editormalloc(int size){
//配列RAM[]内にサイズsizeの領域を確保し、先頭アドレスを返す
//確保できない場合は、エラー表示し動作停止
	unsigned char *p;
	if(editormallocp+size>RAM+RAMSIZE){
		printstr("Cannot allocate memory");
		while(1) asm("wait");
	}
	p=editormallocp;
	editormallocp+=size;
	return p;
}

void wait60thsec(unsigned short n){
	// 60分のn秒ウェイト（ビデオ画面の最下行信号出力終了まで待つ）
	n+=drawcount;
	while(drawcount!=n) asm(WAIT);
}

unsigned int bpixtopos(_tbuf *bp,unsigned int ix){
// テキストバッファ上の位置からテキスト全体の先頭から何文字目かを返す
// bp:テキストバッファポインタ
// ix:bp->Bufの先頭からの文字数
	unsigned int pos;
	_tbuf *sbp;
	pos=0;
	sbp=TBufstart;
	while(sbp!=bp){
		pos+=sbp->n;
		sbp=sbp->next;
		if(sbp==NULL) return 0; //エラー
	}
	return pos+ix;
}
_tbuf * postobpix(int pos,unsigned short *pix){
// テキスト全体の先頭からpos文字目のテキストバッファ上の位置を返す
// 戻り値　テキストバッファポインタ
// *pix（戻り値）：戻り値テキストバッファの先頭からの位置（ポインタ渡し）
	_tbuf *bp;
	bp=TBufstart;
	while(pos >= bp->n){
		if(bp->next==NULL) break; //全体最後尾の場合
		pos-=bp->n;
		bp=bp->next;
	}
	if(pos > bp->n){
		// オーバーランエラーの場合先頭を返す
		*pix=0;
		return TBufstart;
	}
	*pix=pos;
	return bp;
}
_tbuf * linetobpix(int line,unsigned short *pix){
// テキスト全体の先頭からline行目のテキストバッファ上の位置を返す
// 戻り値　テキストバッファポインタ
// *pix（戻り値）：戻り値テキストバッファの先頭からの位置（ポインタ渡し）
	_tbuf *bp,*bp2;
	int ix,ix2;
	bp=TBufstart;
	bp2=TBufstart;
	ix=0;
	ix2=0;
	while(line>1){
		while(1){
			if(ix>=bp->n){
				if(bp->next==NULL) break;
				bp=bp->next;
				ix=0;
				continue;
			}
			if(bp->Buf[ix++] == '\n'){
				bp2=bp;
				ix2=ix;
				break;
			}
		}
		line--;
	}
	*pix=ix2;
	return bp2;
}

_tbuf * newTBuf(_tbuf *prev){
// 新しいテキストバッファ1行を生成
// prev:挿入先の行（prevの後ろに追加）
// 戻り値　生成したバッファへのポインタ、生成できない場合NULL
	_tbuf *bp,*next;

	//バッファの先頭から空きをサーチ
	bp=TextBuffer;
	while(1){
		if(bp->prev==NULL && bp!=TBufstart) break;
		bp++;
		if(bp>=TextBuffer+TBUFMAXLINE) return NULL;//最後まで空きなし
	}
	next=prev->next;
	//行挿入
	bp->prev=prev;
	bp->next=next;
	prev->next=bp;
	if(next!=NULL) next->prev=bp;
	bp->n=0;
	return bp;
}

_tbuf * deleteTBuf(_tbuf *bp){
// テキストバッファの削除
// bp:削除する行のポインタ
// 戻り値　削除前の次のバッファへのポインタ、ない場合NULL
	unsigned short a,b;
	_tbuf *prev,*next;
	prev=bp->prev;
	next=bp->next;
	if(prev==NULL){
		//先頭行の場合
		if(next==NULL) return next; //最後の1行の場合は削除しない
		TBufstart=next; //次の行を先頭行設定
	}
	else prev->next=next; //前を次にリンク（最終行ならNULLがコピーされる）
	if(next!=NULL) next->prev=prev; //次があれば次を前にリンク
	bp->prev=NULL; //空きフラグ設定
	return next;
}

// アンドゥバッファ
/*
UNDOBUFSIZEバイトの環状バッファ。テキストバッファに対する変更発生ごとに、
変更内容、変更場所をバッファの先頭に記録し、先頭位置を進める。
アンドゥ実行が呼び出されると、バッファ先頭から読み出し、テキストバッファに対して
元に戻す変更を行う。
バッファがいっぱいになると、最後尾から消去（上書き）していく。

＜バッファ仕様＞
　開始位置：テキストバッファトップから何バイト目か（2バイト。下位、上位の順）
　繰り返し数：連続動作の場合の回数（2バイト。下位、上位の順）
　バッファの前からも後ろからも削除できるよう、先頭と最後に命令をおく。ただし、
　後ろの命令コードが10以上の場合は削除された文字そのものを意味する。
1文字挿入
　UNDO_INSERT,開始位置,UNDO_INSERT
1文字上書き
　UNDO_OVERWRITE,開始位置,消去文字 [,消去文字が0?9の場合さらに0を付加]
1文字削除（Delete）
　UNDO_DELETE,開始位置,消去文字 [,消去文字が0?9の場合さらに0を付加]
1文字削除（BackSpace）
　UNDO_BACKSPACE,開始位置,消去文字 [,消去文字が0?9の場合さらに0を付加]
連続挿入（Ctrl+Vで貼り付け）
　UNDO_CONTINS,開始位置,繰り返し数,UNDO_CONTINS
連続削除（領域選択して削除）
　UNDO_CONTDEL,繰り返し数,消去文字列,開始位置,繰り返し数,UNDO_CONTDEL
*/

void pushundomem(unsigned char c){
// アンドゥ用メモリの先頭に1バイトを貯める
// 空きがなくなった場合、最後尾の1命令分を無効化
	unsigned char *p;
	int n;

	if(undobuf_used>=UNDOBUFSIZE){
	//空きがない場合、最後尾のブロックのバイト数分をバッファ利用済み量から減らす
		p=undobuf_top-undobuf_used; //最後尾
		if(p<undobuf) p+=UNDOBUFSIZE;
		switch(*p){
			case UNDO_INSERT: //1文字挿入
				undobuf_used-=4;
				break;
			case UNDO_OVERWRITE: //1文字上書き
			case UNDO_DELETE: //1文字削除
			case UNDO_BACKSPACE: //1文字削除（BS）
				undobuf_used-=4;
				p+=3;
				if(p>=undobuf+UNDOBUFSIZE) p-=UNDOBUFSIZE;
				if(*p<10) undobuf_used--; //コード0?9の場合後ろに0が付加されている
				break;
			case UNDO_CONTINS: //連続挿入
				undobuf_used-=6;
				break;
			case UNDO_CONTDEL: //連続削除
				//繰り返し数の読み出し
				p++;
				if(p>=undobuf+UNDOBUFSIZE) p-=UNDOBUFSIZE;
				n=*p++;
				if(p>=undobuf+UNDOBUFSIZE) p-=UNDOBUFSIZE;
				n+=*p<<8;
				undobuf_used-=n+8;
				break;
		}
	}
	//アンドゥバッファ先頭に1バイト挿入し、先頭位置を1進める
	*undobuf_top++=c;
	if(undobuf_top>=undobuf+UNDOBUFSIZE) undobuf_top-=UNDOBUFSIZE;
	undobuf_used++;
}
void pushundomem2(unsigned short w){
// アンドゥバッファに2バイト貯める、下位、上位の順
	pushundomem((unsigned char)w);
	pushundomem(w>>8);
}
unsigned char popundomem(){
// アンドゥバッファから1バイト読み出し、先頭を1つ戻す
// 戻り値：読み出したコード
	undobuf_top--;
	if(undobuf_top<undobuf) undobuf_top+=UNDOBUFSIZE;
	undobuf_used--;
	return *undobuf_top;
}
unsigned short popundomem2(){
// アンドゥバッファから2バイト読み出し
// 戻り値：読み出した2バイトコード
	unsigned short w;
	w=popundomem()<<8;
	w+=popundomem();
	return w;
}
void setundobuf(int com,_tbuf *bp,unsigned short ix,unsigned char c,unsigned short n){
//アンドゥバッファにデータをセットする
//com:コマンド　1:1文字削除、2:1文字上書き、3:1文字挿入、4:連続削除、5:連続挿入開始
//bp,ix:バッファ上の実行場所（カーソル位置）
//c:文字（上書き、挿入の場合のみ使用）
//n:連続数（連続の場合のみ使用）
	unsigned short pos;

	pos=bpixtopos(bp,ix); //テキストバッファ先頭から何バイト目かを求める
	switch(com){
		case UNDO_INSERT: //1文字挿入
			pushundomem(com);
			pushundomem2(pos);
			pushundomem(com);
			break;
		case UNDO_OVERWRITE: //1文字上書き
		case UNDO_DELETE: //1文字削除（Delete）
		case UNDO_BACKSPACE: //1文字削除（BackSpace）
			pushundomem(com);
			pushundomem2(pos);
			pushundomem(c);
			if(c<10) pushundomem(0); //10未満のコードの場合0を付加
			break;
		case UNDO_CONTINS: //連続挿入
			pushundomem(com);
			pushundomem2(pos);
			pushundomem2(n);
			pushundomem(com);
			break;
		case UNDO_CONTDEL: //連続削除
			pushundomem(com);
			pushundomem2(n);
			break;
	}
}

int insertchar(_tbuf *bp,unsigned int ix,unsigned char c,int undo){
//テキストバッファbpの先頭からixバイトの位置にcを挿入
//undo 0:通常（アンドゥバッファに格納する）、1:連続挿入中、2:アンドゥ中
//戻り値　成功：0、不正または容量オーバー：-1、空きがあるはずなのに失敗：1
	unsigned char *p;

	if(ix > bp->n) return -1; //不正指定
	if(num >= TBUFMAXSIZE) return -1; //バッファ容量オーバー
	if(bp->n < TBUFSIZE){
		//ライン内だけで1バイト挿入可能//
		for(p=bp->Buf + bp->n ; p > bp->Buf+ix ; p--) *p=*(p-1);
		*p=c;
		if(!undo) setundobuf(UNDO_INSERT,bp,ix,0,0); //アンドゥバッファ設定
		bp->n++;
		num++; //バッファ使用量
//		if(bp->n >= TBUFSIZE && bp->next==NULL) newTBuf(bp); //バッファがいっぱいになったら新たにバッファ生成
		return 0;
	}
	//ラインがあふれる場合
	if(bp->next==NULL || bp->next->n >=TBUFSIZE){
		// 最終行または次のラインバッファがいっぱいだったら一行挿入
		if(newTBuf(bp)==NULL){
			// ラインバッファ挿入不可
			return 1;
		}
	}
	if(ix==TBUFSIZE){
		insertchar(bp->next,0,c,undo);
		return 0;
	}
	p=bp->Buf + TBUFSIZE-1;
	insertchar(bp->next,0,*p,1); //次の行の先頭に1文字挿入（必ず空きあり）
	for( ; p > bp->Buf+ix ; p--) *p=*(p-1);
	*p=c;
	if(!undo) setundobuf(UNDO_INSERT,bp,ix,0,0); //アンドゥバッファ設定
	return 0;
}

int overwritechar(_tbuf *bp,unsigned int ix,unsigned char c,int undo){
//テキストバッファbpの先頭からixバイトの位置をcで上書き
//undo 0:通常（アンドゥバッファに格納する）、1:連続中、2:アンドゥ中
//戻り値　成功：0、不正または容量オーバー：-1、空きがあるはずなのに失敗：1

	//現在のバッファ位置の文字が終端または改行の場合、挿入モード
	if(ix > bp->n) return -1; //不正指定
	while(ix >= bp->n){
		if(bp->next==NULL){
			//テキスト全体最後尾の場合は挿入
			return insertchar(bp,ix,c,undo);
		}
		bp=bp->next;
		ix=0;
	}
	if(bp->Buf[ix]=='\n') return insertchar(bp,ix,c,undo);
	if(!undo) setundobuf(UNDO_OVERWRITE,bp,ix,bp->Buf[ix],0); //アンドゥバッファ設定
	bp->Buf[ix]=c;
	return 0;
}

void deletechar(_tbuf *bp,unsigned int ix,int undo){
//テキストバッファbpの先頭からixバイトの位置の1バイト削除
//undo -1:通常BackSpace（アンドゥバッファに格納する）
//      0:通常DELETE（アンドゥバッファに格納する）、1:連続中、2:アンドゥ中
	unsigned char *p;

	if(ix > bp->n) return; //不正指定
	if(ix !=bp->n){
		//バッファの最後の文字より後ろでない場合

		//アンドゥバッファ設定
		if(undo==1) pushundomem(bp->Buf[ix]); //連続削除中
		else if(undo==-1) setundobuf(UNDO_BACKSPACE,bp,ix,bp->Buf[ix],0); //1文字削除(backspace)
		else if(undo==0) setundobuf(UNDO_DELETE,bp,ix,bp->Buf[ix],0); //1文字削除

		for(p=bp->Buf+ix ; p< bp->Buf + bp->n-1 ; p++) *p=*(p+1);
		bp->n--;
		num--; //バッファ使用量
		return;
	}
	//行バッファの現在の最後の場合（削除する文字がない場合）
	if(bp->next==NULL) return; //全体の最後の場合、何もしない
	deletechar(bp->next,0,undo); //次の行の先頭文字を削除
}
int gabagecollect1(void){
//断片化されたテキストバッファの隙間を埋めるガベージコレクション
//カーソルの前と後ろそれぞれ探索して最初の1バイト分のみ実施
//戻り値 1バイトでも移動した場合：1、なかった場合：0

	_tbuf *bp;
	int f=0;
	unsigned char *p,*p2;

	//カーソルがバッファの先頭にある場合、前のバッファの最後尾に変更
	//（ただし前に空きがない場合と先頭バッファの場合を除く）
	while(cursorix==0 && cursorbp->prev!=NULL && cursorbp->prev->n <TBUFSIZE){
		cursorbp=cursorbp->prev;
		cursorix=cursorbp->n;
	}
	//画面左上位置がバッファの先頭にある場合、前のバッファの最後尾に変更
	//（ただし先頭バッファの場合を除く）
	while(disptopix==0 && disptopbp->prev!=NULL){
		disptopbp=disptopbp->prev;
		disptopix=disptopbp->n;
	}
	//カーソルのあるバッファ以外の空バッファを全て削除
	bp=TBufstart;
	while(bp!=NULL){
		if(bp->n == 0 && bp!=cursorbp){
			if(bp==disptopbp) disptopbp=bp->next; //画面左上位置が空バッファ先頭の場合、次にずらす
			bp=deleteTBuf(bp); //空きバッファ削除
		}
		else bp=bp->next;
	}

	//カーソル位置より前の埋まっていないバッファを先頭からサーチ
	bp=TBufstart;
	while(bp->n >= TBUFSIZE){
		if(bp==cursorbp) break;
		bp=bp->next;
	}
	if(bp!=cursorbp){
		//最初に見つけた空き場所に次のバッファから1バイト移動
		bp->Buf[bp->n++] = bp->next->Buf[0];
		bp=bp->next;
		p=bp->Buf;
		p2=p+bp->n-1;
		for( ; p<p2 ; p++) *p=*(p+1);
		bp->n--;
		f=1;
		if(bp == disptopbp) disptopix--;
		if(bp == cursorbp) cursorix--;
//		else if(bp->n == 0) deleteTBuf(bp);
	}
	if(cursorbp->next ==NULL) return f; //カーソル位置が最終バッファなら終了
	//カーソル位置の次のバッファから埋まっていないバッファをサーチ
	bp=cursorbp;
	do{
		bp=bp->next;
		if(bp->next ==NULL) return f; //最終バッファに到達なら終了
	} while(bp->n >=TBUFSIZE);

	//最初に見つけた空き場所に次のバッファから1バイト移動
	bp->Buf[bp->n++] = bp->next->Buf[0];
	bp=bp->next;
	p=bp->Buf;
	p2=p+bp->n-1;
	for( ; p<p2 ; p++) *p=*(p+1);
	bp->n--;
	f=1;
	if(bp->n == 0) deleteTBuf(bp);
	return f;
}
void gabagecollect2(void){
// 変化がなくなるまで1バイト分のガベージコレクションを呼び出し
	while(gabagecollect1()) ;
}
void inittextbuf(void){
// テキストバッファの初期化
	_tbuf *bp;
	for(bp=TextBuffer;bp<TextBuffer+TBUFMAXLINE;bp++) bp->prev=NULL; //未使用バッファ化
	TBufstart=TextBuffer; //リンクの先頭設定
	TBufstart->next=NULL;
	TBufstart->n=0;
	num=0; //バッファ使用量
	edited=0; //編集済みフラグクリア
	undobuf_top=undobuf;
	undobuf_used=0;
}
void redraw(){
//画面の再描画
	unsigned char *vp;
	_tbuf *bp,*bp1,*bp2;
	int ix,ix1,ix2;
	int x,y;
	unsigned char ch,cl;

	vp=TVRAM;
	bp=disptopbp;
	ix=disptopix;
	cl=COLOR_NORMALTEXT;
	if(cursorbp1==NULL){
		//範囲選択モードでない場合
		bp1=NULL;
		bp2=NULL;
	}
	else{
		//範囲選択モードの場合、開始位置と終了の前後判断して
		//bp1,ix1を開始位置、bp2,ix2を終了位置に設定
		if(cy<cy1 || (cy==cy1 && cx<cx1)){
			bp1=cursorbp;
			ix1=cursorix;
			bp2=cursorbp1;
			ix2=cursorix1;
		}
		else{
			bp1=cursorbp1;
			ix1=cursorix1;
			bp2=cursorbp;
			ix2=cursorix;
		}
	}
	for(y=0;y<EDITWIDTHY;y++){
		if(bp==NULL) break;
		for(x=0;x<twidth;x++){
			//文字がある位置までサーチ
			while(ix>=bp->n){
				if(bp==bp1 && ix==ix1) cl=COLOR_AREASELECTTEXT;
				if(bp==bp2 && ix==ix2) cl=COLOR_NORMALTEXT;
				bp=bp->next;
				ix=0;
				if(bp==NULL) break;
			}
			if(bp==NULL) break; //バッファ最終
			if(bp==bp1 && ix==ix1) cl=COLOR_AREASELECTTEXT;
			if(bp==bp2 && ix==ix2) cl=COLOR_NORMALTEXT;
			ch=bp->Buf[ix++];
			if(ch=='\n') break;
			if(twidth==30) *(vp+ATTROFFSET1)=cl;
			else *(vp+ATTROFFSET2)=cl;
			*vp++=ch;
		}
		//改行およびバッファ最終以降の右側表示消去
		if(twidth==30){
			for(;x<WIDTH_X1;x++){
				*(vp+ATTROFFSET1)=0;
				*vp++=0;
			}
		}
		else{
			for(;x<WIDTH_X2;x++){
				*(vp+ATTROFFSET2)=0;
				*vp++=0;
			}
		}
	}
	//バッファ最終以降の下側表示消去
	for(;y<EDITWIDTHY;y++){
		if(twidth==30){
			for(x=0;x<WIDTH_X1;x++){
				*(vp+ATTROFFSET1)=0;
				*vp++=0;
			}
		}
		else{
			for(x=0;x<WIDTH_X2;x++){
				*(vp+ATTROFFSET2)=0;
				*vp++=0;
			}
		}
	}
}

void cursor_left(void){
//カーソルを1つ前に移動
//出力：下記変数を移動先の値に変更
//cursorbp,cursorix バッファ上のカーソル位置
//cx,cy 画面上のカーソル位置
//cx2 cxと同じ
//disptopbp,disptopix 画面左上のバッファ上の位置

	_tbuf *bp;
	int ix;
	int i;
	int x;

	//バッファ上のカーソル位置を1つ前に移動
	if(cursorix!=0) cursorix--;
	else while(1) {
		//1つ前のバッファの最後尾に移動、ただし空バッファは飛ばす
		if(cursorbp->prev==NULL) return; //テキスト全体先頭なので移動しない
		cursorbp=cursorbp->prev;
		if(cursorbp->n >0){
			cursorix=cursorbp->n-1;//バッファ最後尾
			break;
		}
	}

	//カーソルおよび画面左上位置の更新
	if(cx>0){
		//左端でなければカーソルを単純に1つ左に移動して終了
		cx--;
		cx2=cx;
		return;
	}
	if(cy>0){
		//左端だが上端ではない場合
		if(cursorbp->Buf[cursorix]!='\n'){
			// 移動先が改行コードでない場合、カーソルは1つ上の行の右端に移動
			cx=twidth-1;
			cx2=cx;
			cy--;
			return;
		}
		//画面左上位置から最後尾のX座標をサーチ
		bp=disptopbp;
		ix=disptopix;
		x=0;
		while(ix!=cursorix || bp!=cursorbp){
			if(bp->n==0){
				//空バッファの場合次へ
				bp=bp->next;
				ix=0;
				continue;
			}
			if(bp->Buf[ix++]=='\n' || x>=twidth-1) x=0;
			else x++;
			if(ix >= bp->n){
				bp=bp->next;
				ix=0;
			}
		}
		cx=x;
		cx2=cx;
		cy--;
		line_no--;
		return;
	}

	//左端かつ上端の場合
	if(cursorbp->Buf[cursorix]!='\n'){
		// 移動先が改行コードでない場合、カーソルは右端に移動
		// 画面左上位置は画面横幅分前に移動
		cx=twidth-1;
		cx2=cx;
	}
	else{
		//移動先が改行コードの場合
		//行頭（改行の次の文字またはバッファ先頭）と現在位置の文字数差を
		//画面横幅で割った余りがカーソルX座標
		bp=cursorbp;
		ix=cursorix;
		i=0;
		while(1){
			if(ix==0){
				if(bp->prev==NULL) break;
				bp=bp->prev;
				ix=bp->n;
				continue;
			}
			ix--;
			if(bp->Buf[ix]=='\n') break;
			i++;
		}
		cx=i % twidth;
		cx2=cx;
		line_no--;
	}
	//画面左上位置は現在位置からX座標分引いたところ
	bp=cursorbp;
	ix=cursorix;
	x=cx;
	while(x>0){
		if(ix==0){
			bp=bp->prev;
			ix=bp->n;
			continue;
		}
		ix--;
		x--;
	}
	disptopbp=bp;
	disptopix=ix;
}
void cursor_right(void){
//カーソルを1つ後ろに移動
//出力：下記変数を移動先の値に変更
//cursorbp,cursorix バッファ上のカーソル位置
//cx,cy 画面上のカーソル位置
//cx2 cxと同じ
//disptopbp,disptopix 画面左上のバッファ上の位置

	_tbuf *bp;
	int ix;
	int i;
	int x;
	unsigned char c;

	if(cursorix >= cursorbp->n){
		//バッファ最後尾の場合、次の先頭に移動
		bp=cursorbp;
		while(1) {
			//空バッファは飛ばす
			if(bp->next==NULL) return; //テキスト全体最後尾なので移動しない
			bp=bp->next;
			if(bp->n >0) break;
		}
		cursorbp=bp;
		cursorix=0;//バッファ先頭
	}
	c=cursorbp->Buf[cursorix++]; //バッファ上のカーソル位置のコードを読んで1つ後ろに移動
	if(c!='\n' && cx<twidth-1){
		//カーソル位置が改行でも右端でもない場合単純に1つ右に移動して終了
		cx++;
		cx2=cx;
		return;
	}
	cx=0; //カーソルを左端に移動
	cx2=cx;
	if(c=='\n') line_no++;
	if(cy<EDITWIDTHY-1){
		//下端でなければカーソルを次行に移動して終了
		cy++;
		return;
	}
	//下端の場合
	//画面左上位置を更新
	//改行コードまたは画面横幅超えるまでサーチ
	bp=disptopbp;
	ix=disptopix;
	x=0;
	while(x<twidth){
		if(ix >= bp->n){
			bp=bp->next;
			ix=0;
			continue;
		}
		if(bp->Buf[ix++]=='\n') break;
		x++;
	}
	disptopbp=bp;
	disptopix=ix;
}
void cursor_up(void){
//カーソルを1つ上に移動
//出力：下記変数を移動先の値に変更
//cursorbp,cursorix バッファ上のカーソル位置
//cx,cy 画面上のカーソル位置
//cx2 移動前のcxと同じ
//disptopbp,disptopix 画面左上のバッファ上の位置

	_tbuf *bp;
	int ix;
	int i;
	int x;
	unsigned char c;

	//画面幅分前に戻ったところがバッファ上カーソルの移動先
	//途中で改行コードがあれば別の手段で検索
	bp=cursorbp;
	ix=cursorix;
	i=cx2-cx;
	while(i<twidth){
		if(ix==0){
			if(bp->prev==NULL) return; //バッファ先頭までサーチしたら移動なし
			bp=bp->prev;
			ix=bp->n;
			continue;
		}
		ix--;
		if(bp->Buf[ix]=='\n') break;
		i++;
	}
	cursorbp=bp;
	cursorix=ix;
	//画面幅の間に改行コードがなかった場合
	if(i==twidth){
		cx=cx2;
		//画面上端でなければカーソルを1つ上に移動して終了
		if(cy>0){
			cy--;
			return;
		}
		//画面上端の場合、カーソル位置からX座標分戻ったところが画面左上位置
		x=cx;
		while(x>0){
			if(ix==0){
				bp=bp->prev;
				ix=bp->n;
				continue;
			}
			ix--;
			x--;
		}
		disptopbp=bp;
		disptopix=ix;
		return;
	}
	//改行が見つかった場合
	//行頭（改行の次の文字またはバッファ先頭）と現在位置の文字数差を
	//画面横幅で割った余りを求める
	line_no--;
	i=0;
	while(1){
		if(ix==0){
			if(bp->prev==NULL) break;
			bp=bp->prev;
			ix=bp->n;
			continue;
		}
		ix--;
		if(bp->Buf[ix]=='\n') break;
		i++;
	}
	x=i % twidth; //改行ブロックの最終行の右端
	bp=cursorbp;
	ix=cursorix;
	//バッファ上のカーソル位置は改行ブロックの最終行右端からカーソルX座標分戻る
	//最終行右端のほうが小さい場合、その場所をバッファ上のカーソル位置とする
	while(x>cx2){
		if(ix==0){
			bp=bp->prev;
			ix=bp->n;
			continue;
		}
		ix--;
		x--;
	}
	cursorbp=bp;
	cursorix=ix;
	cx=x; //cx2または改行ブロック最終行右端
	if(cy>0){
		//画面上端でなければカーソルを1つ上に移動して終了
		cy--;
		return;
	}
	//画面上端の場合
	//画面左上位置は現在位置からX座標分引いたところ
	while(x>0){
		if(ix==0){
			bp=bp->prev;
			ix=bp->n;
			continue;
		}
		ix--;
		x--;
	}
	disptopbp=bp;
	disptopix=ix;
}
void cursor_down(void){
//カーソルを1つ下に移動
//出力：下記変数を移動先の値に変更
//cursorbp,cursorix バッファ上のカーソル位置
//cx,cy 画面上のカーソル位置
//cx2 移動前のcxと同じ
//disptopbp,disptopix 画面左上のバッファ上の位置

	_tbuf *bp;
	int ix;
	int x;
	unsigned char c;

	//次行の先頭サーチ
	//カーソル位置から画面右端までの間に改行コードがあれば次の文字が先頭
	bp=cursorbp;
	ix=cursorix;
	x=cx;
	while(x<twidth){
		if(ix>=bp->n){
			if(bp->next==NULL) return; //バッファ最後までサーチしたら移動なし
			bp=bp->next;
			ix=0;
			continue;
		}
		c=bp->Buf[ix];
		ix++;
		x++;
		if(c=='\n'){
			line_no++;
			break;
		}
	}
	//次行先頭からcx2文字数分後ろにサーチ
	x=0;
	while(x<cx2){
		if(ix>=bp->n){
			if(bp->next==NULL) break; //バッファ最後の場合そこに移動
			bp=bp->next;
			ix=0;
			continue;
		}
		if(bp->Buf[ix]=='\n') break; //改行コードの場合そこに移動
		ix++;
		x++;
	}
	cursorbp=bp;
	cursorix=ix;
	cx=x;
	//画面下端でなければカーソルを1つ下に移動して終了
	if(cy<EDITWIDTHY-1){
		cy++;
		return;
	}
	//下端の場合
	//画面左上位置を更新
	//改行コードまたは画面横幅超えるまでサーチ
	bp=disptopbp;
	ix=disptopix;
	x=0;
	while(x<twidth){
		if(ix >= bp->n){
			bp=bp->next;
			ix=0;
			continue;
		}
		if(bp->Buf[ix++]=='\n') break;
		x++;
	}
	disptopbp=bp;
	disptopix=ix;
}
void cursor_home(void){
//カーソルを行先頭に移動
//出力：下記変数を移動先の値に変更
//cursorbp,cursorix バッファ上のカーソル位置
//cx,cx2 0
//cy 変更なし
//disptopbp,disptopix 画面左上のバッファ上の位置（変更なし）

	//カーソルX座標分前に移動
	while(cx>0){
		if(cursorix==0){
			//空バッファは飛ばす
			cursorbp=cursorbp->prev;
			cursorix=cursorbp->n;
			continue;
		}
		cursorix--;
		cx--;
	}
	cx2=0;
}
void cursor_end(void){
//カーソルを行末に移動
//出力：下記変数を移動先の値に変更
//cursorbp,cursorix バッファ上のカーソル位置
//cx,cx2 行末
//cy 変更なし
//disptopbp,disptopix 画面左上のバッファ上の位置（変更なし）

	//カーソルX座標を画面幅分後ろに移動
	//改行コードまたはバッファ最終があればそこに移動
	while(cx<twidth-1){
		if(cursorix>=cursorbp->n){
			//空バッファは飛ばす
			if(cursorbp->next==NULL) break;
			cursorbp=cursorbp->next;
			cursorix=0;
			continue;
		}
		if(cursorbp->Buf[cursorix]=='\n') break;
		cursorix++;
		cx++;
	}
	cx2=cx;
}
void cursor_pageup(void){
//PageUpキー
//最上行が最下行になるまでスクロール
//出力：下記変数を移動先の値に変更
//cursorbp,cursorix バッファ上のカーソル位置
//cx,cx2
//cy
//disptopbp,disptopix 画面左上のバッファ上の位置

	_tbuf *bp;
	int ix;
	int i;
	int cy_old;

	cy_old=cy;
	while(cy>0) cursor_up(); // cy==0になるまでカーソルを上に移動
	for(i=0;i<EDITWIDTHY-1;i++){
		//画面行数-1行分カーソルを上に移動
		bp=disptopbp;
		ix=disptopix;
		cursor_up();
		if(bp==disptopbp && ix==disptopix) break; //最上行で移動できなかった場合抜ける
	}
	//元のY座標までカーソルを下に移動、1行も動かなかった場合は最上行に留まる
	if(i>0) while(cy<cy_old) cursor_down();
}
void cursor_pagedown(void){
//PageDownキー
//最下行が最上行になるまでスクロール
//出力：下記変数を移動先の値に変更
//cursorbp,cursorix バッファ上のカーソル位置
//cx,cx2
//cy
//disptopbp,disptopix 画面左上のバッファ上の位置

	_tbuf *bp;
	int ix;
	int i;
	int y;
	int cy_old;

	cy_old=cy;
	while(cy<EDITWIDTHY-1){
		// cy==EDITWIDTH-1になるまでカーソルを下に移動
		y=cy;
		cursor_down();
		if(y==cy) break;// バッファ最下行で移動できなかった場合抜ける
	}
	for(i=0;i<EDITWIDTHY-1;i++){
		//画面行数-1行分カーソルを下に移動
		bp=disptopbp;
		ix=disptopix;
		cursor_down();
		if(bp==disptopbp && ix==disptopix) break; //最下行で移動できなかった場合抜ける
	}
	//下端からさらに移動した行数分、カーソルを上に移動、1行も動かなかった場合は最下行に留まる
	if(i>0) while(cy>cy_old) cursor_up();
}
void cursor_top(void){
//カーソルをテキストバッファの先頭に移動
	cursorbp=TBufstart;
	cursorix=0;
	cursorbp1=NULL; //範囲選択モード解除
	disptopbp=cursorbp;
	disptopix=cursorix;
	cx=0;
	cx2=0;
	cy=0;
	line_no=1;
}

int countarea(void){
//テキストバッファの指定範囲の文字数をカウント
//範囲は(cursorbp,cursorix)と(cursorbp1,cursorix1)で指定
//後ろ側の一つ前の文字までをカウント
	_tbuf *bp1,*bp2;
	int ix1,ix2;
	int n;

	//範囲選択モードの場合、開始位置と終了の前後判断して
	//bp1,ix1を開始位置、bp2,ix2を終了位置に設定
	if(cy<cy1 || (cy==cy1 && cx<cx1)){
		bp1=cursorbp;
		ix1=cursorix;
		bp2=cursorbp1;
		ix2=cursorix1;
	}
	else{
		bp1=cursorbp1;
		ix1=cursorix1;
		bp2=cursorbp;
		ix2=cursorix;
	}
	n=0;
	while(1){
		if(bp1==bp2 && ix1==ix2) return n;
		if(ix1 < bp1->n){
			n++;
			ix1++;
		}
		else{
			bp1=bp1->next;
			ix1=0;
		}
	}
}
void deletearea_len(_tbuf *bp,unsigned int ix,int n,int undo){
//テキストバッファの指定位置から複数文字削除
//bp,ix:削除開始位置
//n:削除する文字数
//undo:0:通常、2:アンドゥ中
	unsigned char *p;
	int i;

	//選択範囲が最初のバッファの最後まである場合
	if(n>=(bp->n - ix)){
		if(!undo){
			p=bp->Buf+ix;
			for(i=ix;i < bp->n;i++) pushundomem(*p++); //アンドゥバッファに格納
		}
		n -= bp->n - ix; //削除文字数減
		num-=bp->n - ix; //バッファ使用量を減数
		bp->n=ix; //ix以降を削除
		bp=bp->next;
		if(bp==NULL) return;
		ix=0;
	}
	//次のバッファ以降、選択範囲の終了位置が含まれないバッファは削除
	while(n>=bp->n){
		if(!undo){
			p=bp->Buf;
			for(i=0;i < bp->n;i++) pushundomem(*p++); //アンドゥバッファに格納
		}
		n-=bp->n; //削除文字数減
		num-=bp->n; //バッファ使用量を減数
		bp=deleteTBuf(bp); //バッファ削除して次のバッファに進む
		if(bp==NULL) return;
	}
	//選択範囲の終了位置を含む場合、1文字ずつ削除
	if(!undo) undo=1;
	while(n>0){
		deletechar(bp,ix,undo); //バッファから1文字削除（numは関数内で1減される）
		n--;
	}
}
void deletearea(void){
//テキストバッファの指定範囲を削除
//範囲は(cursorbp,cursorix)と(cursorbp1,cursorix1)で指定
//後ろ側の一つ前の文字までを削除
//削除後のカーソル位置は選択範囲の先頭にし、範囲選択モード解除する

	_tbuf *bp;
	int ix;
	int n;

	n=countarea(); //選択範囲の文字数カウント
	if(n==0) return;

	//範囲選択の開始位置と終了位置の前後を判断してカーソルを開始位置に設定
	if(cy>cy1 || (cy==cy1 && cx>cx1)){
		cursorbp=cursorbp1;
		cursorix=cursorix1;
		cx=cx1;
		cy=cy1;
		line_no=line_no1;
	}
	cx2=cx;
	cursorbp1=NULL; //範囲選択モード解除

	//bp,ixを開始位置に設定
	bp=cursorbp;
	ix=cursorix;

	setundobuf(UNDO_CONTDEL,bp,ix,0,n); //アンドゥバッファ設定（連続削除開始）
	deletearea_len(bp,ix,n,0); //n文字分削除
	//アンドゥバッファに連続削除終了設定
	pushundomem2(bpixtopos(bp,ix));
	pushundomem2(n);
	pushundomem(UNDO_CONTDEL);
}
void clipcopy(void){
// 選択範囲をクリップボードにコピー
	_tbuf *bp1,*bp2;
	int ix1,ix2;
	char *ps,*pd;

	//範囲選択モードの場合、開始位置と終了の前後判断して
	//bp1,ix1を開始位置、bp2,ix2を終了位置に設定
	if(cy<cy1 || (cy==cy1 && cx<cx1)){
		bp1=cursorbp;
		ix1=cursorix;
		bp2=cursorbp1;
		ix2=cursorix1;
	}
	else{
		bp1=cursorbp1;
		ix1=cursorix1;
		bp2=cursorbp;
		ix2=cursorix;
	}
	ps=bp1->Buf+ix1;
	pd=clipboard;
	clipsize=0;
	while(bp1!=bp2 || ix1!=ix2){
		if(ix1 < bp1->n){
			*pd++=*ps++;
			clipsize++;
			ix1++;
		}
		else{
			bp1=bp1->next;
			ps=bp1->Buf;
			ix1=0;
		}
	}
}
void clippaste(void){
// クリップボードから貼り付け
	int n,i;
	unsigned char *p;

	if(clipsize==0 || num+clipsize>TBUFMAXSIZE) return;
	setundobuf(UNDO_CONTINS,cursorbp,cursorix,0,clipsize); //アンドゥバッファ設定
	p=clipboard;
	for(n=clipsize;n>0;n--){
		i=insertchar(cursorbp,cursorix,*p,1);
		if(i>0){
			//バッファ空きがあるのに挿入失敗の場合
			gabagecollect2(); //全体ガベージコレクション
			i=insertchar(cursorbp,cursorix,*p,1);//テキストバッファに１文字挿入
		}
		if(i!=0) break;//挿入失敗
		cursor_right();//画面上、バッファ上のカーソル位置を1つ後ろに移動
		p++;
	}
}
void movecursor(int pos){
// カーソルを現在の位置から任意の位置に移動
// pos：移動したいテキストバッファ先頭からのバイト位置
	int pos2,d;
	pos2=bpixtopos(cursorbp,cursorix);
	d=pos-pos2;
	if(d==0) return;
	if(d>0){
		while(d>0){
			cursor_right();
			d--;
		}
	}
	else{
		while(d<0){
			cursor_left();
			d++;
		}
	}
}
void undoexec(){
//アンドゥ実行
	unsigned char c,c1;
	_tbuf *bp;
	unsigned short n,ix;
	int pos;

	if(undobuf_used==0) return; //アンドゥバッファ空
	cursorbp1=NULL; //範囲選択解除
	c=popundomem(); //アンドゥバッファ先頭の命令読み出し
	switch(c){
		case UNDO_INSERT: //1文字挿入
			//カーソル移動し1文字削除
			pos=popundomem2();
			movecursor(pos);
			bp=postobpix(pos,&ix);
			deletechar(bp,ix,2);
			popundomem(); //dummy read
			break;
		case UNDO_CONTINS: //連続挿入
			//カーソル移動し連続数分削除
			n=popundomem2();
			pos=popundomem2();
			movecursor(pos);
			bp=postobpix(pos,&ix);
			deletearea_len(bp,ix,n,2);
			popundomem(); //dummy read
			break;
		case UNDO_CONTDEL: //連続削除
			//カーソル移動し連続数分、コードを読み出して挿入
			n=popundomem2();
			pos=popundomem2();
			movecursor(pos);
			bp=postobpix(pos,&ix);
			while(n>0){
				insertchar(bp,ix,popundomem(),2);
				n--;
			}
			popundomem2(); //dummy read
			popundomem(); //dummy read
			break;
		case 0: //0の場合、次の1バイトが実際の有効なコード
			c=popundomem();
		default: //1文字削除（DEL、BS）、1文字上書き
			//カーソル移動し1文字挿入（または上書き）
			pos=popundomem2();
			movecursor(pos);
			bp=postobpix(pos,&ix);
			c1=popundomem();
			if(c1==UNDO_OVERWRITE){
				overwritechar(bp,ix,c,2);
			}
			else{
				insertchar(bp,ix,c,2);
				if(c1==UNDO_BACKSPACE) cursor_right();
			}
			break;
	}
}

void set_areamode(){
//範囲選択モード開始時のカーソル開始位置グローバル変数設定
	cursorbp1=cursorbp;
	cursorix1=cursorix;
	cx1=cx;
	cy1=cy;
	line_no1=line_no;
}
void save_cursor(void){
//カーソル関連グローバル変数を一時避難
	cursorbp_t=cursorbp;
	cursorix_t=cursorix;
	disptopbp_t=disptopbp;
	disptopix_t=disptopix;
	cx_t=cx;
	cy_t=cy;
	line_no_t=line_no;
}
void restore_cursor(void){
//カーソル関連グローバル変数を一時避難場所から戻す
	cursorbp=cursorbp_t;
	cursorix=cursorix_t;
	disptopbp=disptopbp_t;
	disptopix=disptopix_t;
	cx=cx_t;
	cy=cy_t;
	line_no=line_no_t;
}

int filesystemretry(){
// SDファイルシステムの再初期化確認と実施
// SDファイルへの保存や読み込み時にファイルエラーが発生した場合に呼び出す
// 戻り値　0：初期化成功、-1：成功することなくEscapeで抜けた
	unsigned short vk;
	while(1){
		setcursorcolor(COLOR_NORMALTEXT);
		printstr((unsigned char *)Message3); //Retry / Quit
		while(1){
			inputchar(); //1文字入力待ち
			vk=vkey & 0xff;
			if(vk==VK_RETURN || vk==VK_SEPARATOR) break;
			if(vk==VK_ESCAPE) return -1;
		}
		//ファイルシステム初期化
		if(FSInit()!=FALSE) return 0; //成功
		//エラーの場合
		setcursorcolor(COLOR_ERRORTEXT);
		printstr((unsigned char *)Message2);//File System Error
	}
}

int sdfilecopy(char *sourcefile,char *distfile){
// SDカード上のファイルをコピー
// soucefile:コピー元ファイル名
// distfile:コピー先ファイル名
// 戻り値：正常終了 0、エラー終了時エラー番号
	FSFILE *sfp,*dfp;
	int n,er,c;
	er=0;
	sfp=FSfopen(sourcefile,"r");
	if(sfp==NULL) return ERR_CANTFILEOPEN;
	dfp=FSfopen(distfile,"w");
	if(dfp==NULL){
		FSfclose(sfp);
		return ERR_CANTFILEOPEN;
	}
	c=0;
	while(1){
		if(c==0){
			printchar('.');
			c=100;
		}
		c--;
		n=FSfread(filebuf,1,FILEBUFSIZE,sfp);
		if(n==0) break;
		if(FSfwrite(filebuf,1,n,dfp)!=n){
			er=ERR_CANTWRITEFILE;
			break;
		}
	}
	FSfclose(sfp);
	FSfclose(dfp);
	return er;
}
int savetextfile(char *filename){
// テキストバッファをテキストファイルに書き込み
// 書き込み成功で0、失敗でエラーコード（負数）を返す
	FSFILE *fp;
	_tbuf *bp;
	int ix,n,i,er;
	unsigned char *ps,*pd;
	er=0;//エラーコード
	i=-1;
	fp=FSfopen(filename,"w");
	if(fp==NULL) return ERR_CANTFILEOPEN;
	bp=TBufstart;
	ix=0;
	ps=bp->Buf;
	do{
		pd=filebuf;
		n=0;
		while(n<FILEBUFSIZE-1){
		//改行コードが2バイトになることを考慮してバッファサイズ-1までとする
			while(ix>=bp->n){
				bp=bp->next;
				if(bp==NULL){
					break;
				}
				ix=0;
				ps=bp->Buf;
			}
			if(bp==NULL) break;
			if(*ps=='\n'){
				*pd++='\r'; //改行コード0A→0D 0Aにする
				n++;
			}
			*pd++=*ps++;
			ix++;
			n++;
		}
		if(n>0){
			i=FSfwrite(filebuf,1,n,fp);
			if(i!=n) er=ERR_CANTWRITEFILE;
		}
	} while(bp!=NULL && er==0);
	FSfclose(fp);
	return er;
}
int loadtextfile(char *filename){
// テキストファイルをテキストバッファに読み込み
// 読み込み成功で0、失敗でエラーコード（負数）を返す
	FSFILE *fp;
	_tbuf *bp;
	int ix,n,i,er;
	unsigned char *ps,*pd;
	er=0;//エラーコード
	fp=FSfopen(filename,"r");
	if(fp==NULL) return ERR_CANTFILEOPEN;
	inittextbuf();
	bp=TextBuffer;
	ix=0;
	pd=bp->Buf;
	do{
		n=FSfread(filebuf,1,FILEBUFSIZE,fp);
		ps=filebuf;
		for(i=0;i<n;i++){
			if(ix>=TBUFSIZE){
				bp->n=TBUFSIZE;
				bp=newTBuf(bp);
				if(bp==NULL){
					er=ERR_FILETOOBIG;
					break;
				}
				ix=0;
				pd=bp->Buf;
			}
			if(*ps=='\r') ps++; //改行コード0D 0A→0Aにする（単純に0D無視）
			else{
				*pd++=*ps++;
				ix++;
				num++;//バッファ総文字数
				if(num>TBUFMAXSIZE){
					er=ERR_FILETOOBIG;
					break;
				}
			}
		}
	} while(n==FILEBUFSIZE && er==0);
	if(bp!=NULL) bp->n=ix;//最後のバッファの文字数
	FSfclose(fp);
	if(er){
		//エラー発生の場合バッファ、カーソル位置初期化
		inittextbuf();
		cursor_top();
	}
	return er;
}
int overwritecheck(char *fn){
// ファイルの上書き確認
// ファイルの存在をチェックし、存在する場合キーボードから上書き確認する
// fn:ファイル名へのポインタ
// 戻り値　0：存在しないまたは上書き、-1：上書きしない
	SearchRec sr;
	unsigned short vk;
	if(FindFirst(fn,ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_ARCHIVE,&sr)) return 0; //ファイルが存在しない
	setcursorcolor(COLOR_ERRORTEXT);
	printstr(fn);
	printstr(": File Exists\n");
	setcursorcolor(COLOR_NORMALTEXT);
	printstr("Ovewrite:[Enter] / Stop:[ESC]\n");
	while(1){
		inputchar(); //1文字入力待ち
		vk=vkey & 0xff;
		if(vk==VK_RETURN || vk==VK_SEPARATOR) return 0;
		if(vk==VK_ESCAPE) return -1;
	}
}
void printfilename(unsigned char x,unsigned char y,int f,int num_dir){
// x,yの位置にファイル名またはディレクトリ名を表示

	if(f==-2){
		setcursor(x,y,COLOR_ERRORTEXT);
		printchar('<');
		printstr("New FILE");
		printchar('>');
	}
	else if(f==-1){
		setcursor(x,y,COLOR_ERRORTEXT);
		printchar('<');
		printstr("New Dir");
		printchar('>');
	}
	else if(f<num_dir){
		setcursor(x,y,COLOR_DIR);
		printchar('[');
		printstr(filenames[f]);
		printchar(']');
	}
	else{
		setcursor(x,y,COLOR_NORMALTEXT);
		printstr(filenames[f]);
	}
}
int select_dir_file(int filenum,int num_dir, unsigned char* msg){
// filenames[]配列に読み込まれたファイルまたはディレクトリを画面表示しキーボードで選択する
// filenum:ファイル＋ディレクトリ数
// num_dir:ディレクトリ数（filenames[]は先頭からnum_dir-1までがディレクトリ）
// msg:画面上部に表示するメッセージ
// 戻り値
//　filenames[]の選択されたファイルまたはディレクトリ番号
//　-1：新規ディレクトリ作成、tempfile[]にディレクトリ名
//　-2：新規ファイル作成、tempfile[]にファイル名
//　-3：ESCキーが押された
	int top,f;
	unsigned char *ps,*pd;
	int x,y;
	unsigned char vk;
	//ファイル一覧を画面に表示
	cls();
	setcursor(0,0,COLOR_NORMALTEXT);
	printstr(msg);
	printstr(": ");
	setcursorcolor(4);
	printstr("Select&[Enter] / [ESC]\n");
	for(f=-2;f<filenum;f++){
		x=(f&1)*15+1;
		y=(f+2)/2+1;
		if(y>=WIDTH_Y-1) break;
		printfilename(x,y,f,num_dir);
	}
	top=-2;//画面一番先頭のファイル番号
	f=-2;//現在選択中のファイル番号
	while(1){
		setcursor((f&1)*15,(f-top)/2+1,5);
		printchar(0x1c);// Right Arrow
		cursor--;
		while(1){
			inputchar();
			vk=vkey & 0xff;
			if(vk) break;
		}
		printchar(' ');
		setcursor(0,WIDTH_Y-1,COLOR_NORMALTEXT);
		for(x=0;x<twidth-1;x++) printchar(' '); //最下行のステータス表示を消去
		switch(vk){
			case VK_UP:
			case VK_NUMPAD8:
				//上矢印キー
				if(f>=0){
					f-=2;
					if(f<top){
						//画面最上部の場合、下にスクロールして最上部にファイル名2つ表示
						if(twidth==WIDTH_X1){
							setcursor(WIDTH_X1-1,WIDTH_Y-2,COLOR_NORMALTEXT);
							while(cursor>=TVRAM+WIDTH_X1*2){
								*cursor=*(cursor-WIDTH_X1);
								*(cursor+ATTROFFSET1)=*(cursor+ATTROFFSET1-WIDTH_X1);
								cursor--;
							}
							while(cursor>=TVRAM+WIDTH_X1) *cursor--=' ';
						}
						else{
							setcursor(WIDTH_X2-1,WIDTH_Y-2,COLOR_NORMALTEXT);
							while(cursor>=TVRAM+WIDTH_X2*2){
								*cursor=*(cursor-WIDTH_X2);
								*(cursor+ATTROFFSET2)=*(cursor+ATTROFFSET2-WIDTH_X2);
								cursor--;
							}
							while(cursor>=TVRAM+WIDTH_X2) *cursor--=' ';
						}
						top-=2;
						printfilename(1,1,top,num_dir);
						printfilename(16,1,top+1,num_dir);
					}
				}
				break;
			case VK_DOWN:
			case VK_NUMPAD2:
				//下矢印キー
				if(((f+2)&0xfffe)<filenum){
					f+=2;
					if(f>=filenum) f--;
					if(f-top>=(WIDTH_Y-2)*2){
						//画面最下部の場合、上にスクロールして最下部にファイル名1つor2つ表示
						setcursor(0,1,COLOR_NORMALTEXT);
						if(twidth==WIDTH_X1){
							while(cursor<TVRAM+WIDTH_X1*(WIDTH_Y-2)){
								*cursor=*(cursor+WIDTH_X1);
								*(cursor+ATTROFFSET1)=*(cursor+ATTROFFSET1+WIDTH_X1);
								cursor++;
							}
							while(cursor<TVRAM+WIDTH_X1*(WIDTH_Y-1)) *cursor++=' ';
						}
						else{
							while(cursor<TVRAM+WIDTH_X2*(WIDTH_Y-2)){
								*cursor=*(cursor+WIDTH_X2);
								*(cursor+ATTROFFSET2)=*(cursor+ATTROFFSET2+WIDTH_X2);
								cursor++;
							}
							while(cursor<TVRAM+WIDTH_X2*(WIDTH_Y-1)) *cursor++=' ';
						}
						top+=2;
						printfilename(1,WIDTH_Y-2,f&0xfffe,num_dir);
						if((f|1)<filenum){
							printfilename(16,WIDTH_Y-2,f|1,num_dir);
						}
					}
				}
				break;
			case VK_LEFT:
			case VK_NUMPAD4:
				//左矢印キー
				if(f&1) f--;
				break;
			case VK_RIGHT:
			case VK_NUMPAD6:
				//右矢印キー
				if((f&1)==0 && f+1<filenum) f++;
				break;
			case VK_RETURN: //Enterキー
			case VK_SEPARATOR: //テンキーのEnter
				if(f==-2){
					//新規ファイル
					setcursor(0,WIDTH_Y-1,COLOR_ERRORTEXT);
					printstr("Input File Name: ");
					setcursorcolor(COLOR_NORMALTEXT);
					//ファイル名入力
					*tempfile=0;
					if(lineinput(tempfile,8+1+3)<0) break; //ESCキー
					if(*tempfile==0) break; //ファイル名入力なし
				}
				else if(f==-1){
					//新規ディレクトリ
					setcursor(0,WIDTH_Y-1,COLOR_ERRORTEXT);
					printstr("Input Dir Name: ");
					setcursorcolor(COLOR_NORMALTEXT);
					//ディレクトリ名入力
					*tempfile=0;
					if(lineinput(tempfile,8+1+3)<0) break; //ESCキー
					if(FSmkdir(tempfile)){
						setcursor(0,WIDTH_Y-1,COLOR_ERRORTEXT);
						printstr("Cannot Make Directory        ");
						break;
					}
				}
				else{
					//ファイル名またはディレクトリ名をtempfileにコピー
					ps=filenames[f];
					pd=tempfile;
					while(*ps) *pd++=*ps++;
					*pd=0;
				}
				return f;
			case VK_ESCAPE:
				//ESCキー
				return -3;
		}
	}
}
int getfilelist(int *p_num_dir){
// カレントディレクトリでのディレクトリ、.BAS、.TXT、.INIファイル一覧を読み込む
// *p_num_dir:ディレクトリ数を返す
// filenames[]:ファイル名およびディレクトリ名一覧
// 戻り値　ファイル＋ディレクトリ数

	unsigned char *ps,*pd;
	int filenum;
	SearchRec sr;
	filenum=0;
	//ディレクトリのサーチ
	if(FindFirst("*.*",ATTR_DIRECTORY,&sr)==0){
		do{
			//filenames[]にディレクトリ名の一覧を読み込み
			ps=sr.filename;
			pd=filenames[filenum];
			while(*ps!=0) *pd++=*ps++;
			*pd=0;
			filenum++;
		}
		while(!FindNext(&sr) && filenum<MAXFILENUM);
	}
	*p_num_dir=filenum;
	if(filenum>=MAXFILENUM) return filenum;
	//拡張子 BASファイルのサーチ
	if(FindFirst("*.BAS",ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_ARCHIVE,&sr)==0){
		do{
			//filenames[]にファイル名の一覧を読み込み
			ps=sr.filename;
			pd=filenames[filenum];
			while(*ps!=0) *pd++=*ps++;
			*pd=0;
			filenum++;
		}
		while(!FindNext(&sr) && filenum<MAXFILENUM);
	}
	if(filenum>=MAXFILENUM) return filenum;
	//拡張子 TXTファイルのサーチ
	if(FindFirst("*.TXT",ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_ARCHIVE,&sr)==0){
		do{
			//filenames[]にファイル名の一覧を読み込み
			ps=sr.filename;
			pd=filenames[filenum];
			while(*ps!=0) *pd++=*ps++;
			*pd=0;
			filenum++;
		}
		while(!FindNext(&sr) && filenum<MAXFILENUM);
	}
	if(filenum>=MAXFILENUM) return filenum;
	//拡張子 INIファイルのサーチ
	if(FindFirst("*.INI",ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_ARCHIVE,&sr)==0){
		do{
			//filenames[]にファイル名の一覧を読み込み
			ps=sr.filename;
			pd=filenames[filenum];
			while(*ps!=0) *pd++=*ps++;
			*pd=0;
			filenum++;
		}
		while(!FindNext(&sr) && filenum<MAXFILENUM);
	}
	return filenum;
}
void save_as(int ow){
// 現在のテキストバッファの内容をSDカードに保存
// ow　0:名前を付けて保存　　1:上書き保存
// ファイル名はグローバル変数currentfile[]
// ファイル名はキーボードから変更可能
// 成功した場合currentfileを更新

	int er;
	int filenum,num_dir,f;
	unsigned char *ps,*pd;

	cls();
	setcursor(0,0,COLOR_NORMALTEXT);
	printstr("Save To SD Card\n");
	if(currentfile[0]==0) ow=0; //ファイル名が設定されていない場合名前を付けて保存

	//currentfileからtempfileにコピー
	ps=currentfile;
	pd=tempfile;
	while(*ps!=0) *pd++=*ps++;
	*pd=0;

	//カレントディレクトリを変数cwdpathにコピー
	while(1){
		if(FSgetcwd(cwdpath,PATHNAMEMAX)) break;
		setcursorcolor(COLOR_ERRORTEXT);
		printstr("Cannot Get Current Dir\n");
		if(filesystemretry()) return; //ファイルシステム再初期化、あきらめた場合はreturnする
	}
	//現在のディレクトリのパスを表示
	setcursorcolor(COLOR_NORMALTEXT);
	printstr("Current Directory is\n");
	printstr(cwdpath);
	printchar('\n');
	while(1){
		if(ow==0){
			printstr("Input File Name + [Enter]\n");
			printstr("[ESC] Select File/Dir or Quit\n");
			//ファイル名入力
			if(lineinput(tempfile,8+1+3)<0){
				//ESCキーが押された場合、ファイル選択、ディレクトリ変更画面または終了
				while(1){
					filenum=getfilelist(&num_dir); //ディレクトリ、ファイル名一覧を読み込み
					f=select_dir_file(filenum,num_dir,"Save"); //ファイルの選択
					cls();
					if(f==-3){
						//終了
						FSchdir(cwdpath);//カレントディレクトリを元に戻す
						return;
					}
					else if(f==-2){
						//新規ファイル
						if(overwritecheck(tempfile)==0) break;//上書きチェック
					}
					else if(f<num_dir){
						//新規ディレクトリまたはディレクトリ変更
						FSchdir(tempfile);//ディレクトリ変更して再度ファイル一覧へ
					}
					else break;
				}
			}
			else{
				if(*tempfile==0) continue; //NULL文字列の場合
				if(overwritecheck(tempfile)) continue;
			}
		}
		printstr("Writing...\n");
		er=savetextfile(tempfile); //ファイル保存、er:エラーコード
		if(er==0){
			printstr("OK");
			FSremove(TEMPFILENAME); //実行時に生成する一時ファイルを削除
			//tempfileからcurrentfileにコピーして終了
			ps=tempfile;
			pd=currentfile;
			while(*ps!=0) *pd++=*ps++;
			*pd=0;
			FSgetcwd(cwdpath,PATHNAMEMAX); //カレントパスを更新
			edited=0; //編集済みフラグクリア
			wait60thsec(60);//1秒待ち
			return;
		}
		setcursorcolor(COLOR_ERRORTEXT);
		if(er==ERR_CANTFILEOPEN) printstr("Bad File Name or File Error\n");
		else printstr("Cannot Write\n");
		if(filesystemretry()) return; //ファイルシステム再初期化、あきらめた場合はreturnする
	}
}

void newtext(void){
// 新規テキスト作成
	unsigned char vk;
	if(edited && num){
		//最終保存後に編集済みの場合、保存の確認
		cls();
		setcursorcolor(COLOR_NORMALTEXT);
		printstr("Save Editing File?\n");
		printstr("Save:[Enter] / Not Save:[ESC]\n");
		while(1){
			inputchar(); //1文字キー入力待ち
			vk=vkey & 0xff;
			if(vk==VK_RETURN || vk==VK_SEPARATOR){
				save_as(0); //名前を付けて保存
				break;
			}
			else if(vk==VK_ESCAPE) break;
		}
	}
	inittextbuf(); //テキストバッファ初期化
	cursor_top(); //カーソルをテキストバッファの先頭に設定
	currentfile[0]=0; //作業中ファイル名クリア
}

void msra(void){
// Make Self-Running Application （自己実行アプリケーションの作成）
// 最初にソースファイルを名前を付けて保存
// 次にBASICシステムのHEXファイルをソースファイル名の拡張子をHEXにした名前でコピー

	int er;
	unsigned char *ps,*pd;
	cls();
	setcursor(0,0,COLOR_NORMALTEXT);
	printstr("Make Self-Running Application\n\n");
	printstr("(Work on Root Directory)\n");

	//カレントディレクトリを変数cwdpathにコピー
	while(1){
		if(FSgetcwd(cwdpath,PATHNAMEMAX)) break;
		setcursorcolor(COLOR_ERRORTEXT);
		printstr("Cannot Get Current Dir\n");
		if(filesystemretry()) return; //ファイルシステム再初期化、あきらめた場合はreturnする
	}
	while(1){
		//カレントディレクトリをルートに変更
		if(FSchdir((char *)ROOTDIR)==0) break;
		setcursorcolor(COLOR_ERRORTEXT);
		printstr("Cannot Change To Root Dir\n");
		if(filesystemretry()) return; //ファイルシステム再初期化、あきらめた場合はreturnする
	}
	//currentfileからtempfileにコピー
	ps=currentfile;
	pd=tempfile;
	while(*ps!=0) *pd++=*ps++;
	*pd=0;

	while(1){
		setcursorcolor(COLOR_NORMALTEXT);
		printstr("Input File Name (xxx.BAS)\n");
		if(lineinput(tempfile,8+1+3)<0){
			//ESCキーが押された
			FSchdir(cwdpath); //カレントディレクトリを元に戻す
			return;
		}
		ps=tempfile;
		while(*ps!='.' && *ps!=0) ps++;
		if(ps+4>=tempfile+13 ||
			*ps!='.' ||
			(*(ps+1)!='b' && *(ps+1)!='B') ||
			(*(ps+2)!='a' && *(ps+2)!='A') ||
			(*(ps+3)!='s' && *(ps+3)!='S') ||
			*(ps+4)!=0){
				setcursorcolor(COLOR_ERRORTEXT);
				printstr("File Name Must Be xxx.BAS\n");
				continue;
		}
		if(overwritecheck(tempfile)) continue;
		printstr("Writing BASIC File\n");
		er=savetextfile(tempfile); //ファイル保存、er:エラーコード
		if(er==0) break;
		setcursorcolor(COLOR_ERRORTEXT);
		if(er==ERR_CANTFILEOPEN) printstr("Bad File Name or File Error\n");
		else printstr("Cannot Write\n");

		//ファイルシステム再初期化、あきらめた場合はreturnする
		if(filesystemretry()){
			if(FSchdir(cwdpath)){
				cwdpath[0]='\\';
				cwdpath[1]=0;
			}
			return;
		}
	}
	printstr("OK\n\n");
	FSremove(TEMPFILENAME); //実行時に生成する一時ファイルを削除
	//tempfileからcurrentfileにコピーして終了
	ps=tempfile;
	pd=currentfile;
	while(*ps!=0) *pd++=*ps++;
	*pd=0;
	edited=0; //編集済みフラグクリア
	// 拡張子をHEXにしてBASICシステムファイルをコピー
	*(ps-3)='H';
	*(ps-2)='E';
	*(ps-1)='X';
	if(overwritecheck(tempfile)) return;
	printstr("Copying\n");
	printstr(HEXFILE);
	printstr(" To ");
	printstr(tempfile);
	printstr("\nWait For A While");
	er=sdfilecopy(HEXFILE,tempfile);
	if(FSchdir(cwdpath)){
		cwdpath[0]='\\';
		cwdpath[1]=0;
	}
	if(er==0){
		printstr("\nDone");
		wait60thsec(120);//2秒待ち
		return;
	}
	setcursorcolor(COLOR_ERRORTEXT);
	if(er==ERR_CANTFILEOPEN){
		printstr(HEXFILE);
		printstr(" Not Found\n");
	}
	else if(er==ERR_CANTWRITEFILE){
		printstr("Write Error\n");
	}
	setcursorcolor(COLOR_NORMALTEXT);
	printstr((unsigned char *)Message1);// Hit Any Key
	inputchar(); //1文字入力待ち
	return;
}
int fileload(void){
// SDカードからファイルを選択して読み込み
// currenfile[]にファイル名を記憶
// 対象ファイル拡張子 BASおよびTXT
// 戻り値　0：読み込みを行った　-1：読み込みなし
	int filenum,f,er;
	unsigned char *ps,*pd;
	unsigned char vk;
	int num_dir;//ディレクトリ数

	//ファイルの一覧をSDカードから読み出し
	cls();
	if(edited && num){
		//最終保存後に編集済みの場合、保存の確認
		setcursorcolor(COLOR_NORMALTEXT);
		printstr("Save Program Before Load?\n");
		printstr("Save:[Enter] / Not Save:[ESC]\n");
		while(1){
			inputchar(); //1文字キー入力待ち
			vk=vkey & 0xff;
			if(vk==VK_RETURN || vk==VK_SEPARATOR){
				save_as(0); //名前を付けて保存
				break;
			}
			else if(vk==VK_ESCAPE) break;
		}
	}
	//カレントディレクトリを変数cwdpathにコピー
	while(1){
		if(FSgetcwd(cwdpath,PATHNAMEMAX)) break;
		setcursorcolor(COLOR_ERRORTEXT);
		printstr("Cannot Get Current Dir\n");
		if(filesystemretry()) return -1; //ファイルシステム再初期化、あきらめた場合はreturnする
	}
	while(1){
		filenum=getfilelist(&num_dir); //ディレクトリ、ファイル名一覧を読み込み
		if(filenum==0){
			setcursorcolor(COLOR_ERRORTEXT);
			printstr(".BAS or .TXT File Not Found\n");
			printstr((unsigned char *)Message1);// Hit Any Key
			inputchar(); //1文字入力待ち
			FSchdir(cwdpath);//カレントディレクトリを元に戻す
			return -1;
		}
		//ファイルの選択
		f=select_dir_file(filenum,num_dir,"Load");
		if(f==-3){
			//読み込まずに終了
			FSchdir(cwdpath);//カレントディレクトリを元に戻す
			return -1;
		}
		else if(f==-2){
			//新規ファイルまたはファイル名を入力して読み込み
			er=loadtextfile(tempfile); //テキストバッファにファイル読み込み
			if(er==ERR_CANTFILEOPEN){
				//ファイルが存在しない場合、新規テキスト
				edited=0;
				newtext();
			}
			else if(er==ERR_FILETOOBIG){
				//ファイルサイズエラーの場合、選択画面に戻る
				setcursor(0,WIDTH_Y-1,COLOR_ERRORTEXT);
				printstr("File Too Big                 ");
				wait60thsec(60);//1秒待ち
				continue;
			}
			//currenfile[]にファイル名をコピー
			ps=tempfile;
			pd=currentfile;
			while(*ps) *pd++=*ps++;
			*pd=0;
			FSgetcwd(cwdpath,PATHNAMEMAX);//cwdpathをカレントディレクトリのパスに変更
			return 0;
		}
		else if(f<num_dir){
			//新規ディレクトリまたはディレクトリ変更して、再度ファイル一覧画面へ
			FSchdir(tempfile);
		}
		else{
			er=loadtextfile(filenames[f]); //テキストバッファにファイル読み込み
			if(er==0){
				//cwdpath[]、currenfile[]にパス、ファイル名をコピーして終了
				FSgetcwd(cwdpath,PATHNAMEMAX);
				ps=filenames[f];
				pd=currentfile;
				while(*ps!=0) *pd++=*ps++;
				*pd=0;
				return 0;
			}
			setcursor(0,WIDTH_Y-1,COLOR_ERRORTEXT);
			if(er==ERR_CANTFILEOPEN) printstr("Cannot Open File             ");
			else if(er=ERR_FILETOOBIG) printstr("File Too Big                 ");
			wait60thsec(60);//1秒待ち
		}
	}
}
void changewidth(void){
// 30文字モードと40文字モードの切り替え
	if(twidth==WIDTH_X1) set_width(1);
	else set_width(0);
	cursor_top(); //カーソルをテキストバッファの先頭に設定
	redraw(); //再描画
}
void run(int test){
//KM-BASICコンパイル＆実行
// test 0:コンパイルと実行、0以外:コンパイルのみで終了
	int er,er2;
	FSFILE *fp;
	unsigned int disptoppos,cursorpos;
	unsigned char widthmode;
	int i,edited1;
	_tbuf *bp;
	unsigned short ix;
	unsigned char *p;

	cls();
	setcursor(0,0,COLOR_NORMALTEXT);
	while(1){
		//カレントディレクトリをルートに変更
		if(FSchdir((char *)ROOTDIR)){
			setcursorcolor(COLOR_ERRORTEXT);
			printstr("Cannot Change To Root Dir\n");
			if(filesystemretry()) return; //ファイルシステム再初期化、あきらめた場合はreturnする
			continue;
		}
		//ルートディレクトリのパス名保存ファイルに実行時パスを保存
		fp=FSfopen(WORKDIRFILE,"w");
		if(fp==NULL){
			setcursorcolor(COLOR_ERRORTEXT);
			printstr("Cannot Open Work Dir File\n");
			if(filesystemretry()){
				//ファイルシステム再初期化、あきらめた場合はカレントディレクトリを戻しreturnする
				FSchdir(cwdpath);
				return;
			}
			continue;
		}
		for(p=cwdpath;*p;p++) ;
		er=FSfwrite(cwdpath,1,p-cwdpath+1,fp);
		FSfclose(fp);
		if(er!=p-cwdpath+1){
			FSremove(WORKDIRFILE);
			setcursorcolor(COLOR_ERRORTEXT);
			printstr("Cannot Write Work Dir File\n");
			if(filesystemretry()){
				//ファイルシステム再初期化、あきらめた場合はカレントディレクトリを戻しreturnする
				FSchdir(cwdpath);
				return;
			}
			continue;
		}
		break;
	}
	while(1){
		//カレントディレクトリを元に戻す
		if(FSchdir(cwdpath)){
			setcursorcolor(COLOR_ERRORTEXT);
			printstr("Cannot Change To CWD\n");
			if(filesystemretry()) return; //ファイルシステム再初期化、あきらめた場合はreturnする
			continue;
		}
		//実行用引渡しファイルに保存
		if(savetextfile(TEMPFILENAME)){
			setcursorcolor(COLOR_ERRORTEXT);
			printstr("Cannot Write To SD Card\n");
			if(filesystemretry()) return; //ファイルシステム再初期化、あきらめた場合はreturnする
			continue;
		}
		break;
	}

	//カーソル位置、画面表示位置、画面モードの保存
	disptoppos=bpixtopos(disptopbp,disptopix);
	cursorpos=bpixtopos(cursorbp,cursorix);
	widthmode=twidth;
	edited1=edited; //編集済みフラグの一時退避
	set_width(0);//30文字モードに設定

	// Enable Break key
	g_disable_break=0;
	//KM-BASIC実行
	er2=runbasic(TEMPFILENAME,test);

	stopPCG();//システムフォントに戻す
	setcursorcolor(COLOR_NORMALTEXT);
	printchar('\n');
	printstr((unsigned char *)Message1);// Hit Any Key
	do ps2readkey(); //キーバッファが空になるまで読み出し
	while(vkey!=0);
	ps2mode(); //キーボード有効化
	inputchar(); //1文字入力待ち
	init_composite(); //パレット初期化のため画面初期化
	//画面モードを戻す
	if(widthmode==WIDTH_X1) set_width(0);
	else set_width(1);

	FSgetcwd(cwdpath,PATHNAMEMAX);//カレントディレクトリパス変数を戻す
	while(1){
		//カレントディレクトリをルートに変更
		if(FSchdir((char *)ROOTDIR)){
			setcursorcolor(COLOR_ERRORTEXT);
			printstr("Cannot Change To Root Dir\n");
			filesystemretry(); //ファイルシステム再初期化
			continue;
		}
		//ルートディレクトリのパス名保存ファイルからパス名を読み出し
		fp=FSfopen(WORKDIRFILE,"r");
		if(fp==NULL){
			setcursorcolor(COLOR_ERRORTEXT);
			printstr("Cannot Open Work Dir File\n");
			filesystemretry(); //ファイルシステム再初期化
			continue;
		}
		er=FSfread(cwdpath,1,PATHNAMEMAX,fp);
		FSfclose(fp);
		if(er<=0){
			setcursorcolor(COLOR_ERRORTEXT);
			printstr("Cannot Read Work Dir File\n");
			filesystemretry(); //ファイルシステム再初期化
			continue;
		}
		FSremove(WORKDIRFILE); //パス名保存ファイル削除
		break;
	}
	while(1){
		//カレントディレクトリを元に戻す
		if(FSchdir(cwdpath)){
			setcursorcolor(COLOR_ERRORTEXT);
			printstr("Cannot Change To CWD\n");
			filesystemretry(); //ファイルシステム再初期化
			continue;
		}
		//実行用引渡しファイルから元に戻す
		if(loadtextfile(TEMPFILENAME)){
			setcursorcolor(COLOR_ERRORTEXT);
			printstr("Cannot Load From SD Card\n");
			filesystemretry(); //ファイルシステム再初期化
			continue;
		}
		break;
	}
	if(er2<=0){
		//正常終了またはファイルエラーまたはリンクエラーの場合
		//カーソルを元の位置に設定
		disptopbp=postobpix(disptoppos,&disptopix);
		cursorbp=postobpix(cursorpos,&cursorix);
	}
	else{
		//コンパイルエラーの場合
		//カーソルをエラー行で画面トップに移動
		disptopbp=linetobpix(er2,&disptopix);
		cursorbp=disptopbp;
		cursorix=disptopix;
		cx=0;
		cx2=0;
		cy=0;
		line_no=er2;
		//中央になるようスクロール
		for(i=0;i<EDITWIDTHY/2;i++){
			//画面行数半分カーソルを上に移動
			bp=disptopbp;
			ix=disptopix;
			cursor_up();
			if(bp==disptopbp && ix==disptopix) break; //最上行で移動できなかった場合抜ける
		}
		for(;i>0;i--) cursor_down(); //元のY座標までカーソルを下に移動
	}
	cursorbp1=NULL; //範囲選択モード解除
	clipsize=0; //クリップボードクリア
	edited=edited1;
	FSremove(TEMPFILENAME);
}
void displaybottomline(void){
//エディター画面最下行の表示
	unsigned char *p;
	unsigned char c;
	int t;
	p=cursor; //カーソル位置の退避
	c=cursorcolor;
	setcursor(0,WIDTH_Y-1,COLOR_BOTTOMLINE);
	if(shiftkeys() & CHK_SHIFT){
		printstr("NEW |MSRA|WDTH|TEST|");
		setcursorcolor(COLOR_ERRORTEXT);
		t=TBUFMAXSIZE-num;
		if(t==0) t=1;
		while(t<10000){
			printchar(' ');
			t*=10;
		}
		printstr("LEFT:");
		printnum(TBUFMAXSIZE-num);
	}
	else{
		printstr("LOAD|SAVE|    |RUN |");
		setcursorcolor(COLOR_ERRORTEXT);
		t=line_no;
		if(t==0) t=1;
		while(t<10000){
			printchar(' ');
			t*=10;
		}
		printstr("LINE:");
		printnum(line_no);
	}
	cursor=p; //カーソル位置戻し
	cursorcolor=c;
}
void normal_code_process(unsigned char k){
// 通常文字入力処理
// k:入力された文字コード
	int i;

	edited=1; //編集済みフラグ
	if(insertmode || k=='\n' || cursorbp1!=NULL){ //挿入モード
		if(cursorbp1!=NULL) deletearea();//選択範囲を削除
		i=insertchar(cursorbp,cursorix,k,0);//テキストバッファに１文字挿入
		if(i>0){
			//バッファ空きがあるのに挿入失敗の場合
			gabagecollect2(); //全体ガベージコレクション
			i=insertchar(cursorbp,cursorix,k,0);//テキストバッファに１文字挿入
		}
		if(i==0) cursor_right();//画面上、バッファ上のカーソル位置を1つ後ろに移動
	}
	else{ //上書きモード
		i=overwritechar(cursorbp,cursorix,k,0);//テキストバッファに１文字上書き
		if(i>0){
			//バッファ空きがあるのに上書き（挿入）失敗の場合
			//（行末やバッファ最後尾では挿入）
			gabagecollect2(); //全体ガベージコレクション
			i=overwritechar(cursorbp,cursorix,k,0);//テキストバッファに１文字上書き
		}
		if(i==0) cursor_right();//画面上、バッファ上のカーソル位置を1つ後ろに移動
	}
}
void control_code_process(unsigned char k,unsigned char sh){
// 制御文字入力処理
// k:制御文字の仮想キーコード
// sh:シフト関連キー状態

	save_cursor(); //カーソル関連変数退避（カーソル移動できなかった場合戻すため）
	switch(k){
		case VK_LEFT:
		case VK_NUMPAD4:
			 //シフトキー押下していなければ範囲選択モード解除（NumLock＋シフト＋テンキーでも解除）
			if((sh & CHK_SHIFT)==0 || (k==VK_NUMPAD4) && (sh & CHK_NUMLK)) cursorbp1=NULL;
			else if(cursorbp1==NULL) set_areamode(); //範囲選択モードでなければ範囲選択モード開始
			if(sh & CHK_CTRL){
				//CTRL＋左矢印でHome
				cursor_home();
				break;
			}
			cursor_left();
			if(cursorbp1!=NULL && (disptopbp!=disptopbp_t || disptopix!=disptopix_t)){
				//範囲選択モードで画面スクロールがあった場合
				if(cy1<EDITWIDTHY-1) cy1++; //範囲スタート位置もスクロール
				else restore_cursor(); //カーソル位置を戻す（画面範囲外の範囲選択禁止）
			}
			break;
		case VK_RIGHT:
		case VK_NUMPAD6:
			 //シフトキー押下していなければ範囲選択モード解除（NumLock＋シフト＋テンキーでも解除）
			if((sh & CHK_SHIFT)==0 || (k==VK_NUMPAD6) && (sh & CHK_NUMLK)) cursorbp1=NULL;
			else if(cursorbp1==NULL) set_areamode(); //範囲選択モードでなければ範囲選択モード開始
			if(sh & CHK_CTRL){
				//CTRL＋右矢印でEnd
				cursor_end();
				break;
			}
			cursor_right();
			if(cursorbp1!=NULL && (disptopbp!=disptopbp_t || disptopix!=disptopix_t)){
				//範囲選択モードで画面スクロールがあった場合
				if(cy1>0) cy1--; //範囲スタート位置もスクロール
				else restore_cursor(); //カーソル位置を戻す（画面範囲外の範囲選択禁止）
			}
			break;
		case VK_UP:
		case VK_NUMPAD8:
			 //シフトキー押下していなければ範囲選択モード解除（NumLock＋シフト＋テンキーでも解除）
			if((sh & CHK_SHIFT)==0 || (k==VK_NUMPAD8) && (sh & CHK_NUMLK)) cursorbp1=NULL;
			else if(cursorbp1==NULL) set_areamode(); //範囲選択モードでなければ範囲選択モード開始
			cursor_up();
			if(cursorbp1!=NULL && (disptopbp!=disptopbp_t || disptopix!=disptopix_t)){
				//範囲選択モードで画面スクロールがあった場合
				if(cy1<EDITWIDTHY-1) cy1++; //範囲スタート位置もスクロール
				else restore_cursor(); //カーソル位置を戻す（画面範囲外の範囲選択禁止）
			}
			break;
		case VK_DOWN:
		case VK_NUMPAD2:
			 //シフトキー押下していなければ範囲選択モード解除（NumLock＋シフト＋テンキーでも解除）
			if((sh & CHK_SHIFT)==0 || (k==VK_NUMPAD2) && (sh & CHK_NUMLK)) cursorbp1=NULL;
			else if(cursorbp1==NULL) set_areamode(); //範囲選択モードでなければ範囲選択モード開始
			cursor_down();
			if(cursorbp1!=NULL && (disptopbp!=disptopbp_t || disptopix!=disptopix_t)){
				//範囲選択モードで画面スクロールがあった場合
				if(cy1>0) cy1--; //範囲スタート位置もスクロール
				else restore_cursor(); //カーソル位置を戻す（画面範囲外の範囲選択禁止）
			}
			break;
		case VK_HOME:
		case VK_NUMPAD7:
			 //シフトキー押下していなければ範囲選択モード解除（NumLock＋シフト＋テンキーでも解除）
			if((sh & CHK_SHIFT)==0 || (k==VK_NUMPAD7) && (sh & CHK_NUMLK)) cursorbp1=NULL;
			else if(cursorbp1==NULL) set_areamode(); //範囲選択モードでなければ範囲選択モード開始
			cursor_home();
			break;
		case VK_END:
		case VK_NUMPAD1:
			 //シフトキー押下していなければ範囲選択モード解除（NumLock＋シフト＋テンキーでも解除）
			if((sh & CHK_SHIFT)==0 || (k==VK_NUMPAD1) && (sh & CHK_NUMLK)) cursorbp1=NULL;
			else if(cursorbp1==NULL) set_areamode(); //範囲選択モードでなければ範囲選択モード開始
			cursor_end();
			break;
		case VK_PRIOR: // PageUpキー
		case VK_NUMPAD9:
			 //シフト＋PageUpは無効（NumLock＋シフト＋「9」除く）
			if((sh & CHK_SHIFT) && ((k!=VK_NUMPAD9) || ((sh & CHK_NUMLK)==0))) break;
			cursorbp1=NULL; //範囲選択モード解除
			cursor_pageup();
			break;
		case VK_NEXT: // PageDownキー
		case VK_NUMPAD3:
			 //シフト＋PageDownは無効（NumLock＋シフト＋「3」除く）
			if((sh & CHK_SHIFT) && ((k!=VK_NUMPAD3) || ((sh & CHK_NUMLK)==0))) break;
			cursorbp1=NULL; //範囲選択モード解除
			cursor_pagedown();
			break;
		case VK_DELETE: //Deleteキー
		case VK_DECIMAL: //テンキーの「.」
			edited=1; //編集済みフラグ
			if(cursorbp1!=NULL) deletearea();//選択範囲を削除
			else deletechar(cursorbp,cursorix,0);
			break;
		case VK_BACK: //BackSpaceキー
			edited=1; //編集済みフラグ
			if(cursorbp1!=NULL){
				deletearea();//選択範囲を削除
				break;
			}
			if(cursorix==0 && cursorbp->prev==NULL) break; //バッファ先頭では無視
			cursor_left();
			deletechar(cursorbp,cursorix,-1);
			break;
		case VK_INSERT:
		case VK_NUMPAD0:
			insertmode^=1; //挿入モード、上書きモードを切り替え
			break;
		case 'C':
			//CTRL+C、クリップボードにコピー
			if(cursorbp1!=NULL && (sh & CHK_CTRL)) clipcopy();
			break;
		case 'X':
			//CTRL+X、クリップボードに切り取り
			if(cursorbp1!=NULL && (sh & CHK_CTRL)){
				clipcopy();
				deletearea(); //選択範囲の削除
				edited=1; //編集済みフラグ
			}
			break;
		case 'V':
			//CTRL+V、クリップボードから貼り付け
			if((sh & CHK_CTRL)==0) break;
			if(clipsize==0) break;
			edited=1; //編集済みフラグ
			if(cursorbp1!=NULL){
				//範囲選択している時は削除してから貼り付け
				if(num-countarea()+clipsize<=TBUFMAXSIZE){ //バッファ空き容量チェック
					deletearea();//選択範囲を削除
					clippaste();//クリップボード貼り付け
				}
			}
			else{
				if(num+clipsize<=TBUFMAXSIZE){ //バッファ空き容量チェック
					clippaste();//クリップボード貼り付け
				}
			}
			break;
		case 'S':
			//CTRL+S、SDカードに保存
			if(num==0) break;
			if(sh & CHK_CTRL) save_as(1); //上書き保存
			break;
		case 'O':
			//CTRL+O、ファイル読み込み
			if(sh & CHK_CTRL){
				if(fileload()==0){ //ファイルを選択して読み込み
					//読み込みを行った場合、カーソル位置を先頭に
					cursor_top();
				}
			}
			break;
		case 'N':
			//CTRL+N、新規作成
			if(sh & CHK_CTRL) newtext();
			break;
		case VK_F1: //F1キー
			if(sh & CHK_SHIFT) newtext();//SHIFT+F1キー　新規作成
			else{
				//ファイル読み込み
				if(fileload()==0){ //ファイルを選択して読み込み
					//読み込みを行った場合、カーソル位置を先頭に
					cursor_top();
				}
			}
			break;
		case VK_F2: //F2キー
			if(num==0) break;
			if(sh & CHK_SHIFT) msra(); //create direct running file
			else save_as(0); //ファイル名を付けて保存
			break;
		case VK_F3: //F3キー
			if(sh & CHK_SHIFT) changewidth(); //30文字モード、40文字モード切り替え
			break;
		case VK_F4: //F4キー
			if(num==0) break;
			if(sh & CHK_SHIFT) run(1); //コンパイルテスト
			else run(0); //コンパイル＆実行
			break;
		case 'Z':
			//CTRL+Z、アンドゥ
			if(sh & CHK_CTRL) undoexec();
			break;
	}
}
void texteditor(void){
//テキストエディター本体
	unsigned char k1,k2,sh;
	FSFILE *fp;

	editormallocp=RAM;
	TextBuffer=(_tbuf *)editormalloc(sizeof(_tbuf)*TBUFMAXLINE);
	clipboard=editormalloc(WIDTH_X2*EDITWIDTHY);
	filebuf=editormalloc(FILEBUFSIZE);
	cwdpath=editormalloc(PATHNAMEMAX);
	filenames=(unsigned char (*)[])editormalloc(MAXFILENUM*13);
	undobuf=editormalloc(UNDOBUFSIZE);

//	TextBuffer=(_tbuf *)RAM;
//	clipboard=(unsigned char *)TextBuffer+sizeof(_tbuf)*TBUFMAXLINE;
//	filebuf=clipboard+WIDTH_X2*EDITWIDTHY;
//	cwdpath=filebuf+FILEBUFSIZE;
//	filenames=(unsigned char (*)[])(cwdpath+PATHNAMEMAX);
//	undobuf=(unsigned char *)filenames+MAXFILENUM*13;

	inittextbuf(); //テキストバッファ初期化
	currentfile[0]=0; //作業中ファイル名クリア
	cwdpath[0]='\\'; //カレントディレクトリをルートに設定
	cwdpath[1]=0;

	//実行時生成一時ファイルがあった場合は読み込む
	fp=FSfopen(WORKDIRFILE,"r");
	if(fp!=NULL){
		FSfread(cwdpath,1,PATHNAMEMAX,fp);
		FSfclose(fp);
		FSchdir(cwdpath);
		if(loadtextfile(TEMPFILENAME)==0){
			edited=1;
			setcursorcolor(COLOR_ERRORTEXT);
			printstr("Temporary File Loaded\n");
			printstr("Current Directory is\n");
			setcursorcolor(COLOR_DIR);
			printstr(cwdpath);
			setcursorcolor(COLOR_ERRORTEXT);
			printstr("\nSave To SD Card If Necessary\n");
			setcursorcolor(COLOR_NORMALTEXT);
			printstr((unsigned char *)Message1); //Hit Any Key
			inputchar(); //1文字入力待ち
		}
		else{
			cwdpath[0]='\\'; //カレントディレクトリをルートに設定
			cwdpath[1]=0;
		}
	}
	cursor_top(); //カーソルをテキストバッファの先頭に移動
	insertmode=1; //0:上書き、1:挿入
	clipsize=0; //クリップボードクリア
	blinktimer=0; //カーソル点滅タイマークリア

	while(1){
		redraw();//画面再描画
		setcursor(cx,cy,COLOR_NORMALTEXT);
		getcursorchar(); //カーソル位置の文字を退避（カーソル点滅用）
		while(1){
			//キー入力待ちループ
			wait60thsec(1);  //60分の1秒ウェイト
			blinkcursorchar(); //カーソル点滅させる
			k1=ps2readkey(); //キーバッファから読み込み、k1:通常文字入力の場合ASCIIコード
			displaybottomline(); //画面最下行にファンクションキー機能表示
			if(vkey) break;  //キーが押された場合ループから抜ける
			if(cursorbp1==NULL) gabagecollect1(); //1バイトガベージコレクション（範囲選択時はしない）
		}
		resetcursorchar(); //カーソルを元の文字表示に戻す
		k2=(unsigned char)vkey; //k2:仮想キーコード
		sh=vkey>>8;             //sh:シフト関連キー状態
		if(k2==VK_RETURN || k2==VK_SEPARATOR) k1='\n'; //Enter押下は単純に改行文字を入力とする
		if(k1) normal_code_process(k1); //通常文字が入力された場合
		else control_code_process(k2,sh); //制御文字が入力された場合
		if(cursorbp1!=NULL && cx==cx1 && cy==cy1) cursorbp1=NULL;//選択範囲の開始と終了が重なったら範囲選択モード解除
 	}
}
/*
   This file is provided under the LGPL license ver 2.1.
   Written by Katsumi.
   http://hp.vector.co.jp/authors/VA016157/
   kmorimatsu@users.sourceforge.jp
*/

#include "compiler.h"

const char* g_err_str[]={
	"Syntax error",
	"Not enough binary space",
	"Not enough memory",
	"Divided by zero",
	"Not yet implemented",
	"Label or line number not found: ",
	"Label too long or too short",
	"String too complexed",
	"Data not found",
	"Unknown error:",
	"Music syntax error:'",
	" found more than twice",
	"Break",
	"Unexpected NEXT or RETURN statement",
	"Cannot assign temporary block",
	"GOSUB fuction cannot be used after string-handling",
	"Invalid BREAK statement in line ",
	"Invalid ELSE/IF statement in line ",
	"Invalid parameter(s)",
	"File error",
	"Invalid variable name",
};

char* resolve_label(int s6){
	static char str[7];
	int i,j;
	if (s6<65536) {
		// Line number
		for(i=0;i<5;i++){
			str[5-i]='0'+rem10_32(s6);
			s6=div10_32(s6);
		}
		str[6]=0x00;
		for(j=1;j<5;j++){
			if (str[j]!='0') break;
		}
		return (char*)(str+j);
	} else {
		// Label
		s6-=65536;
		str[6]=0x00;
		for(i=5;0<=i;i--){
			if (s6<36) {
				// First character must be A-Z, corresponding to 1-26 but not 10-35.
				// See get_label() for the detail.
				str[i]=s6-1+'A';
				break;
			} else {
				// From second, 0-9 corresponds to 0-9 and A-Z corresponds to 10-35.
				str[i]="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[rem36_32(s6)];
				s6=div36_32(s6);
			}
		}
		return (char*)(str+i);
	}
}

void pre_end_addr(int s6){
	int i,j;
	char str[7];
	if (s6<0) s6=s6&0x7fffffff;
	g_label=s6;
	if (s6<65536) {
		// Line number
		printstr("\nIn line ");
	} else {
		// Label
		printstr("\nAfter label ");
	}
	printstr(resolve_label(s6));
	asm volatile("la $v0,%0"::"i"(&g_end_addr));
	asm volatile("lw $v0,0($v0)");
	asm volatile("nop");
	asm volatile("jr $v0");
}

#define end_exec() \
	asm volatile("addu $a0,$s6,$zero");\
	asm volatile("j pre_end_addr")

void err_break(void){
	printstr(ERR_BREAK);
	end_exec();
}

void err_data_not_found(void){
	printstr(ERR_DATA_NF);
	end_exec();
}

void err_label_not_found(void){
	printstr(ERR_LABEL_NF);
	printstr(resolve_label(g_label));
	printstr("\n");
	end_exec();
}

void err_div_zero(void){
	printstr(ERR_DIV_0);
	end_exec();
}

void err_no_mem(void){
	printstr(ERR_NE_MEMORY);
	end_exec();
}

void err_str_complex(void){
	printstr(ERR_STR_COMPLEX);
	end_exec();
}

void err_unknown(void){
	asm volatile("la $v0,%0"::"i"(&g_temp));
	asm volatile("sw $ra,0($v0)");
	printstr(ERR_UNKNOWN);
	printhex32(g_temp);
	end_exec();
}

void err_music(char* str){
	printstr(ERR_MUSIC);
	printstr(str);
	printstr("'\n");
	// Restore s6 from g_s6
	asm volatile("la $s6,%0"::"i"(&g_s6));
	asm volatile("lw $s6,0($s6)");
	end_exec();
}

void err_unexp_next(void){
	printstr(ERR_UNEXP_NEXT);
	end_exec();	
}

void err_no_block(void){
	printstr(ERR_NO_BLOCK);
	end_exec();	
}

void err_invalid_param(void){
	printstr(ERR_INVALID_PARAM);
	end_exec();	
}

void err_file(void){
	printstr(ERR_FILE);
	end_exec();	
}

/*
   This file is provided under the LGPL license ver 2.1.
   Written by K.Tanaka & Katsumi
   http://www.ze.em-net.ne.jp/~kenken/index.html
   http://hp.vector.co.jp/authors/VA016157/
*/

#include <xc.h>
#include "api.h"
#include "main.h"
#include "compiler.h"

/*
	Enable following line if memory dump is needed when exception occurs.
*/

//#define DUMPFILE "~~MEMORY.DMP"

#ifdef DUMPFILE
void dumpMemory(){
	unsigned int i;
	FSFILE *fp;
	printstr("\n"DUMPFILE" ");
	if(FSInit()==FALSE){
		printstr("cannot be created.\n");
		return;
	}
	fp=FSfopen(DUMPFILE,"w");
	if(fp==NULL) {
		printstr("not saved.\n");
		return;
	}
	for(i=0;i<PERSISTENT_RAM_SIZE;i+=512){
		if (FSfwrite(&RAM[i],1,512,fp)<512) break;
	}
	FSfclose(fp);	
	printstr("saved.\n");
}
#else
void dumpMemory(){}
#endif //ifdef DUMPFILE

void _general_exception_handler (void){
	int i;
	// $v1 is g_ex_data
	asm volatile("la $v1,%0"::"i"(&g_ex_data[0]));
	// Prepare proper stack area before SoftReset
	asm volatile("addiu $sp,$v1,0xfff0");
	// g_ex_data[2]=$s6
	asm volatile("sw $s6,8($v1)");
	// g_ex_data[3]=Cause
	asm volatile("mfc0 $v0,$13");
	asm volatile("sw $v0,12($v1)");
	// g_ex_data[4]=EPC 
	asm volatile("mfc0 $v0,$14");
	asm volatile("sw $v0,16($v1)");
	// Exception occured
	g_ex_data[0]=1;
	// g_s6
	g_ex_data[1]=g_s6;
	// Clear 2 MLB bits of EPC
	g_ex_data[4]&=0xfffffffc;
	// If EPC is within RAM, store data in exception area.
	if ((int)(&RAM[0])<=g_ex_data[4] && g_ex_data[4] <(int)(&RAM[RAMSIZE])) {
		// g_ex_data[5] - g_ex_data[12]: assembly
		for(i=-3;i<=3;i++){
			g_ex_data[i+8]=((int*)g_ex_data[4])[i];
		}
	}
	// Wait until all buttons are released and reset MachiKania.
	#ifdef __DEBUG
		asm volatile("j 0xBFC00000");
	#else
		buttonmode();
		for(i=0;i<100000;i++){
			if((KEYPORT&(KEYUP|KEYDOWN|KEYLEFT|KEYRIGHT|KEYSTART|KEYFIRE))
				!=(KEYUP|KEYDOWN|KEYLEFT|KEYRIGHT|KEYSTART|KEYFIRE)) i=0;
		}
		asm volatile("j SoftReset");
	#endif
}

void blue_screen(void){
	int i,j,s6,s6g;
	unsigned int* opos;
	if (RCONbits.POR || RCONbits.EXTR) {
		// After power on or reset. Reset flags and return.
		RCONbits.POR=0;
		RCONbits.EXTR=0;
		for(i=0;i<RAMSIZE;i++){
			// Reset all RAM area including g_ex_data[]
			RAM[i]=0;
		}
		return;
	} else if (g_ex_data[0]==0) {
		// No exception found.
		return;
	}
	// Exception occured before SoftReset().
	// Prepare data
	s6=g_ex_data[2];
	s6g=g_ex_data[1];
	s6=s6&0x7fffffff;
	s6g=s6g&0x7fffffff;
	opos=(int*)g_ex_data[4];
	//set_bgcolor(255,0,0);
	printstr("STOP");
	printstr("\nException at ");
	printhex32(g_ex_data[4]);
	printstr("\n      Cause: ");
	printhex32(g_ex_data[3]);
	printstr("\n ");
	switch((g_ex_data[3]>>2)&0x1f){
		case 0:  printstr("(Interrupt)"); break;
		case 1:  printstr("(TLB modification)"); break;
		case 2:  printstr("(TLB load/fetch)"); break;
		case 3:  printstr("(TLB store)"); break;
		case 4:  printstr("(Address load/fetch error )"); break;
		case 5:  printstr("(Address store error)"); break;
		case 6:  printstr("(Bus fetch error)"); break;
		case 7:  printstr("(Bus load/store error)"); break;
		case 8:  printstr("(Syscall)"); break;
		case 9:  printstr("(Breakpoint)"); break;
		case 10: printstr("(Reserved instruction)"); break;
		case 11: printstr("(Coprocessor Unusable)"); break;
		case 12: printstr("(Integer Overflow)"); break;
		case 13: printstr("(Trap)"); break;
		case 23: printstr("(Reference to Watch address)"); break;
		case 24: printstr("(Machine check)"); break;
		default: printstr("(Unknown)"); break;
	}
	printstr("\n         s6: ");
	printstr(resolve_label(s6));
	printstr("\n       g_s6: ");
	printstr(resolve_label(s6g));
	printstr("\n");
	printstr("Reset MachiKania to contine.\n\n");
	// Show code where the exception happened.
	for(i=-3;i<=3;i++){
		printstr("\n ");
		printhex32((unsigned int)&opos[i]);
		printstr("  ");
		if ((unsigned int)&RAM[0]<=(unsigned int)&opos[i] && (unsigned int)&opos[i]<(unsigned int)&RAM[RAMSIZE]) {
			// Exception in RAM[RAMSIZE] area
			printhex32(g_ex_data[i+8]);		
		} else if (   0xA0000000<=(unsigned int)&opos[i] && (unsigned int)&opos[i]<0xA0000000+PIC32MX_RAMSIZE
			|| 0x9D000000<=(unsigned int)&opos[i] && (unsigned int)&opos[i]<=0x9D000000+PIC32MX_FLASHSIZE) {
			// Exception in outside RAM[RAMSIZE] or flash area
			printhex32(opos[i]);
		} else {
			printstr("********");
		}
	}
	printstr("\n");

#ifndef __DEBUG
	dumpMemory();
#endif
	while(1) asm("wait");
}
/*
   This file is provided under the LGPL license ver 2.1.
   Written by K.Tanaka & Katsumi
   http://www.ze.em-net.ne.jp/~kenken/index.html
   http://hp.vector.co.jp/authors/VA016157/
*/

#include <xc.h>
#include "api.h"
#include "compiler.h"

static FSFILE* g_fhandle;
static char* g_fbuff;
static int g_size;

char* init_file(char* buff,char* appname){
	// Open file
	g_fhandle=FSfopen(appname,"r");
	if (!g_fhandle) {
		return ERR_UNKNOWN;
	}
	g_fbuff=buff;
	g_line=0;
	g_fileline=0;
	return 0;
}

void close_file(){
	FSfclose(g_fhandle);
}

void read_file(int blocklen){
	int i;
	static char in_string, escape;
	// blocklen is either 512 or 256.
	if (blocklen==512) {
		// This is first read. Initialize parameter(s).
		in_string=0;
		escape=0;
	} else if (g_size<512) {
		// Already reached the end of file.
		return;
	} else {
		// Shift buffer and source position 256 bytes.
		for(i=0;i<256;i++) g_fbuff[i]=g_fbuff[i+256];
		g_srcpos-=256;
	}
	// Read 512 or 256 bytes from SD card.
	g_size=512-blocklen+FSfread((void*)&g_fbuff[512-blocklen],1,blocklen,g_fhandle);
	// Some modifications of text for easy compiling.
	for(i=512-blocklen;i<512;i++){
		if (in_string) {
			if (g_fbuff[i]=='\\' && !escape) {
				escape=1;
			} else {
				escape=0;
				if (g_fbuff[i]=='"') in_string=0;
			}
		} else {
			// If not in string, all upper cases.
			if (g_fbuff[i]=='"') in_string=1;
			else if ('a'<=g_fbuff[i] && g_fbuff[i]<='z') g_fbuff[i]+='A'-'a';
			// If not in string, tabs will be spaces.
			else if ('\t'==g_fbuff[i]) g_fbuff[i]=' ';
		}
		if (g_fbuff[i]==0x0a || g_fbuff[i]==0x0d) in_string=escape=0;
	}
	return;
}

char* compile_file(){
	int i;
	char* err;
	// Read first 512 bytes
	read_file(512);
	// Compile line by line
	while (g_size==512) {
		err=compile_line();
		if (err) return err;
		// Maintain at least 256 characters in cache.
		if (256<=g_srcpos) read_file(256);
	}
	// Return code at the end
	g_source[g_size]=0x0d;
	// Compile last few lines.
	while(g_srcpos<g_size-1){
		err=compile_line();
		if (err) return err;
	}
	// Add "DATA 0" and "END" statements.
	g_source="DATA 0:END\n";
	g_srcpos=0;
	err=compile_line();
	if (err) return err;
	g_srcpos=-1;
	// No error occured
	return 0;
}

#include "./compiler.h"
#include "stdlib.h"

char* get_float_sub(int pr);

char* get_simple_float(void){
	int i;
	float f;
	char* err;
	char b1,b2,b3;
	next_position();
	b1=g_source[g_srcpos];
	if (b1=='(') {
		// (...)
		// Parenthesis
		g_srcpos++;
		next_position();
		err=get_float_sub(priority(OP_VOID));
		if (err) return err;
		next_position();
		if (g_source[g_srcpos]!=')') return ERR_SYNTAX;
		g_srcpos++;
	} else if (b1=='-') {
		// Unary '-' operator
		// Note that unary operators ( + and - ) have higher priority than the other operators
		g_srcpos++;
		err=get_simple_float();
		if (err) return err;
		check_obj_space(1);
		g_object[g_objpos++]=0x34040000;                     // ori a0,zero,0
		call_lib_code(LIB_FLOAT | OP_SUB);
	} else {
		// Main routine of getting float value here
		if (b1=='+') g_srcpos++; // Ignore unary '+' operator
		next_position();
		b1=g_source[g_srcpos];
		b2=g_source[g_srcpos+1];
		b3=g_source[g_srcpos+2];
		if ('0'<=b1 && b1<='9') {
			f=strtof((const char*)&g_source[g_srcpos],&err);
			if (&g_source[g_srcpos]==err) return ERR_SYNTAX;
			g_srcpos=err-g_source;
			i=((int*)(&f))[0];
			if (i&0xFFFF0000) {
				// 32 bit
				check_obj_space(2);
				g_object[g_objpos++]=0x3C020000|((i>>16)&0x0000FFFF); // lui   v0,xxxx
				g_object[g_objpos++]=0x34420000|(i&0x0000FFFF);       // ori v0,v0,xxxx
			} else {
				// 16 bit
				check_obj_space(1);
				g_object[g_objpos++]=0x34020000|(i&0x0000FFFF); // ori v0,zero,xxxx
			}
		} else {
			i=get_var_number();
			if (i<0) {
				// Must be a function.
				return float_function();
			}
			if (g_source[g_srcpos]!='#') return ERR_SYNTAX;
			g_srcpos++;
			if (g_source[g_srcpos]=='(') {
				// Dimension
				g_srcpos++;
				return get_dim_value(i);
			}
			// Simple value
			check_obj_space(1);
			g_object[g_objpos++]=0x8FC20000|(i*4); // lw v0,xx(s8)
		}
	}
	// No error 
	return 0;
}

char* get_float_sub(int pr){
	char* err;
	enum operator op;
	char b1,b2,b3;
	int prevpos;
	// Get a value in $v0.
	err=get_simple_float();
	if (err) return err;
	while(1){
		// Get the operator in op. If not valid operator, simply return without error.
		prevpos=g_srcpos;
		err=get_floatOperator();
		if (err) return 0;
		op=g_last_op;
		// Compair current and previous operators.
		// If the previous operator has higher priolity, return.
		if (pr>=priority(op)) {
			g_srcpos=prevpos;
			return 0;
		}
		// Store $v0 in stack
		g_sdepth+=4;
		if (g_maxsdepth<g_sdepth) g_maxsdepth=g_sdepth;
		check_obj_space(1);
		g_object[g_objpos++]=0xAFA20000|g_sdepth; // sw v0,xx(sp)
		// Get next value.
		err=get_float_sub(priority(op));
		if (err) return err;
		// Get value from stack to $a0.
		check_obj_space(1);
		g_object[g_objpos++]=0x8FA40000|g_sdepth; // lw a0,xx(sp)
		g_sdepth-=4;
		// Calculation. Result will be in $v0.
		err=calculation_float(op);
		if (err) return err;
	}
}

char* get_float(){
	// Note that this can be called recursively.
	// Value may contain function with a parameter of another value.
	char* err;
	int prevpos;
	if (g_sdepth==0) {
		// Initialize stack handler
		g_maxsdepth=0;
		prevpos=g_objpos;
		// Stack decrement command will be filled later
		check_obj_space(1);
		g_objpos++;
	}
	err=get_float_sub(priority(OP_VOID));
	if (err) return err;
	if (g_sdepth==0) {
		if (g_maxsdepth==0) {
			// Stack was not used.
			shift_obj(&g_object[prevpos+1],&g_object[prevpos],g_objpos-prevpos-1);
			g_objpos--;
		} else {
			// Stack was used.
			check_obj_space(1);
			g_object[prevpos]=0x27BD0000 | (0-g_maxsdepth) & 0x0000FFFF; // addiu sp,sp,-xx
			g_object[g_objpos++]=0x27BD0000 | g_maxsdepth & 0x0000FFFF;  // addiu sp,sp,xx
		}
	}
	g_lastvar=VAR_FLOAT;
	return 0;
}/*
   This file is provided under the LGPL license ver 2.1.
   Written by Katsumi.
   http://hp.vector.co.jp/authors/VA016157/
   kmorimatsu@users.sourceforge.jp
*/

#include "compiler.h"
#include "api.h"

char* music_function(){
	call_lib_code(LIB_MUSICFUNC);
	return 0;
}

char* read_function(){
	call_lib_code(LIB_READ);
	return 0;
}

char* cread_function(){
	call_lib_code(LIB_CREAD);
	return 0;
}

char* gosub_function(){
	// Check if garbage collection has been done.
	// This check is required because the used temporary area would be changed 
	// in sub routine. 
	if (g_temp_area_used) return ERR_GOSUB_ASH;
	return gosub_statement();
}
char* strncmp_function(){
	char* err;
	err=get_string();
	if (err) return err;
	check_obj_space(2);
	g_object[g_objpos++]=0x27BDFFF8; // addiu       sp,sp,-8
	g_object[g_objpos++]=0xAFA20004; // sw          v0,4(sp)
	if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
	g_srcpos++;
	err=get_string();
	if (err) return err;
	check_obj_space(1);
	g_object[g_objpos++]=0xAFA20008; // sw          v0,8(sp)
	if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
	g_srcpos++;
	err=get_value();
	if (err) return err;
	call_lib_code(LIB_STRNCMP);
	check_obj_space(1);
	g_object[g_objpos++]=0x27BD0008; // addiu       sp,sp,8
	return 0;
}
char* len_function(){
	char* err;
	err=get_string();
	if (err) return err;
	check_obj_space(5);
	g_object[g_objpos++]=0x2443FFFF; // addiu       v1,v0,-1
	                                 // loop:
	g_object[g_objpos++]=0x80640001; // lb          a0,1(v1)
	g_object[g_objpos++]=0x1480FFFE; // bne         a0,zero,loop
	g_object[g_objpos++]=0x24630001; // addiu       v1,v1,1
	g_object[g_objpos++]=0x00621023; // subu        v0,v1,v0
	return 0;
}

char* asc_function(){
	char* err;
	err=get_string();
	if (err) return err;
	check_obj_space(1);
	g_object[g_objpos++]=0x90420000; // lbu         v0,0(v0)
	return 0;
}

char* val_function(){
	char* err;
	err=get_string();
	if (err) return err;
	call_lib_code(LIB_VAL);
	return 0;	
}

char* peek_function(){
	char* err;
	err=get_value();
	if (err) return err;
	check_obj_space(1);
	g_object[g_objpos++]=0x90420000; // lbu         v0,0(v0)
	return 0;
}

char* sgn_function(){
	char* err;
	err=get_value();
	if (err) return err;
	check_obj_space(5);
	g_object[g_objpos++]=0x10400004; // beq         v0,zero,end
	g_object[g_objpos++]=0x24030001; // addiu       v1,zero,1
	g_object[g_objpos++]=0x1C400002; // bgtz        v0,end
	g_object[g_objpos++]=0x00601021; // addu        v0,v1,zero
	g_object[g_objpos++]=0x00031023; // subu        v0,zero,v1
	                                 // end:
	return 0;
}

char* abs_function(){
	char* err;
	err=get_value();
	if (err) return err;
	check_obj_space(3);
	g_object[g_objpos++]=0x00021FC3; //sra         v1,v0,0x1f
	g_object[g_objpos++]=0x00621026; //xor         v0,v1,v0
	g_object[g_objpos++]=0x00431023; //subu        v0,v0,v1
	return 0;
}

char* not_function(){
	char* err;
	err=get_value();
	if (err) return err;
	check_obj_space(1);
	g_object[g_objpos++]=0x2C420001; //sltiu       v0,v0,1
	return 0;
}

char* rnd_function(){
	call_lib_code(LIB_RND);
	return 0;
}


char* chr_function(void){
	char* err;
	err=get_value();
	if (err) return err;
	call_lib_code(LIB_CHR);
	return 0;
}
char* hex_function(void){
	char* err;
	err=get_value();
	if (err) return err;
	if (g_source[g_srcpos]==',') {
		// Second argument found.
		// Get is as $a0.
		g_srcpos++;
		check_obj_space(2);
		g_object[g_objpos++]=0x27BDFFFC; //addiu       sp,sp,-4
		g_object[g_objpos++]=0xAFA20004; //sw          v0,4(sp)
		err=get_value();
		if (err) return err;
		check_obj_space(3);
		g_object[g_objpos++]=0x00022021; //a0,zero,v0
		g_object[g_objpos++]=0x8FA20004; //lw          v0,4(sp)
		g_object[g_objpos++]=0x27BD0004; //addiu       sp,sp,4
	} else {
		// Second argument not found.
		// Set $a0 to 0.
		check_obj_space(1);
		g_object[g_objpos++]=0x24040000; //addiu       a0,zero,0
	}
	call_lib_code(LIB_HEX);
	return 0;
}

char* dec_function(void){
	char* err;
	err=get_value();
	if (err) return err;
	call_lib_code(LIB_DEC);
	return 0;
}

char* keys_function(void){
	char* err;
	next_position();
	if (g_source[g_srcpos]==')') {
		check_obj_space(1);
		g_object[g_objpos++]=0x3402003F; //ori         v0,zero,0x3f
	} else {
		err=get_value();
		if (err) return err;
	}	
	call_lib_code(LIB_KEYS);
	return 0;
}

char* tvram_function(void){
	char* err;
	int i;
	next_position();
	if (g_source[g_srcpos]==')') {
		i=(int)(&TVRAM[0]);
		i-=g_gp;
		check_obj_space(1);
		g_object[g_objpos++]=0x27820000|(i&0x0000FFFF);       // addiu       v0,gp,xxxx
	} else {
		err=get_value();
		if (err) return err;
		i=(int)(&TVRAM[0]);
		i-=g_gp;
		check_obj_space(3);
		g_object[g_objpos++]=0x27830000|(i&0x0000FFFF);       // addiu       v1,gp,xxxx
		g_object[g_objpos++]=0x00621821;                      // addu        v1,v1,v0
		g_object[g_objpos++]=0x90620000;                      // lbu         v0,0(v1)
	}	
	return 0;
}

char* drawcount_function(void){
	call_lib_code(LIB_DRAWCOUNT);
	return 0;
}

char* input_function(void){
	call_lib_code(LIB_INPUT);
	return 0;
}

char* inkey_function(void){
	char* err;
	next_position();
	if (g_source[g_srcpos]==')') {
		check_obj_space(1);
		g_object[g_objpos++]=0x34020000; //ori         v0,zero,0x00
	} else {
		err=get_value();
		if (err) return err;
	}	
	call_lib_code(LIB_INKEY);
	return 0;
}

char* args_function(void){
	char* err;
	int i;
	err=get_value();
	if (err) return err;
	i=g_object[g_objpos-1];
	if ((i>>16)==0x3402) {
		// Previous object is "ori v0,zero,xxxx".
		i&=0xffff;
		i=(i+1)<<2;
		g_object[g_objpos-1]=0x8EA20000|i; //   lw          v0,xx(s5)
	} else {
		check_obj_space(3);
		g_object[g_objpos++]=0x00021080;   //   sll         v0,v0,0x2
		g_object[g_objpos++]=0x02A21021;   //   addu        v0,s5,v0
		g_object[g_objpos++]=0x8C420004;   //   lw          v0,4(v0)
	}
	return 0;	
}

char* system_function(void){
	char* err;
	err=get_value();
	if (err) return err;
	g_object[g_objpos++]=0x00402021; //   addu        a0,v0,zero
	call_lib_code(LIB_SYSTEM);
	return 0;
}

char* sprintf_function(void){
	char* err;
	err=get_string();
	if (err) return err;
	next_position();
	if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
	g_srcpos++;
	check_obj_space(2);
	g_object[g_objpos++]=0x27BDFFFC; //addiu       sp,sp,-4
	g_object[g_objpos++]=0xAFA20004; //sw          v0,4(sp)
	err=get_float();
	if (err) return err;
	check_obj_space(3);
	g_object[g_objpos++]=0x00022021; //addu        a0,zero,v0
	g_object[g_objpos++]=0x8FA20004; //lw          v0,4(sp)
	g_object[g_objpos++]=0x27BD0004; //addiu       sp,sp,4
	call_lib_code(LIB_SPRINTF);
	return 0;
}

char* floatstr_function(void){
	char* err;
	err=get_float();
	if (err) return err;
	check_obj_space(2);
	g_object[g_objpos++]=0x00022021; //addu        a0,zero,v0
	g_object[g_objpos++]=0x34020000; //ori         v0,zero,0x0000
	call_lib_code(LIB_SPRINTF);
	return 0;
}

char* floatsharp_function(void){
	char* err;
	err=get_value();
	if (err) return err;
	call_lib_code(LIB_FLOATFUNCS | FUNC_FLOAT);
	return 0;
}

char* valsharp_function(void){
	char* err;
	err=get_string();
	if (err) return err;
	call_lib_code(LIB_FLOATFUNCS | FUNC_VALSHARP);
	return 0;
}

char* int_function(void){
	char* err;
	err=get_float();
	if (err) return err;
	call_lib_code(LIB_FLOATFUNCS | FUNC_INT);
	return 0;
}

char* fseek_function(){
	call_lib_code(LIB_FILE | FUNC_FTELL);
	return 0;
}

char* flen_function(){
	call_lib_code(LIB_FILE | FUNC_FLEN);
	return 0;
}

char* fgetc_function(){
	call_lib_code(LIB_FILE | FUNC_FGETC);
	return 0;
}

char* finput_function(){
	char* err;
	next_position();
	if (g_source[g_srcpos]!=')') {
		err=get_value();
		if (err) return err;
	} else {
		// Parameter will be zero if not defined
		check_obj_space(1);
		g_object[g_objpos++]=0x34020000; // ori v0,zero,0
	}
	call_lib_code(LIB_FILE | FUNC_FINPUT);
	return 0;
}

char* feof_function(){
	call_lib_code(LIB_FILE | FUNC_FEOF);
	return 0;
}

char* float_constant(float val){
	volatile int i;
	((float*)(&i))[0]=val;
	if (i&0xFFFF0000) {
		// 32 bit
		check_obj_space(2);
		g_object[g_objpos++]=0x3C020000|((i>>16)&0x0000FFFF); // lui   v0,xxxx
		g_object[g_objpos++]=0x34420000|(i&0x0000FFFF);       // ori v0,v0,xxxx
	} else {
		// 16 bit
		check_obj_space(1);
		g_object[g_objpos++]=0x34020000|(i&0x0000FFFF); // ori v0,zero,xxxx
	}
	return 0;	
}

char* float_1param_function(enum functions func){
	char* err;
	err=get_float();
	if (err) return err;
	call_lib_code(LIB_FLOATFUNCS | func);
	return 0;
}

char* float_2param_function(enum functions func){
	char* err;
	err=get_float();
	if (err) return err;
	next_position();
	if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
	g_srcpos++;
	check_obj_space(2);
	g_object[g_objpos++]=0x27BDFFFC; //addiu       sp,sp,-4
	g_object[g_objpos++]=0xAFA20004; //sw          v0,4(sp)
	err=get_float();
	if (err) return err;
	check_obj_space(3);
	g_object[g_objpos++]=0x00022021; //addu        a0,zero,v0
	g_object[g_objpos++]=0x8FA20004; //lw          v0,4(sp)
	g_object[g_objpos++]=0x27BD0004; //addiu       sp,sp,4
	call_lib_code(LIB_FLOATFUNCS | func);
	return 0;
}

char* float_function(void){
	char* err;
	if (nextCodeIs("FLOAT#(")) {
		err=floatsharp_function();
	} else if (nextCodeIs("VAL#(")) {
		err=valsharp_function();
	} else if (nextCodeIs("SIN#(")) {
		err=float_1param_function(FUNC_SIN);
	} else if (nextCodeIs("COS#(")) {
		err=float_1param_function(FUNC_COS);
	} else if (nextCodeIs("TAN#(")) {
		err=float_1param_function(FUNC_TAN);
	} else if (nextCodeIs("ASIN#(")) {
		err=float_1param_function(FUNC_ASIN);
	} else if (nextCodeIs("ACOS#(")) {
		err=float_1param_function(FUNC_ACOS);
	} else if (nextCodeIs("ATAN#(")) {
		err=float_1param_function(FUNC_ATAN);
	} else if (nextCodeIs("ATAN2#(")) {
		err=float_2param_function(FUNC_ATAN2);
	} else if (nextCodeIs("SINH#(")) {
		err=float_1param_function(FUNC_SINH);
	} else if (nextCodeIs("COSH#(")) {
		err=float_1param_function(FUNC_COSH);
	} else if (nextCodeIs("TANH#(")) {
		err=float_1param_function(FUNC_TANH);
	} else if (nextCodeIs("EXP#(")) {
		err=float_1param_function(FUNC_EXP);
	} else if (nextCodeIs("LOG#(")) {
		err=float_1param_function(FUNC_LOG);
	} else if (nextCodeIs("LOG10#(")) {
		err=float_1param_function(FUNC_LOG10);
	} else if (nextCodeIs("POW#(")) {
		err=float_2param_function(FUNC_POW);
	} else if (nextCodeIs("SQRT#(")) {
		err=float_1param_function(FUNC_SQRT);
	} else if (nextCodeIs("CEIL#(")) {
		err=float_1param_function(FUNC_CEIL);
	} else if (nextCodeIs("FLOOR#(")) {
		err=float_1param_function(FUNC_FLOOR);
	} else if (nextCodeIs("FABS#(")) {
		err=float_1param_function(FUNC_FABS);
	} else if (nextCodeIs("MODF#(")) {
		err=float_1param_function(FUNC_MODF);
	} else if (nextCodeIs("FMOD#(")) {
		err=float_2param_function(FUNC_FMOD);
	} else if (nextCodeIs("GOSUB#(")) {
		err=gosub_function();
	} else if (nextCodeIs("ARGS#(")) {
		err=args_function();
	} else if (nextCodeIs("PI#")) {
		return float_constant(3.141593);
	} else {
		return ERR_SYNTAX;
	}
	if (err) return err;
	if (g_source[g_srcpos]!=')') return ERR_SYNTAX;
	g_srcpos++;
	return 0;
}

char* str_function(void){
	char* err;
	if (nextCodeIs("CHR$(")) {
		err=chr_function();
	} else if (nextCodeIs("HEX$(")) {
		err=hex_function();
	} else if (nextCodeIs("DEC$(")) {
		err=dec_function();
	} else if (nextCodeIs("INPUT$(")) {
		err=input_function();
	} else if (nextCodeIs("GOSUB$(")) {
		err=gosub_function();
	} else if (nextCodeIs("ARGS$(")) {
		err=args_function();
	} else if (nextCodeIs("READ$(")) {
		err=read_function();
	} else if (nextCodeIs("SPRINTF$(")) {
		err=sprintf_function();
	} else if (nextCodeIs("FLOAT$(")) {
		err=floatstr_function();
	} else if (nextCodeIs("SYSTEM$(")) {
		err=system_function();
	} else if (nextCodeIs("FINPUT$(")) {
		err=finput_function();
	} else {
		return ERR_SYNTAX;
	}
	if (err) return err;
	if (g_source[g_srcpos]!=')') return ERR_SYNTAX;
	g_srcpos++;
	return 0;
}

char* function(void){
	char* err;
	if (nextCodeIs("NOT(")) {
		err=not_function();
	} else if (nextCodeIs("DRAWCOUNT(")) {
		err=drawcount_function();
	} else if (nextCodeIs("MUSIC(")) {
		err=music_function();
	} else if (nextCodeIs("TVRAM(")) {
		err=tvram_function();
	} else if (nextCodeIs("KEYS(")) {
		err=keys_function();
	} else if (nextCodeIs("READ(")) {
		err=read_function();
	} else if (nextCodeIs("CREAD(")) {
		err=cread_function();
	} else if (nextCodeIs("GOSUB(")) {
		err=gosub_function();
	} else if (nextCodeIs("STRNCMP(")) {
		err=strncmp_function();
	} else if (nextCodeIs("PEEK(")) {
		err=peek_function();
	} else if (nextCodeIs("LEN(")) {
		err=len_function();
	} else if (nextCodeIs("ASC(")) {
		err=asc_function();
	} else if (nextCodeIs("SGN(")) {
		err=sgn_function();
	} else if (nextCodeIs("ABS(")) {
		err=abs_function();
	} else if (nextCodeIs("RND(")) {
		err=rnd_function();
	} else if (nextCodeIs("VAL(")) {
		err=val_function();
	} else if (nextCodeIs("INKEY(")) {
		err=inkey_function();
	} else if (nextCodeIs("ARGS(")) {
		err=args_function();
	} else if (nextCodeIs("SYSTEM(")) {
		err=system_function();
	} else if (nextCodeIs("INT(")) {
		err=int_function();
	} else if (nextCodeIs("GCOLOR(")) {
		err=graphic_statement(FUNC_GCOLOR);
	} else if (nextCodeIs("FOPEN(")) {
		err=fopen_statement(FUNC_FOPEN);
	} else if (nextCodeIs("FSEEK(")) {
		err=fseek_function();
	} else if (nextCodeIs("FLEN(")) {
		err=flen_function();
	} else if (nextCodeIs("FGET(")) {
		err=fget_statement();
	} else if (nextCodeIs("FPUT(")) {
		err=fput_statement();
	} else if (nextCodeIs("FGETC(")) {
		err=fgetc_function();
	} else if (nextCodeIs("FPUTC(")) {
		err=fputc_statement();
	} else if (nextCodeIs("FREMOVE(")) {
		err=fremove_statement();
	} else if (nextCodeIs("FEOF(")) {
		err=feof_function();
	} else {
		return ERR_SYNTAX;
	}
	if (err) return err;
	if (g_source[g_srcpos]!=')') return ERR_SYNTAX;
	g_srcpos++;
	return err;
}
/*
   This file is provided under the LGPL license ver 2.1.
   Written by K.Tanaka & Katsumi
   http://www.ze.em-net.ne.jp/~kenken/index.html
   http://hp.vector.co.jp/authors/VA016157/
*/

#include "compiler.h"
#include "main.h"

// Contain the valus of $gp and $s6 (GPR of MIPS32)
int g_gp;
int g_s6;

// Line data when compiling
int g_line;
int g_fileline;

// Contain the address to which return in "END" statement.
int g_end_addr;

// Following vars are used in value.c and string.c.
// These define the depth of stack pointer used for
// handling values and strings.
int g_sdepth;
int g_maxsdepth;

// Following var shows what type of variable was defined
// in compiling the last code.
enum variable g_lastvar;

// Vars used for handling constant integer
int g_intconst;
char g_valueisconst;

// Global vars associated to RAM
char* g_source;
int g_srcpos;
int* g_object;
int g_objpos;
int* g_objmax;
char RAM[RAMSIZE] __attribute__((persistent,address(0xA0000000+PIC32MX_RAMSIZE-PERSISTENT_RAM_SIZE)));
unsigned int g_ex_data[EXCEPTION_DATA_SIZE/4] __attribute__((persistent,address(0xA0000000+PIC32MX_RAMSIZE-EXCEPTION_DATA_SIZE)));

// Global area for vars A-Z and three temporary string pointers
int g_var_mem[ALLOC_BLOCK_NUM];
unsigned short g_var_pointer[ALLOC_BLOCK_NUM];
unsigned short g_var_size[ALLOC_BLOCK_NUM];

// Flag to use temporary area when compiling
char g_temp_area_used;

// Heap area
int* g_heap_mem;
int g_max_mem;

// Random seed
unsigned int g_rnd_seed;

// Enable/disable Break keys
char g_disable_break;

// Font data used for PCG
unsigned char* g_pcg_font;

// Use or do not use graphic
char g_use_graphic;

// Pointer to graphic RAM
unsigned short* g_graphic_area;

// Parameter-containing block used for library
int* g_libparams;

// Number of long name variables
int g_long_name_var_num;

// General purpose integer used for asigning value with pointer
int g_temp;
/*
   This file is provided under the LGPL license ver 2.1.
   Written by K.Tanaka
   http://www.ze.em-net.ne.jp/~kenken/index.html
*/
// キー入力、カーソル表示関連機能 by K.Tanaka
// PS/2キーボード入力システム、カラーテキスト出力システム利用

#include "videoout.h"
#include "ps2keyboard.h"
#include "keyinput.h"

unsigned char lineinputbuf[256]; //lineinput関数用一時バッファ
unsigned char blinkchar,blinkcolor;
int blinktimer;
int insertmode; //挿入モード：1、上書きモード：0

void getcursorchar(){
// カーソル点滅用に元の文字コードを退避
	blinkchar=*cursor;
	if(twidth==WIDTH_X1) blinkcolor=*(cursor+ATTROFFSET1);
	else blinkcolor=*(cursor+ATTROFFSET2);
}
void resetcursorchar(){
// カーソルを元の文字に戻す
	*cursor=blinkchar;
	if(twidth==WIDTH_X1) *(cursor+ATTROFFSET1)=blinkcolor;
	else *(cursor+ATTROFFSET2)=blinkcolor;
}
void blinkcursorchar(){
// 定期的に呼び出すことでカーソルを点滅表示させる
// BLINKTIMEで点滅間隔を設定
// 事前にgetcursorchar()を呼び出しておく
	blinktimer++;
	if(blinktimer>=BLINKTIME*2) blinktimer=0;
	if(blinktimer<BLINKTIME){
		if(insertmode) *cursor=CURSORCHAR;
		else *cursor=CURSORCHAR2;
		if(twidth==WIDTH_X1) *(cursor+ATTROFFSET1)=CURSORCOLOR;
		else *(cursor+ATTROFFSET2)=CURSORCOLOR;
	}
	else{
		*cursor=blinkchar;
		if(twidth==WIDTH_X1) *(cursor+ATTROFFSET1)=blinkcolor;
		else *(cursor+ATTROFFSET2)=blinkcolor;
	}
}

unsigned char inputchar(void){
// キーボードから1キー入力待ち
// 戻り値 通常文字の場合ASCIIコード、その他は0、グローバル変数vkeyに仮想キーコード
	unsigned char k;
	unsigned short d;
	d=drawcount;
	while(1){
		while(d==drawcount) asm("wait"); //60分の1秒ウェイト
		d=drawcount;
		k=ps2readkey();  //キーバッファから読み込み、k1:通常文字入力の場合ASCIIコード
		if(vkey) return k;
	}
}

unsigned char cursorinputchar(void){
// カーソル表示しながらキーボードから1キー入力待ち
// 戻り値 通常文字の場合ASCIIコード、その他は0、グローバル変数vkeyに仮想キーコード
	unsigned char k;
	unsigned short d;
	getcursorchar(); //カーソル位置の文字を退避（カーソル点滅用）
	d=drawcount;
	while(1){
		while(d==drawcount) asm("wait"); //60分の1秒ウェイト
		d=drawcount;
		blinkcursorchar(); //カーソル点滅させる
		k=ps2readkey();  //キーバッファから読み込み、k1:通常文字入力の場合ASCIIコード
		if(vkey) break;  //キーが押された場合ループから抜ける
	}
	resetcursorchar(); //カーソルを元の文字表示に戻す
	return k;
}

unsigned char printinputchar(void){
// カーソル表示しながらキーボードから通常文字キー入力待ちし、入力された文字を表示
// 戻り値 入力された文字のASCIIコード、グローバル変数vkeyに最後に押されたキーの仮想キーコード
	unsigned char k;
	while(1){
		k=cursorinputchar();
		if(k) break;
	}
	printchar(k);
	return k;
}

int lineinput(char *s,int n){
// キー入力して文字列配列sに格納
// sに初期文字列を入れておくと最初に表示して文字列の最後にカーソル移動する
// 初期文字列を使用しない場合は*s=0としておく
// カーソル位置はsetcursor関数で指定しておく
// 最大文字数n、最後に0を格納するのでn+1バイトの領域必要、ただしnの最大値は255
// 戻り値　Enterで終了した場合0、ESCで終了時は-1（sは壊さない）
//
	unsigned char *ps,*pd,*pc;
	unsigned char k1,k2;
	int i;

	if(n>255) return -1;
	ps=s;
	pd=lineinputbuf;
	i=0;
	//初期文字列をlineinputbufにコピーし、文字数をiに入れる
	while(*ps!=0 && i<n){
		*pd++=*ps++;
		i++;
	}
	*pd=0;//バッファ内の文字列最後に0
	pc=pd;//現在の文字入力位置ポインタ（最後尾）
	if(i>0) printstr(lineinputbuf); //初期文字列表示
	while(1){
		k1=cursorinputchar(); //カーソル表示しながら1キー入力待ち
		k2=(unsigned char)vkey; //k2:仮想キーコード
		if(k1){
			//通常文字の場合
			if(insertmode || *pc==0){
				//挿入モードまたは最後尾の場合
				if(i==n) continue; //入力文字数最大値の場合無視
				for(pd=lineinputbuf+i;pd>=pc;pd--) *(pd+1)=*pd; //1文字分挿入
				i++;
			}
			*pc=k1; //入力文字を追加
			printstr(pc); //入力文字以降を表示
			pc++;
			for(ps=lineinputbuf+i;ps>pc;ps--) cursor--; //カーソル位置戻し
		}
		else switch(k2){
			//制御文字の場合
			case VK_LEFT:
			case VK_NUMPAD4:
				//左矢印キー
				if(pc>lineinputbuf){
					pc--;
					cursor--;
				}
				break;
			case VK_RIGHT:
			case VK_NUMPAD6:
				//右矢印キー
				if(*pc!=0){
					pc++;
					cursor++;
				}
				break;
			case VK_RETURN: //Enterキー
			case VK_SEPARATOR: //テンキーのEnter
				//入力用バッファから呼び出し元のバッファにコピーして終了
				printchar('\n');
				ps=lineinputbuf;
				pd=s;
				while(*ps!=0) *pd++=*ps++;
				*pd=0;
				return 0;
			case VK_HOME:
			case VK_NUMPAD7:
				//Homeキー、文字列先頭にカーソル移動
				while(pc>lineinputbuf){
					pc--;
					cursor--;
				}
				break;
			case VK_END:
			case VK_NUMPAD1:
				//Endキー、文字列最後尾にカーソル移動
				while(*pc!=0){
					pc++;
					cursor++;
				}
				break;
			case VK_BACK:
				//Back Spaceキー、1文字左に移動しDelete処理
				if(pc==lineinputbuf) break;//カーソルが先頭の場合、無視
				pc--;
				cursor--;
			case VK_DELETE:
			case VK_DECIMAL:
				//Deleteキー、カーソル位置の1文字削除
				if(*pc==0) break;//カーソルが最後尾の場合、無視
				for(pd=pc;*(pd+1)!=0;pd++) *pd=*(pd+1);
				*pd=0;
				i--;
				printstr(pc);
				printchar(0);//NULL文字表示
				for(ps=lineinputbuf+i+1;ps>pc;ps--) cursor--;
				break;
			case VK_INSERT:
			case VK_NUMPAD0:
				//Insertキー、挿入モードトグル動作
				insertmode^=1;
				break;
			case VK_ESCAPE:
			case VK_CANCEL:
				//ESCキーまたはCTRL+Breakキー、-1で終了
				return -1;
		}
	}
}
/*
   This file is provided under the LGPL license ver 2.1.
   Written by Katsumi.
   http://hp.vector.co.jp/authors/VA016157/
   kmorimatsu@users.sourceforge.jp
*/

#include <xc.h>
#include "main.h"
#include "compiler.h"
#include "api.h"
#include "keyinput.h"
#include "stdlib.h"
#include "math.h"

/*
   Local global variables used for graphic
 */

static int g_gcolor=7;
static int g_prev_x=0;
static int g_prev_y=0;

int lib_read(int mode, unsigned int label){
	unsigned int i,code,code2;
	static unsigned int pos=0;
	static unsigned int in_data=0;
	static unsigned char skip=0;
	if (label) {
		// RESTORE function
		switch(mode){
			case 0:
				// label is label data
				i=(int)search_label(label);
				if (!i) {
					err_data_not_found();
					return 0;
				}
				break;
			case 1:
				// label is pointer
				i=label;
				break;
			case 2:
			default:
				// Reset data/read
				pos=0;
				in_data=0;
				skip=0;
				return 0;
		}
		i-=(int)(&g_object[0]);
		pos=i/4;
		in_data=0;
	}
	// Get data
	if (in_data==0) {
		for(i=pos;i<g_objpos;i++){
			code=g_object[i];
			code2=g_object[i+1];
			if ((code&0xFFFF0000)!=0x04110000) continue;
			// "bgezal zero," assembly found.
			// Check if 0x00000020,0x00000021,0x00000022, or 0x00000023 follows
			if ((code2&0xfffffffc)!=0x00000020) {// add/addu/sub/subu        zero,zero,zero
				// If not, skip following block (it's strig).
				i+=code&0x0000FFFF;
				continue;
			}
			// DATA region found.
			in_data=(code&0x0000FFFF)-1;
			pos=i+2;
			skip=code2&0x03;
			break;
		}
		if (g_objpos<=i) {
			err_data_not_found();
			return 0;
		}
	}
	if (label) {
		// RESTORE function. Return pointer.
		return ((int)&g_object[pos])+skip;
	} else {
		switch(mode){
			case 0:
				// READ() function
				in_data--;
				return g_object[pos++];
			case 1:
			default:
				// CREAD() function
				i=g_object[pos];
				i>>=skip*8;
				i&=0xff;
				if ((++skip)==4) {
					skip=0;
					in_data--;
					pos++;
				}
				return i;
		}
	}
}

void reset_dataread(){
	lib_read(2,1);
}

char* lib_midstr(int var_num, int pos, int len){
	int i;
	char* str;
	char* ret;
	if (0<=pos) {
		// String after "pos" position.
		str=(char*)(g_var_mem[var_num]+pos);
	} else {
		// String right "pos" characters.
		// Determine length
		str=(char*)g_var_mem[var_num];
		for(i=0;str[i];i++);
		if (0<=(i+pos)) {
			str=(char*)(g_var_mem[var_num]+i+pos);
		}
	}
	if (len<0) {
		// Length is not specified.
		// Return the string to the end.
		return str;
	}
	// Length is specified.
	// Construct temporary string containing specified number of characters.
	ret=alloc_memory((len+1+3)/4,-1);
	// Copy string.
	for(i=0;(ret[i]=str[i])&&(i<len);i++);
	ret[len]=0x00;
	return ret;
}

void lib_clear(void){
	int i;
	// All variables will be integer 0
	for(i=0;i<26;i++){
		g_var_mem[i]=0;
	}
	// Clear memory allocation area
	for(i=0;i<ALLOC_BLOCK_NUM;i++){
		g_var_size[i]=0;
	}
	// Cancel PCG
	stopPCG();
	g_pcg_font=0;
}

void lib_let_str(char* str, int var_num){
	int begin,end,size;
	// Save pointer
	g_var_mem[var_num]=(int)str;
	// Determine size
	for(size=0;str[size];size++);
	// Check if str is in heap area.
	begin=(int)str;
	end=(int)(&str[size]);
	if (begin<(int)(&g_heap_mem[0]) || (int)(&g_heap_mem[g_max_mem])<=end) {
		// String is not within allcated block
		return;
	}
	// Str is in heap area. Calculate values stored in heap data dimension
	begin-=(int)(&g_heap_mem[0]);
	begin>>=2;
	end-=(int)(&g_heap_mem[0]);
	end>>=2;
	size=end-begin+1;
	g_var_pointer[var_num]=begin;
	g_var_size[var_num]=size;
}

int lib_rnd(){
	int y;
	y=g_rnd_seed;
	y = y ^ (y << 13);
	y = y ^ (y >> 17);
	y = y ^ (y << 5);
	g_rnd_seed=y;
	return y&0x7fff;
}

char* lib_chr(int num){
	char* str;
	str=alloc_memory(1,-1);
	str[0]=num&0x000000FF;
	str[1]=0x00;
	return str;
}

char* lib_dec(int num){
	char* str;
	int i,j,minus;
	char b[12];
	b[11]=0x00;
	if (num<0) {
		minus=1;
		num=0-num;
	} else {
		minus=0;
	}
	for (i=10;0<i;i--) {
		if (num==0 && i<10) break; 
		b[i]='0'+rem10_32(num);
		num=div10_32(num);
	}
	if (minus) {
		b[i]='-';
	} else {
		i++;
	}
	str=alloc_memory(3,-1);
	for(j=0;str[j]=b[i++];j++);
	return str;
}

char* lib_hex(int num, int width){
	char* str;
	int i,j,minus;
	char b[8];
	str=alloc_memory(3,-1);
	for(i=0;i<8;i++){
		b[i]="0123456789ABCDEF"[(num>>(i<<2))&0x0F];
	}
	// Width must be between 0 and 8;
	if (width<0||8<width) width=8;
	if (width==0) {
		// Width not asigned. Use minimum width.
		for(i=7;0<i;i--){
			if ('0'<b[i]) break;
		}
	} else {
		// Constant width
		i=width-1;
	}
	// Copy string to allocated block.
	for(j=0;0<=i;i--){
		str[j++]=b[i];
	}
	str[j]=0x00;
	return str;
}

char* lib_connect_string(char* str1, char* str2){
	int i,j;
	char b;
	char* result;
	// Determine total length
	for(i=0;str1[i];i++);
	for(j=0;str2[j];j++);
	// Allocate a block for new string
	result=alloc_memory((i+j+1+3)/4,-1);
	// Create connected strings 
	for(i=0;b=str1[i];i++) result[i]=b;
	for(j=0;b=str2[j];j++) result[i+j]=b;
	result[i+j]=0x00;
	free_temp_str(str1);
	free_temp_str(str2);
	return result;
}

void lib_string(int mode){
	int i;
	switch(mode){
		case 0:
			// CR
			printchar('\n');
			return;
		case 1:
			// ,
			i=rem10_32((unsigned int)(cursor-TVRAM));
			printstr("          "+i);
			return;
		default:
			return;
	}
}

void* lib_label(unsigned int label){
	// This routine is used to jump to address dynamically determined
	// in the code; for example: "GOTO 100+I"
	unsigned int i,code,search;
	void* ret;  
	if (label&0xFFFF0000) {
		// Label is not supported.
		// Line number must bs less than 65536.
		err_label_not_found();
	} else {
		// Line number
		ret=search_label(label);
		if (ret) return ret;
		// Line number not found.
		err_label_not_found();
	}
}

int lib_keys(int mask){
	int keys;
	// Enable tact switches
	if (inPS2MODE()) {
		buttonmode();
	}

	keys=KEYPORT;
	keys=
		((keys&KEYUP)?    0:1)|
		((keys&KEYDOWN)?  0:2)|
		((keys&KEYLEFT)?  0:4)|
		((keys&KEYRIGHT)? 0:8)|
		((keys&KEYSTART)? 0:16)|
		((keys&KEYFIRE)?  0:32);
	return mask&keys;
}

int lib_val(char* str){
	int i;
	int val=0;
	int sign=1;
	char b;
	// Skip blanc
	for(i=0;0<=str[i] && str[i]<0x21;i++);
	// Skip '+'
	if (str[i]=='+') i++;
	// Check '-'
	if (str[i]=='-') {
		sign=-1;
		i++;
	}
	// Check '0x' or '$'
	if (str[i]=='$' || str[i]=='0' && (str[i+1]=='x' || str[i+1]=='X')) {
		// Hexadecimal
		if (str[i++]=='0') i++;
		while(1) {
			b=str[i++];
			if ('0'<=b && b<='9') {
				val<<=4;
				val+=b-'0';
			} else if ('a'<=b && b<='f') {
				val<<=4;
				val+=b-'a'+10;
			} else if ('A'<=b && b<='F') {
				val<<=4;
				val+=b-'A'+10;
			} else {
				break;
			}
		}
	} else {
		// Decimal
		while(1) {
			b=str[i++];
			if ('0'<=b && b<='9') {
				val*=10;
				val+=b-'0';
			} else {
				break;
			}
		}
	}
	return val*sign;
}

char* lib_input(){
	// Allocate memory for strings with 63 characters
	char *str=calloc_memory((63+1)/4,-1);
	// Enable PS/2 keyboard
	if (!inPS2MODE()) {
		ps2mode();
		ps2init();
	}
	// Clear key buffer
	do ps2readkey();
	while(vkey!=0);
	// Get string as a line
	lineinput(str,63);
	check_break();
	return str;
}

unsigned char lib_inkey(int key){
	int i;
	// Enable PS/2 keyboard
	if (!inPS2MODE()) {
		ps2mode();
		ps2init();
	}
	if (key) {
		return ps2keystatus[key&0xff];
	} else {
		for(i=0;i<256;i++){
			if (ps2keystatus[i]) return i;
		}
		return 0;
	}
}

void lib_usepcg(int mode){
	// Modes; 0: stop PCG, 1: use PCG, 2: reset PCG and use it
	switch(mode){
		case 0:
			// Stop PCG
			stopPCG();
			break;
		case 2:
			// Reset PCG and use it
			if (g_pcg_font) {
				free_temp_str(g_pcg_font);
				g_pcg_font=0;
			}
			// Continue to case 1:
		case 1:
		default:
			// Use PCG
			if (g_pcg_font) {
				startPCG(g_pcg_font,0);
			} else {
				g_pcg_font=alloc_memory(256*8/4,ALLOC_PCG_BLOCK);
				startPCG(g_pcg_font,1);
			}
			break;
	}
}

void lib_pcg(unsigned int ascii,unsigned int fontdata1,unsigned int fontdata2){
	unsigned int* pcg;
	// If USEPCG has not yet executed, do now.
	if (!g_pcg_font) lib_usepcg(1);
	pcg=(unsigned int*)g_pcg_font;
	// 0 <= ascii <= 0xff
	ascii&=0xff;
	// Update font data
	ascii<<=1;
	pcg[ascii]=(fontdata1>>24)|((fontdata1&0xff0000)>>8)|((fontdata1&0xff00)<<8)|(fontdata1<<24);
	pcg[ascii+1]=(fontdata2>>24)|((fontdata2&0xff0000)>>8)|((fontdata2&0xff00)<<8)|(fontdata2<<24);
}

void lib_scroll30(int x,int y){
	int i,j;
	int vector=y*WIDTH_X1+x;
	if (vector<0) {
		// Copy data from upper address to lower address
		for(i=0-vector;i<WIDTH_X1*WIDTH_Y;i++){
			TVRAM[i+vector]=TVRAM[i];
			TVRAM[WIDTH_X1*WIDTH_Y+i+vector]=TVRAM[WIDTH_X1*WIDTH_Y+i];
		}
	} else if (0<vector) {
		// Copy data from lower address to upper address
		for(i=WIDTH_X1*WIDTH_Y-vector-1;0<=i;i--){
			TVRAM[i+vector]=TVRAM[i];
			TVRAM[WIDTH_X1*WIDTH_Y+i+vector]=TVRAM[WIDTH_X1*WIDTH_Y+i];
		}
	} else {
		return;
	}
	if (x<0) {
		// Fill blanc at right
		for(i=x;i<0;i++){
			for(j=WIDTH_X1+i;j<WIDTH_X1*WIDTH_Y;j+=WIDTH_X1){
				TVRAM[j]=0x00;
				TVRAM[WIDTH_X1*WIDTH_Y+j]=cursorcolor;
			}
		}
	} else if (0<x) {
		// Fill blanc at left
		for(i=0;i<x;i++){
			for(j=i;j<WIDTH_X1*WIDTH_Y;j+=WIDTH_X1){
				TVRAM[j]=0x00;
				TVRAM[WIDTH_X1*WIDTH_Y+j]=cursorcolor;
			}
		}
	}
	if (y<0) {
		// Fill blanc at bottom
		for(i=WIDTH_X1*(WIDTH_Y+y);i<WIDTH_X1*WIDTH_Y;i++){
				TVRAM[i]=0x00;
				TVRAM[WIDTH_X1*WIDTH_Y+i]=cursorcolor;
		}
	} else if (0<y) {
		// Fill blanc at top
		for(i=0;i<WIDTH_X1*y;i++){
				TVRAM[i]=0x00;
				TVRAM[WIDTH_X1*WIDTH_Y+i]=cursorcolor;
		}
	}
}

void lib_scroll40(int x,int y){
	int i,j;
	int vector=y*WIDTH_X2+x;
	if (vector<0) {
		// Copy data from upper address to lower address
		for(i=0-vector;i<WIDTH_X2*WIDTH_Y;i++){
			TVRAM[i+vector]=TVRAM[i];
			TVRAM[WIDTH_X2*WIDTH_Y+i+vector]=TVRAM[WIDTH_X2*WIDTH_Y+i];
		}
	} else if (0<vector) {
		// Copy data from lower address to upper address
		for(i=WIDTH_X2*WIDTH_Y-vector-1;0<=i;i--){
			TVRAM[i+vector]=TVRAM[i];
			TVRAM[WIDTH_X2*WIDTH_Y+i+vector]=TVRAM[WIDTH_X2*WIDTH_Y+i];
		}
	} else {
		return;
	}
	if (x<0) {
		// Fill blanc at right
		for(i=x;i<0;i++){
			for(j=WIDTH_X2+i;j<WIDTH_X2*WIDTH_Y;j+=WIDTH_X2){
				TVRAM[j]=0x00;
				TVRAM[WIDTH_X2*WIDTH_Y+j]=cursorcolor;
			}
		}
	} else if (0<x) {
		// Fill blanc at left
		for(i=0;i<x;i++){
			for(j=i;j<WIDTH_X2*WIDTH_Y;j+=WIDTH_X2){
				TVRAM[j]=0x00;
				TVRAM[WIDTH_X2*WIDTH_Y+j]=cursorcolor;
			}
		}
	}
	if (y<0) {
		// Fill blanc at bottom
		for(i=WIDTH_X2*(WIDTH_Y+y);i<WIDTH_X2*WIDTH_Y;i++){
				TVRAM[i]=0x00;
				TVRAM[WIDTH_X2*WIDTH_Y+i]=cursorcolor;
		}
	} else if (0<y) {
		// Fill blanc at top
		for(i=0;i<WIDTH_X2*y;i++){
				TVRAM[i]=0x00;
				TVRAM[WIDTH_X2*WIDTH_Y+i]=cursorcolor;
		}
	}
}

void __attribute__((nomips16)) lib_wait(int period){
	int i;
	unsigned short dcount;
	for(i=0;i<period;i++){
		dcount=drawcount;
		while(dcount==drawcount){
			asm (WAIT);
			check_break();
		}
	}
}

void allocate_graphic_area(){
	if (!g_graphic_area) {
		// Use this pointer like unsigned short GVRAM[G_H_WORD*G_Y_RES] __attribute__ ((aligned (4)));
		g_graphic_area=(unsigned short*)alloc_memory(G_H_WORD*G_Y_RES/2,ALLOC_GRAPHIC_BLOCK);
		// Start graphic and clear screen
		init_graphic(g_graphic_area);
		// Move current point to (0,0)
		g_prev_x=g_prev_y=0;
	}
}

void lib_usegraphic(int mode){
	// Modes; 0: stop GRAPHIC, 1: use GRAPHIC, 2: reset GRAPHIC and use it
	switch(mode){
		case 0:
			if (g_use_graphic){
				// Stop GRAPHIC if used
				set_graphmode(0);
				g_use_graphic=0;
				// Set timer4 for tempo
				PR4=59473;       // 3632*262/16-1
			} else {
				// Prepare GRAPHIC area if not used and not allcated.
				allocate_graphic_area();
			}
			break;
		case 2:
			// Reset GRAPHIC and use it
			g_graphic_area=0;
			// Continue to case 1:
		case 1:
		case 3:
		default:
			// Use GRAPHIC
			allocate_graphic_area();
			// Start showing GRAPHIC with mode 1, but not with mode 3
			if (mode !=3 && !g_use_graphic){
				set_graphmode(1);
				g_use_graphic=1;
				// Set timer4 for tempo
				PR4=55756;       // ~=3405*262/16-1(55755.875)
			}
			break;
	}
}

int lib_graphic(int v0,enum functions func){
	unsigned char b;
	int x1=g_libparams[1];
	int y1=g_libparams[2];
	int x2=g_libparams[3];
	int y2=g_libparams[4];
	// Disable if graphic area is not defined.
	if (!g_graphic_area) return;
	// If C is omitted in parameters, use current color.
	if (v0==-1) {
		v0=g_gcolor;
	}
	// If X1 or Y1 is 0x80000000, use the previous values.
	if (x1==0x80000000) x1=g_prev_x;
	if (y1==0x80000000) y1=g_prev_y;
	switch(func){
		case FUNC_POINT:// X1,Y1
			g_prev_x=x1;
			g_prev_y=y1;
			break;
		case FUNC_PSET:// X1,Y1[,C]
			g_pset(x1,y1,v0&0x0F);
			g_prev_x=x1;
			g_prev_y=y1;
			break;
		case FUNC_LINE:// X1,Y1,X2,Y2[,C]
			if (y1==y2) g_hline(x1,x2,y1,v0&0x0F);
			else g_gline(x1,y1,x2,y2,v0&0x0F);
			g_prev_x=x2;
			g_prev_y=y2;
			break;
		case FUNC_BOXFILL:// X1,Y1,X2,Y2[,C]
			g_boxfill(x1,y1,x2,y2,v0&0x0F);
			g_prev_x=x2;
			g_prev_y=y2;
			break;
		case FUNC_CIRCLE:// X1,Y1,R[,C]
			g_circle(x1,y1,x2,v0&0x0F);
			g_prev_x=x1;
			g_prev_y=y1;
			break;
		case FUNC_CIRCLEFILL:// X1,Y1,R[,C]
			g_circlefill(x1,y1,x2,v0&0x0F);
			g_prev_x=x1;
			g_prev_y=y1;
			break;
		case FUNC_GPRINT:// X1,Y1,C,BC,S$
			g_printstr(x1,y1,x2,y2,(unsigned char*)v0);
			// Move current X,Y according to the string
			while(b=((unsigned char*)v0)[0]){
				v0++;
				if (b==0x0d) {
					x1=0;
					y1+=8;
				} else {
					x1+=8;
				}
			}
			g_prev_x=x1;
			g_prev_y=y1;
			break;
		case FUNC_PUTBMP2:// X1,Y1,M,N,BMP(label)
			// Search CDATA
			// It starts from either 0x00000020,0x00000021,0x00000022, or 0x00000023.
			while((((unsigned int*)v0)[0]&0xfffffffc)!=0x00000020) v0+=4;
			// CDATA starts from next word.
			// MLB 3 bytes show skip byte(s).
			v0+=4+(((unsigned int*)v0)[0]&0x03);
			// Contunue to FUNC_PUTBMP.
		case FUNC_PUTBMP:// X1,Y1,M,N,BMP(pointer)
			g_putbmpmn(x1,y1,x2,y2,(const unsigned char*)v0);
			g_prev_x=x1;
			g_prev_y=y1;
			break;
		case FUNC_GCOLOR:// (X1,Y1)
			v0=g_color(x1,y1);
			break;
		default:
			break;
	}
	return v0;
}

void lib_var_push(int a0, int a1, int* sp){
	// Note that sp[1] is used for string return address
	// sp[2] can be used to store flags
	// sp[3] etc can be used to store variable values
	int i,params;
	unsigned char varnum;
	unsigned int strflags=0;
	int stack=3;
	for(i=0;i<8;i++){
		// Prepare parameter
		switch(i){
			case 0:
				params=a0;
				break;
			case 4:
				params=a1;
				break;
			default:
				break;
		}
		// Get variable number
		varnum=params&0xff;
		params>>=8;
		if (varnum==0) break; // No more variable. End the loop.
		varnum--;
		sp[stack++]=g_var_mem[varnum];
		if (g_var_size[varnum] && g_var_mem[varnum]==(int)(&g_var_pointer[varnum])) {
			// strflags change using varnum
			strflags|=1<<i;
			// Copy to VAR_BLOCK
			move_to_perm_block(varnum);
		}
		// Clear variable
		g_var_mem[varnum]=0;
	}
	// Store string flags
	sp[2]=strflags;
}

void lib_var_pop(int a0, int a1, int* sp){
	// Note that sp is 4 bytes larger than that in lib_var_push
	// sp[1] was used to store flags
	// sp[2] etc can be used to store variable values
	int i,params;
	unsigned char varnum;
	int stack=2;
	unsigned int strflags=sp[1];
	for(i=0;i<8;i++){
		// Prepare parameter
		switch(i){
			case 0:
				params=a0;
				break;
			case 4:
				params=a1;
				break;
			default:
				break;
		}
		// Get variable number
		varnum=params&0xff;
		params>>=8;
		if (varnum==0) break; // No more variable. End the loop.
		varnum--;
		g_var_mem[varnum]=sp[stack++];
		if (strflags&(1<<i)) {
			// Restore from VAR_BLOCK
			move_from_perm_block(varnum);
		}
	}
}


int lib_system(int a0,int v0){
	switch(a0){
		// Version info
		case 0: return (int)SYSVER1;
		case 1: return (int)SYSVER2;
		case 2: return (int)BASVER;
		case 3: return (int)FILENAME_FLASH_ADDRESS;
		// Display info
		case 20: return twidth;
		case 21: return WIDTH_Y;
		case 22: return G_X_RES;
		case 23: return G_Y_RES;
		case 24: return cursorcolor;
		case 25: return g_gcolor;
		case 26: return ((int)(cursor-TVRAM))%twidth;
		case 27: return ((int)(cursor-TVRAM))/twidth;
		case 28: return g_prev_x;
		case 29: return g_prev_y;
		// Keyboard info
		case 40: return (int)inPS2MODE();
		case 41: return (int)vkey;
		case 42: return (int)lockkey;
		case 43: return (int)keytype;
		// Pointers to gloval variables
		case 100: return (int)&g_var_mem[0];
		case 101: return (int)&g_rnd_seed;
		case 102: return (int)&TVRAM[0];
		case 103: return (int)&FontData[0];
		case 104: return (int)g_var_mem[ALLOC_PCG_BLOCK];
		case 105: return (int)g_var_mem[ALLOC_GRAPHIC_BLOCK];
		// Change system settings
		case 200:
			// ON/OFF monitor
			if (v0) {
				start_composite();
			} else {
				stop_composite();
			}
			break;
		default:
			break;
	}
	return 0;
}

char* lib_sprintf(char* format, int data){
	char* str;
	int i;
	char temp[4];
	if (!format) format="%g";
	i=snprintf((char*)(&temp[0]),4,format,data)+1;
	str=alloc_memory((i+3)/4,-1);
	snprintf(str,i,format,data);
	return str;
}

int lib_floatfuncs(int ia0,int iv0,enum functions a1){
	volatile float a0,v0;
	((int*)(&a0))[0]=ia0;
	((int*)(&v0))[0]=iv0;
	switch(a1){
		case FUNC_FLOAT:
			v0=(float)iv0;
			break;
		case FUNC_INT:
			return (int)v0;
		case FUNC_VALSHARP:
			v0=strtof((const char*)iv0,0);
			break;
		case FUNC_SIN:
			v0=sinf(v0);
			break;
		case FUNC_COS:
			v0=cosf(v0);
			break;
		case FUNC_TAN:
			v0=tanf(v0);
			break;
		case FUNC_ASIN:
			v0=asinf(v0);
			break;
		case FUNC_ACOS:
			v0=acosf(v0);
			break;
		case FUNC_ATAN:
			v0=atanf(v0);
			break;
		case FUNC_ATAN2:
			v0=atan2f(v0,a0);
			break;
		case FUNC_SINH:
			v0=sinhf(v0);
			break;
		case FUNC_COSH:
			v0=coshf(v0);
			break;
		case FUNC_TANH:
			v0=tanhf(v0);
			break;
		case FUNC_EXP:
			v0=expf(v0);
			break;
		case FUNC_LOG:
			v0=logf(v0);
			break;
		case FUNC_LOG10:
			v0=log10f(v0);
			break;
		case FUNC_POW:
			v0=powf(v0,a0);
			break;
		case FUNC_SQRT:
			v0=sqrtf(v0);
			break;
		case FUNC_CEIL:
			v0=ceilf(v0);
			break;
		case FUNC_FLOOR:
			v0=floorf(v0);
			break;
		case FUNC_FABS:
			v0=fabsf(v0);
			break;
		case FUNC_MODF:
			v0=modff(v0,(void*)&a0);
			break;
		case FUNC_FMOD:
			v0=fmodf(v0,a0);
			break;
		default:
			err_unknown();
			break;
	}
	return ((int*)(&v0))[0];
};

int* lib_dim(int varnum, int argsnum, int* sp){
	int i,j;
	static int* heap;
	// Calculate total length.
	int len=0;  // Total length
	int size=1; // Size of current block
	for(i=1;i<=argsnum;i++){
		size*=sp[i]+1;
		len+=size;
	}
	// Allocate memory
	heap=calloc_memory(len,varnum);
	// Construct pointers
	len=0;
	size=1;
	for(i=1;i<argsnum;i++){
		size*=sp[i]+1;
		for(j=0;j<size;j++){
			heap[len+j]=(int)&heap[len+size+(sp[i+1]+1)*j];
		}
		len+=size;
	}
	return heap;
};

void lib_width(int width){
	switch(width){
		case 30:
			if (twidth!=30) set_width(0);
			break;
		case 40:
			if (twidth!=40) set_width(1);
			break;
		default:
			break;
	}
}

int lib_file_textlen(FSFILE* fhandle){
	char buff[128];
	int i,textlen,len,seek;
	seek=FSftell(fhandle);
	len=FSfread(&buff[0],1,128,fhandle);
	textlen=0;
	for(i=0;i<len-1;i++){ // Read 127 bytes for supporting CRLF
		if (buff[i]==0x0d) {
			if (i<len && buff[i+1]==0x0a) i++;
			break;
		} else if (buff[i]==0x0a) {
			break;
		}
		if (i==len-2) {
			// reached the end of buffer. Read next 127 bytes
			textlen+=127;
			buff[0]=buff[127];
			len=FSfread(&buff[1],1,127,fhandle);
			// Continue with i=0
			i=-1;
		}
	}
	// The last return code must be included to caluclate total length.
	textlen+=i+1;
	// Return to original position
	FSfseek(fhandle,seek,SEEK_SET);
	return textlen;
}

int lib_file(enum functions func, int a0, int a1, int v0){
	static FSFILE* s_fhandle[2]={0,0};
	static char activefhandle=0;
	static int numinline=0;
	FSFILE* fhandle=0;
	int i;
	int buff[1];
	char* str;
	if (activefhandle) fhandle=s_fhandle[activefhandle-1];
	switch(func){
		case FUNC_FINIT:
			// This function is not BASIC statement/function but used from
			// running routine. 
			for(i=0;i<2;i++){
				if (s_fhandle[i]) FSfclose(s_fhandle[i]);
				s_fhandle[i]=0; 
			}
			activefhandle=0;
			numinline=0;
			break;
		case FUNC_FOPEN:   // Return 0 when called as a function.
		case FUNC_FOPENST: // Stop with error when called as a statement.
			activefhandle=0;
			// Check if file handle is free to use, first.
			switch(v0){
				case 0:
					// File handle was not designated
					// Force handle=1 and continue to following cases.
					v0=1;
				case 1:
				case 2:
					// File handle was designated
					// Check if not used yet.
					if (s_fhandle[v0-1]) {
						// This file handle has been occupied.
						err_file();
						return 0;
					}
					// OK. This file handle can be asigned for new file opened.
					break;
				default:
					err_invalid_param();
					return 0;
			}
			// Open a file
			fhandle=FSfopen ((const char*) a0, (const char*) a1);
			if (!fhandle) {
				if (func==FUNC_FOPENST) err_file();
				return 0;
			}
			// The file is succesfully opened. Asign file handle.
			s_fhandle[v0-1]=fhandle;
			activefhandle=v0;
			return v0;
		case FUNC_FILE:
			switch(v0){
				case 1:
				case 2:
					if (s_fhandle[v0]) {
						activefhandle=v0;
						break;
					}
				default:
					err_invalid_param();
			}
			break;
		case FUNC_FCLOSE:
			switch(v0){
				case 0:
					break;
				case 1:
				case 2:
					if (s_fhandle[v0-1]) activefhandle=v0;
					if (activefhandle) fhandle=s_fhandle[activefhandle-1];
					break;
				default:
					err_invalid_param();
			}
			if (fhandle) {
				FSfclose(fhandle);
				s_fhandle[activefhandle-1]=0;
			}
			activefhandle=0;
			break;	
		case FUNC_FINPUT:
			if (fhandle) {
				// Determine text length if called without parameter
				if (v0==0) v0=lib_file_textlen(fhandle);
				// Allocate temporary area for string
				str=alloc_memory((v0+1+3)/4,-1);
				// Read from SD card
				v0=FSfread(str,1,v0,fhandle);
				// Null string at the end.
				str[v0]=0;
				return (int)str;
			} else {
				err_file();
				return (int)"";
			}
		case FUNC_FPRINTSTR:
			// Like lib_printstr()
			for(i=0;((char*)v0)[i];i++);
			if (fhandle) {
				if (!FSfwrite((char*)v0,1,i,fhandle)) err_file();
			} else err_file();
			numinline+=i;
			break;
		case FUNC_FSTRING:
			// Like lib_string()
			switch(v0){
				case 0:
					// CR
					lib_file(FUNC_FPRINTSTR,a0,a1,(int)"\r\n");
					numinline=0;
					break;
				case 1:
					// ,
					i=rem10_32(numinline);
					lib_file(FUNC_FPRINTSTR,a0,a1,(int)("          "+i));
					break;
				default:
					break;
			}
			break;
		case FUNC_FGET:
			if (fhandle) return FSfread((void*)a0,1,v0,fhandle);
			err_file();
			break;
		case FUNC_FPUT:
			if (fhandle) return FSfwrite((void*)a0,1,v0,fhandle);
			err_file();
			break;
		case FUNC_FGETC:
			if (fhandle) {
				// Note: Little endian.
				if (FSfread((void*)&buff[0],1,1,fhandle)) return buff[0]&0xff;
				else return -1;
			}
			err_file();
			break;
		case FUNC_FPUTC:
			if (fhandle) {
				// Note: Little endian.
				buff[0]=v0;
				return FSfwrite((void*)&buff[0],1,1,fhandle);
			}
			err_file();
			break;
		case FUNC_FSEEK:
			if (fhandle) return FSfseek(fhandle,v0,SEEK_SET);
			err_file();
			break;
		case FUNC_FTELL:
			if (fhandle) return FSftell(fhandle);
			err_file();
			break;
		case FUNC_FLEN:
			if (fhandle) return fhandle->size;
			err_file();
			break;
		case FUNC_FEOF:
			if (fhandle) return (fhandle->size<=FSftell(fhandle)) ? 1:0;
			err_file();
			break;
		case FUNC_FREMOVE:
			return FSremove((const char *)v0);
		default:
			err_unknown();
	}
	return v0;
}

int _call_library(int a0,int a1,int a2,enum libs a3);

void __attribute__((nomips16))call_library(void){
	// Store s6 in g_s6
	asm volatile("la $a2,%0"::"i"(&g_s6));
	asm volatile("sw $s6,0($a2)");
	// Copy $v0 to $a2 as 3rd argument of function
	asm volatile("addu $a2,$v0,$zero");
	// Store sp in g_libparams
	asm volatile("la $v0,%0"::"i"(&g_libparams));
	asm volatile("sw $sp,0($v0)");
	// Jump to main routine
	asm volatile("j _call_library");
}

int __attribute__((nomips16))_call_library(int a0,int a1,int v0,enum libs a3){
	// usage: call_lib_code(LIB_XXXX);
	// Above code takes 2 words.
	check_break();
	switch(a3 & LIB_MASK){
		case LIB_FLOAT:
			return lib_float(a0,v0,(enum operator)(a3 & OP_MASK)); // see operator.c
		case LIB_FLOATFUNCS:
			return lib_floatfuncs(a0,v0,(enum functions)(a3 & FUNC_MASK));
		case LIB_STRNCMP:
			return strncmp((char*)g_libparams[1],(char*)g_libparams[2],v0);
		case LIB_MIDSTR:
			return (int)lib_midstr(a1,v0,a0);
		case LIB_RND:
			return (int)lib_rnd();
		case LIB_DEC:
			return (int)lib_dec(v0);
		case LIB_HEX:
			return (int)lib_hex(v0,a0);
		case LIB_CHR:
			return (int)lib_chr(v0);
		case LIB_VAL:
			return lib_val((char*)v0);
		case LIB_LETSTR:
			lib_let_str((char*)v0,a0);
			return;
		case LIB_CONNECT_STRING:
			return (int)lib_connect_string((char*)a0, (char*)v0);
		case LIB_STRING:
			lib_string(v0);
			return v0;
		case LIB_PRINTSTR:
			printstr((char*)v0);
			return v0;
		case LIB_GRAPHIC:
			return lib_graphic(v0, (enum functions)(a3 & FUNC_MASK));
		case LIB_SPRINTF:
			return (int)lib_sprintf((char*)v0,a0);
		case LIB_VAR_PUSH:
			lib_var_push(a0,a1,g_libparams);
			return v0;
		case LIB_VAR_POP:
			lib_var_pop(a0,a1,g_libparams);
			return v0;
		case LIB_SCROLL:
			if (twidth==30) lib_scroll30(g_libparams[1],v0);
			else if (twidth==40) lib_scroll40(g_libparams[1],v0);
			return v0;
		case LIB_FILE:
			return lib_file((enum functions)(a3 & FUNC_MASK),g_libparams[1],g_libparams[2],v0);
		case LIB_KEYS:
			return lib_keys(v0);
		case LIB_INKEY:
			return (int)lib_inkey(v0);
		case LIB_CURSOR:
			setcursor(g_libparams[1],v0,cursorcolor);
			return v0;
		case LIB_SOUND:
			set_sound((unsigned long*)v0);
			return v0;
		case LIB_MUSICFUNC:
			return musicRemaining();
		case LIB_MUSIC:
			set_music((char*)v0);
			return v0;
		case LIB_SETDRAWCOUNT:
			drawcount=(v0&0x0000FFFF);
			return v0;
		case LIB_DRAWCOUNT:
			return drawcount;
		case LIB_SYSTEM:
			return lib_system(a0,v0);
		case LIB_RESTORE:
			return lib_read(0,v0);
		case LIB_RESTORE2:
			return lib_read(1,v0);
		case LIB_READ:
			return lib_read(0,0);
		case LIB_CREAD:
			return lib_read(1,0);
		case LIB_LABEL:
			return (int)lib_label(v0);
		case LIB_INPUT:
			return (int)lib_input();
		case LIB_USEGRAPHIC:
			lib_usegraphic(v0);
			return v0;
		case LIB_USEPCG:
			lib_usepcg(v0);
			return v0;
		case LIB_PCG:
			lib_pcg(g_libparams[1],g_libparams[2],v0);
			return v0;
		case LIB_BGCOLOR: // BGCOLOR R,G,B
			set_bgcolor(v0,g_libparams[1],g_libparams[2]); //set_bgcolor(b,r,g);
			return v0;
		case LIB_PALETTE: // PALETTE N,R,G,B
			set_palette(g_libparams[1],v0,g_libparams[2],g_libparams[3]); // set_palette(n,b,r,g);
			return v0;
		case LIB_GPALETTE:// GPALETTE N,R,G,B
			if (g_graphic_area) g_set_palette(g_libparams[1],v0,g_libparams[2],g_libparams[3]); // g_set_palette(n,b,r,g);
			return v0;
		case LIB_CLS:
			clearscreen();
			return v0;
		case LIB_GCLS:
			if (g_graphic_area) g_clearscreen();
			g_prev_x=g_prev_y=0;
			return v0;
		case LIB_WIDTH:
			lib_width(v0);
			return v0;
		case LIB_COLOR:
			setcursorcolor(v0);
			return v0;
		case LIB_GCOLOR:
			g_gcolor=v0;
			return v0;
		case LIB_WAIT:
			lib_wait(v0);
			return v0;
		case LIB_CLEAR:
			lib_clear();
			return v0;
		case LIB_DIM:
			return (int)lib_dim(a0,a1,(int*)v0);
#ifdef __DEBUG
		case LIB_DEBUG:
			asm volatile("nop");
			return v0;
#endif
		case LIB_DIV0:
			err_div_zero();
			return v0;
		default:
			err_unknown();
			return v0;
	}
}
/*
   This file is provided under the LGPL license ver 2.1.
   Written by Katsumi.
   http://hp.vector.co.jp/authors/VA016157/
   kmorimatsu@users.sourceforge.jp
*/

#include "compiler.h"

unsigned int g_label;

char* get_label(void){
	unsigned int i;
	char b1;
	int prevpos;
	next_position();
	prevpos=g_srcpos;
	i=0;
	b1=g_source[g_srcpos];
	if ('0'<= b1 && b1<='9') {
		// May be line number
		do {
			i*=10;
			i+=b1-'0';
			g_srcpos++;
			b1=g_source[g_srcpos];
		} while ('0'<= b1 && b1<='9');
		// Check if end of the statement.
		if (i==0 || 65535<i) {
			// Line number 0 or more than 65535 is not available
			g_srcpos=prevpos;
			return ERR_SYNTAX;
		} else if (get_operator()) {
			// Oparator not found.
			g_label=i;
			return 0;
		} else {
			// This is not constant line number.
			g_srcpos=prevpos;
			g_label=0;
			return 0;
		}
	} else if ('A'<=b1 && b1<='Z') {
		// May be label
		do {
			// First character must be A-Z
			// From second, A-Z and 0-9 can be used.
			i*=36;
			if ('0'<=b1 && b1<='9') {
				i+=b1-'0';
			} else if (g_srcpos==prevpos) {
				// First character must be A-Z.
				// Subtract 9, resulting 1-26 but not 10-35.
				// This subtraction is required to maintain
				// final number being <0x80000000.
				i+=b1-'A'+1;
			} else {
				i+=b1-'A'+10;
			}
			g_srcpos++;
			b1=g_source[g_srcpos];
		} while ('0'<= b1 && b1<='9' || 'A'<=b1 && b1<='Z');
		// Length of the label must be between 2 and 6.
		if (g_srcpos-prevpos<2 || 6<g_srcpos-prevpos) {
			g_srcpos=prevpos;
			return ERR_LABEL_LONG;
		}
		// Must not be a function
		next_position();
		if (g_source[g_srcpos]=='(') {
			g_srcpos=prevpos;
			g_label=0;
			return 0;
		}
		g_label=i+65536;
		return 0;
	} else {
		g_label=0;
		return 0;
	}
}

void* search_label(unsigned int label){
	unsigned int i,code,search1,search2;
	if (label&0xFFFF0000) {
		// Label
		search1=0x3C160000|((label>>16)&0x0000FFFF); //lui s6,yyyy;
		search2=0x36D60000|(label&0x0000FFFF);       //ori s6,s6,zzzz;
		for(i=0;i<g_objpos;i++){
			code=g_object[i];
			if (code==search1) {
				if (g_object[i+1]==search2) {
					// Label number found
					return &(g_object[i]);
				}
			}
			if (code&0xFFFF0000==0x04110000) {
				// "bgezal zero," assembly found. Skip following block (strig).
				i+=code&0x0000FFFF;
			}
		}
		// Line number not found.
		return 0;
	} else {
		// Line number
		search1=0x34160000|label; //ori         s6,zero,xxxx;
		for(i=0;i<g_objpos;i++){
			code=g_object[i];
			if (code==search1) {
				// Line number found
				return &(g_object[i]);
			}
			if (code&0xFFFF0000==0x04110000) {
				// "bgezal zero," assembly found. Skip following block (strig).
				i+=code&0x0000FFFF;
			}
		}
		// Line number not found.
		return 0;
	}
}

void* search_breakout(unsigned int start, int* prevcode){
	unsigned int pos,code1,depth;
	// Start search from start point where BREAK statement is used.
	depth=0;
	for(pos=start;pos<g_objpos;pos++){
		code1=g_object[pos];
		switch(code1>>16){
			case 0x0411:
				// "bgezal zero," assembly found. Skip following block (strig).
				pos+=code1&0x0000FFFF;
				break;
			case 0x0820: // FOR
			case 0x0821: // WHILE
			case 0x0822: // DO
				depth++;
				break;
			case 0x0830: // NEXT
			case 0x0831: // WEND
			case 0x0832: // LOOP
				if (0<depth) {
					depth--;
					break;
				}
				// Destination found.
				// Previous code will be also set if required for CONTINUE statement.
				if (prevcode) prevcode[0]=g_object[pos-1];
				return (void*)&g_object[pos];
			default:
				break;
		}
	}
	return 0;
}

void* search_ifout(unsigned int start){
	unsigned int pos,code1,depth;
	// Start search from start point where BREAK statement is used.
	depth=0;
	for(pos=start;pos<g_objpos;pos++){
		code1=g_object[pos];
		switch(code1>>16){
			case 0x0411:
				// "bgezal zero," assembly found. Skip following block (strig).
				pos+=code1&0x0000FFFF;
				break;
			case 0x3000: // Block marker
				if (code1==0x30008000) {
					// end block
					if (0<depth) {
						depth--;
						break;
					}
					// Destination found.
					return (void*)&g_object[pos];
				} else if (code1==0x30000000) {
					// begin block
					depth++;
					break;
				} else {
					break;
				}
			default:
				break;
		}
	}
	return 0;
}

/*
	Following codes are dedicated to specific use:
	0x0411xxxx: String/data block
		Use 0x0413xxxx (bzegall zero,xxxx) for other cases to get PC to $ra
	0x0810xxxx, 0x0811xxxx: GOTO statement
	0x0812xxxx, 0x0813xxxx: GOSUB statement
	0x0814xxxx, 0x0815xxxx: SOUND etc, for setting v0 as pointer to DATA array.
	0x0816xxxx: BREAK statemant and relatives
		0x08160000: BREAK
		0x08160008: CONTINUE
		0x08160100: Jump to next ELSE, ELSEIF or ENDIF
	0x082xyyyy: Begin block (FOR/DO/WHILE)
	0x083xyyyy: End block (NEXT/LOOP/WEND)
	0x00000020, 0x00000021,
	0x00000022, 0x00000023: Marker for begining the DATA region.
	                        MLB 2 bits show skip byte length in DATA.
	0x30000000: Begin block (IF-THEN-ELSEIF-ELSE-ENDIF)
	0x30008000: End block (IF-THEN-ELSEIF-ELSE-ENDIF)
	0x3000Fxxx: General purpose NOP with value 0x0000-0x0FFF.

	IF-THEN-ELSEIF-ELSE-ENDIF is written as follows:
		IF-THEN: 0x30000000 0x10400000 0x30000000
		ELSEIF-THEN: 0x08160100 0x30008000 (conditional expression) 0x10400000 0x30000000
		ELSE: 0x08160100 0x30008000 0x30000000
		ENDIF: 0x30008000 0x30008000 
	, where "0x10400000 0x30000000" and "0x08160100 0x30008000" will be replaced by
	codes jumping to next 0x30008000. The 0x30000000 - 0x30008000 blocks will be skipped.
*/

char* link(void){
	int pos;
	unsigned int code1,code2,label;
	g_fileline=0;
	for(pos=0;pos<g_objpos;pos++){
		code1=g_object[pos];
		switch(code1>>16){
			case 0x0411:
				// "bgezal zero," assembly found. Skip following block (strig).
				pos+=code1&0x0000FFFF;
				break;
			case 0x3416:
				// "ori s6,zero,xxxx" found this is the first word in a line.
				g_fileline++;
				g_line=code1&0x0000FFFF;
				break;
			case 0x0810:
				// GOTO
				code2=g_object[pos+1];
				if ((code2&0xFFFF0000)!=0x08110000) continue;
				code1&=0x0000FFFF;
				code2&=0x0000FFFF;
				label=(code1<<16)|code2;
				code1=(int)search_label(label);
				g_label=label;
				if (!code1) return ERR_LABEL_NF;
				code1&=0x0FFFFFFF;
				code1>>=2;
				code1|=0x08000000; // j xxxx
				g_object[pos++]=code1;
				g_object[pos]=0x00000000; // nop
				break;
			case 0x0812:
				// GOSUB
				code2=g_object[pos+1];
				if ((code2&0xFFFF0000)!=0x08130000) continue;
				code1&=0x0000FFFF;
				code2&=0x0000FFFF;
				label=(code1<<16)|code2;
				code2=(int)search_label(label);
				g_label=label;
				if (!code2) return ERR_LABEL_NF;
				code2&=0x0FFFFFFF;
				code2>>=2;
				code2|=0x08000000; // j xxxx
				g_object[pos++]=0x00000000; // nop
				g_object[pos]=code2;
				break;
			case 0x0814:
				// SOUND etc, for setting v0 as pointer to label/line
				code2=g_object[pos+1];
				if ((code2&0xFFFF0000)!=0x08150000) continue;
				code1&=0x0000FFFF;
				code2&=0x0000FFFF;
				label=(code1<<16)|code2;
				code1=(int)search_label(label);
				g_label=label;
				if (!code1) return ERR_LABEL_NF;
				g_object[pos++]=0x3C020000|((code1>>16)&0x0000FFFF); // lui   v0,xxxx
				g_object[pos]  =0x34420000|(code1&0x0000FFFF);       // ori v0,v0,xxxx
				break;
			case 0x0816:
				switch(code1&0xFFFF) {
					case 0x0000:
						// BREAK statement
						// Find next the NEXT or WHILE statement and insert jump code after this.
						g_label=g_line;
						code1=(int)search_breakout(pos,0);
						if (!code1) return ERR_INVALID_BREAK;
						code1&=0x0FFFFFFF;
						code1>>=2;
						code1|=0x08000000; // j xxxx
						g_object[pos]=code1;
						break;
					case 0x0008:
						// CONTINUE statement
						// Find next the NEXT or WHILE statement and insert jump code after this.
						g_label=g_line;
						code1=(int)search_breakout(pos,&g_temp);
						if (!code1) return ERR_INVALID_BREAK;
						if (0x3000F000 == (g_temp&0xFFFFF000)) {
							// WEND or LOOP statement found
							code1-=(g_temp&0x0FFF)<<2;
						} else {
							// NEXT statement found
							code1-=3<<2;
						}
						code1&=0x0FFFFFFF;
						code1>>=2;
						code1|=0x08000000; // j xxxx
						g_object[pos]=code1;
						break;
					case 0x0100:
						// Jump to next ENDIF
						g_label=g_line;
						// "pos+2" is for skipping next code (must be 0x30008000)
						code1=(int)search_ifout(pos+2);
						if (!code1) return ERR_INVALID_ELSEIF;
						code1&=0x0FFFFFFF;
						code1>>=2;
						code1|=0x08000000; // j xxxx
						g_object[pos]=code1;
						break;
					default:
						break;
				}
				break;
			case 0x3000:
				// Block marker
				switch(code1&0xFFFF) {
					case 0x0000:
						// Begin if block
						if (g_object[pos-1]==0x10400000) { // beq v0,zero,xxxx
							// IF-THEN or ELSEIF-THEN
							// Jump to next ELSE, ELSEIF or ENDIF
							g_label=g_line;
							// "pos+1" is for skipping current code (0x30000000)
							code1=(int)search_ifout(pos+1);
							if (!code1) return ERR_INVALID_ELSEIF;
							code1-=(int)(&g_object[pos]);
							code1>>=2;
							code1&=0x0000FFFF;
							code1|=0x10400000; // beq v0,zero,xxxx
							g_object[pos-1]=code1;
							break;
						}
						break;
					default:
						break;
				}
				break;
			case 0x0820: // FOR
			case 0x0830: // NEXT
			case 0x0821: // WHILE
			case 0x0831: // WEND
			case 0x0822: // DO
			case 0x0832: // WHILE
				// These are used for detecing the depth of structures.
				// Change them to stack increase/decrease commands.
				g_object[pos]=0x27BD0000|(code1&0x0000FFFF); //// addiu       sp,sp,xx
				break;
			case 0x2407:                                // addiu       a3,zero,xxxx
				if (g_object[pos-1]!=0x02E0F809) break; // jalr        ra,s7
				// call_lib_code(x)
				switch(code1&0x0000FFFF){
					case LIB_RESTORE:
						// Convert label data to pointer if not dynamic
						code1=g_object[pos-3];
						code2=g_object[pos-2];
						if ((code1>>16)!=0x3C02) break; // lui         v0,xxxx
						if ((code2>>16)!=0x3442) break; // ori         v0,v0,xxxx
						label=(code1<<16)|(code2&0x0000FFFF);
						code1=(int)search_label(label);
						g_label=label;
						if (!code1) return ERR_LABEL_NF;
						code2=code1&0x0000FFFF;
						code1=code1>>16;
						g_object[pos-3]=0x3C020000|code1;      // lui         v0,xxxx
						g_object[pos-2]=0x34420000|code2;      // ori         v0,v0,xxxx
						g_object[pos]=0x24070000|LIB_RESTORE2; // addiu       a3,zero,xxxx
						break;
					default:
						break;
				}
				break;
			default:
				break;
		}
	}
	return 0;
}/*
   This file is provided under the LGPL license ver 2.1.
   Written by K.Tanaka & Katsumi
   http://www.ze.em-net.ne.jp/~kenken/index.html
   http://hp.vector.co.jp/authors/VA016157/
*/

// main.c
// MachiKania BASIC System Ver Zoea
// KM-BASIC 統合開発実行環境 for PIC32MX170F256B / PIC32MX270F256B by K.Tanaka

// 利用システム
// ps2keyboard.X.a : PS/2キーボード入力システムライブラリ
// lib_colortext32.a : カラービデオ信号出力システムライブラリ（30×27テキスト版）
// libsdfsio.a ： SDカードアクセス用ライブラリ

#include <xc.h>
#include "api.h"
#include "compiler.h"
#include "editor.h"
#include "keyinput.h"
#include "main.h"

//外付けクリスタル with PLL (16倍)
#pragma config PMDL1WAY = OFF, IOL1WAY = OFF
#pragma config FPLLIDIV = DIV_1, FPLLMUL = MUL_16, FPLLODIV = DIV_1
#pragma config FNOSC = PRIPLL, FSOSCEN = OFF, POSCMOD = XT, OSCIOFNC = OFF
#pragma config FPBDIV = DIV_1, FWDTEN = OFF, JTAGEN = OFF, ICESEL = ICS_PGx1
#pragma config FCKSM = CSECMD

#define mBMXSetRAMKernProgOffset(offset)	(BMXDKPBA = (offset))
#define mBMXSetRAMUserDataOffset(offset)	(BMXDUDBA = (offset))
#define mBMXSetRAMUserProgOffset(offset)	(BMXDUPBA = (offset))

// INIファイル指定キーワード（8文字以内）
const char InitKeywords[][9]={
	"106KEY","101KEY","NUMLOCK","CAPSLOCK","SCRLLOCK"
};

void freadline(char *s,FSFILE *fp){
// ファイルから1行読み込み、配列sに返す
// 最大8文字まで。9文字以上の場合無効
// #または0x20以下のコードを見つけた場合、以降は無視
// s:9バイト以上の配列
// fp:ファイルポインタ
	int n;
	char c,*p;
	n=0;
	p=s;
	*p=0;
	while(n<=8){
		if(FSfread(p,1,1,fp)==0 || *p=='\n'){
			*p=0;
			return;
		}
		if(*p=='#'){
			*p=0;
			break;
		}
		if(*p<=' '){
			if(n>0){
				*p=0;
				break;
			}
			continue;
		}
		p++;
		n++;
	}
	if(n>8) *s=0; //9文字以上の文字列の場合は無効
	//以降の文字は無視
	while(FSfread(&c,1,1,fp) && c!='\n') ;
}
int searchinittext(char *s){
// InitKeywords配列の中から文字列sを探し、位置した場合何番目かを返す
// 見つからなかった場合-1を返す
	int i;
	char *p1;
	const char *p2;
	for(i=0;i<sizeof(InitKeywords)/sizeof(InitKeywords[0]);i++){
		p1=s;
		p2=InitKeywords[i];
		while(*p1==*p2){
			if(*p1==0) return i;
			p1++;
			p2++;
		}
	}
	return -1;
}
void readinifile(void){
	FSFILE *fp;
	char inittext[9];

	fp=FSfopen(INIFILE,"r");
	if(fp==NULL) return;
	printstr("Initialization File Found\n");
	lockkey=0; //INIファイルが存在する場合、Lock関連キーはINIファイルに従う
	while(1){
		if(FSfeof(fp)) break;
		freadline(inittext,fp);
		switch(searchinittext(inittext)){
			case 0:
				keytype=0;//日本語キーボード
				break;
			case 1:
				keytype=1;//英語キーボード
				break;
			case 2:
				lockkey|=2;//Num Lock
				break;
			case 3:
				lockkey|=4;//CAPS Lock
				break;
			case 4:
				lockkey|=1;//Scroll Lock
				break;
		}
	}
	FSfclose(fp);
}

void printhex8(unsigned char d){
	printchar("0123456789ABCDEF"[d>>4]);
	printchar("0123456789ABCDEF"[d&0x0f]);	
}

void printhex16(unsigned short d){
	printhex8(d>>8);
	printhex8(d&0x00ff);
}

void printhex32(unsigned int d){
	printhex16(d>>16);
	printhex16(d&0x0000ffff);
}

int main(void){
	char *appname,*s;

	if(DEVCFG1 & 0x8000){
		// Set Clock switching enabled and reset
		NVMWriteWord(&DEVCFG1,DEVCFG1 & 0xffff7fff);
		SoftReset();
	}

	/* ポートの初期設定 */
	TRISA = 0x0000; // PORTA全て出力
	ANSELA = 0x0000; // 全てデジタル
	TRISB = KEYSTART | KEYFIRE | KEYUP | KEYDOWN | KEYLEFT | KEYRIGHT;// ボタン接続ポート入力設定
	ANSELB = 0x0000; // 全てデジタル
	CNPUBSET=KEYSTART | KEYFIRE | KEYUP | KEYDOWN | KEYLEFT | KEYRIGHT;// プルアップ設定
	ODCB = 0x0300;	//RB8,RB9はオープンドレイン

	// 周辺機能ピン割り当て
	SDI2R=2; //RPA4:SDI2
	RPB5R=4; //RPB5:SDO2

	// Make RAM executable. See also "char RAM[RAMSIZE]" in globalvars.c
	mBMXSetRAMKernProgOffset(PIC32MX_RAMSIZE-RAMSIZE);
	mBMXSetRAMUserDataOffset(PIC32MX_RAMSIZE);
	mBMXSetRAMUserProgOffset(PIC32MX_RAMSIZE);

	ps2mode(); //RA1オン（PS/2有効化マクロ）
	init_composite(); // ビデオメモリクリア、割り込み初期化、カラービデオ出力開始
	setcursor(0,0,COLOR_NORMALTEXT);

	// Show blue screen if exception before soft reset.
	blue_screen();

	printstr("MachiKania BASIC System\n");
	printstr(" Ver "SYSVER1" "SYSVER2" by KENKEN\n");
	printstr("BASIC Compiler "BASVER"\n");
	printstr(" by Katsumi\n\n");
	//SDカードファイルシステム初期化
	setcursorcolor(COLOR_NORMALTEXT);
	printstr("Init File System...");
	// Initialize the File System
	if(FSInit()==FALSE){ //ファイルシステム初期化
		//エラーの場合停止
		setcursorcolor(COLOR_ERRORTEXT);
		printstr("\nFile System Error\n");
		printstr("Insert Correct Card\n");
		printstr("And Reset\n");
		while(1) asm("wait");
	}
	printstr("OK\n");
	lockkey=2; // NumLockキーオン
	keytype=0; // 日本語キーボード
	readinifile(); //INIファイル読み込み
	printstr("Init PS/2...");
	if(ps2init()){ //PS/2初期化
		//キーボードが見つからない場合
		printstr("Keyboard Not Found\n");
	}
	else printstr("OK\n");

	wait60thsec(60); //1秒待ち

	// 実行中HEXファイル名がHEXFILEと一致した場合はエディタ起動
	appname=(char*)FILENAME_FLASH_ADDRESS;
	s=HEXFILE;
	while(*s++==*appname++) if(*s==0) texteditor(); //テキストエディター呼び出し

	// 実行中HEXファイル名の「.HEX」を「.BAS」に置き換えてBASファイルを実行
	appname=(char*)FILENAME_FLASH_ADDRESS;
	s=tempfile;
	while(*appname!='.') *s++=*appname++;
	appname=".BAS";
	while(*appname!=0) *s++=*appname++;
	*s=0;
	// buttonmode(); //ボタン有効化
	g_disable_break=1; // Breakキー無効化
	runbasic(tempfile,0);
	while(1) asm(WAIT);
}
/*
   This file is provided under the LGPL license ver 2.1.
   Written by Katsumi.
   http://hp.vector.co.jp/authors/VA016157/
   kmorimatsu@users.sourceforge.jp
*/

#include "compiler.h"

/*
	ALLOC_VAR_NUM:    # of variables used for allocation of memory (string/dimension).
	                  0 is for A, 1 is for B, ... , and 25 is for Z.
	                  This number also includes temporary area used for string construction etc.
	                  Temporary area is cleared every line of BASIC code in alloc_memory().
	ALLOC_BLOCK_NUM:  # of blocks that can be used for memory allocation.
	                  This # also includes the ones for ALLOC_VAR_NUM.
	                  After ALLOC_VAR_NUM area, dedicated memory area and permanent area follows.
	                  Currently, only PCG is used for permanent pourpose.
                      10 permanant blocks can be used.
	                  Therefore, ALLOC_VAR_NUM+11 == ALLOC_BLOCK_NUM
	ALLOC_PERM_BLOCK: Start # of permanent blocks.
                      The blocks after this number is permanently stored.
                      Therefore, it must be released when it's not used any more.
*/

void set_free_area(void* begin, void* end){
	int i;
	for(i=0;i<ALLOC_BLOCK_NUM;i++){
		g_var_size[i]=0;
	}
	g_heap_mem=(int*)begin;
	g_max_mem=(int)((end-begin)/4);
}

void* calloc_memory(int size, int var_num){
	int i;
	void* ret;
	// Allocate memory
	ret=alloc_memory(size,var_num);
	// Fill zero in allocated memory
	for(i=0;i<size;i++){
		((int*)ret)[i]=0;
	}
	// return pointer to allocated memory
	return ret;
}
void* alloc_memory(int size, int var_num){
	// Remove temporary blocks once a line.
	asm volatile("nop");
	asm volatile("bltz $s6,_alloc_memory_main"); // Skip if $s6<0
	// Following code will be activated after setting $s6 register
	// every line and after label statement.
	asm volatile("lui $v0,0x8000");
	asm volatile("or $s6,$v0,$s6");              // $s6=0x80000000|$s6;
	// Remove all temporary blocks
	// Note that g_var_size is short integer.
	// Note that ALLOC_VAR_NUM is used here (but not ALLOC_BLOC_NUM)
	//	for(i=26;i<ALLOC_VAR_NUM;i++)g_var_size[i]=0;
	asm volatile("addiu $v0,$zero,%0"::"n"((ALLOC_VAR_NUM-26)/2)); // $v0=(ALLOC_VAR_NUM-26)/2
	asm volatile("la $v1,%0"::"i"(&g_var_size[0]));                // $v1=g_var_size
	asm volatile("loop:");
	asm volatile("sw $zero,(26*2)($v1)");                          // $v1[26]=0, $v1[27]=0
	asm volatile("addiu $v0,$v0,-1");                              // $v0--
	asm volatile("addiu $v1,$v1,4");                               // $v1+=2
	asm volatile("bne $v0,$zero,loop");                            // loop if 0<$v0
	asm volatile("b _alloc_memory_main");
}
void* _alloc_memory_main(int size, int var_num){
	int i,j,candidate;
	// Assign temp var number
	if (var_num<0) {
		// Use ALLOC_VAR_NUM here but not ALLOC_BLOCK_NUM
		for(i=26;i<ALLOC_VAR_NUM;i++){
			if (g_var_size[i]==0) {
				var_num=i;
				break;
			}
		}
		if (var_num<0) {
			err_str_complex();
			return 0;
		}
	}
	// Clear var to be assigned.
	g_var_size[var_num]=0;
	g_var_pointer[var_num]=0;
	while(1){
		// Try the block after last block
		candidate=0;
		for(i=0;i<ALLOC_BLOCK_NUM;i++){
			if (g_var_size[i]==0) continue;
			if (candidate<=g_var_pointer[i]) {
				candidate=g_var_pointer[i]+g_var_size[i];
			}
		}
		if (candidate+size<=g_max_mem) break;
		// Check between blocks
		// Note that there is at least one block with zero pointer and zero size (see above).
		for(i=0;i<ALLOC_BLOCK_NUM;i++){
			// Candidate is after this block.
			candidate=g_var_pointer[i]+g_var_size[i];
			// Check if there is an overlap.
			for(j=0;j<ALLOC_BLOCK_NUM;j++){
				if (g_var_size[j]==0) continue;
				if (candidate+size<=g_var_pointer[j]) continue;
				if (g_var_pointer[j]+g_var_size[j]<=candidate) continue;
				// This block overlaps with the candidate
				candidate=-1;
				break;
			}
			if (0<=candidate && candidate+size<=g_max_mem) {
				// Available block found
				break;
			} else {
				candidate=-1;
			}
		}
		if (0<=candidate) break;
		// New memory block cannot be allocated.
		err_no_mem();
		return 0;
	}
	// Available block found.
	g_var_pointer[var_num]=candidate;
	g_var_size[var_num]=size;
	g_var_mem[var_num]=(int)(&(g_heap_mem[candidate]));
	return (void*)g_var_mem[var_num];
}

void free_temp_str(char* str){
	int i,pointer;
	if (!str) return;
	pointer=(int)str-(int)g_heap_mem;
	pointer>>=2;
	for(i=0;i<ALLOC_BLOCK_NUM;i++){
		if (g_var_pointer[i]==pointer) {
			g_var_size[i]=0;
			break;
		}
	}
}

void move_to_perm_block(int var_num){
	int i;
	// Find available permanent block
	for (i=ALLOC_PERM_BLOCK;i<ALLOC_BLOCK_NUM;i++){
		if (g_var_size[i]==0) break;
	}
	if (ALLOC_BLOCK_NUM<=i) err_no_block(); // Not found
	// Available block found.
	// Copy value from variable.
	g_var_size[i]=g_var_size[var_num];
	g_var_pointer[i]=g_var_pointer[var_num];
	g_var_mem[i]=g_var_mem[var_num];
	// Clear variable
	g_var_size[var_num]=0;
	g_var_mem[var_num]=0;
}

void move_from_perm_block(int var_num){
	int i,pointer;
	pointer=(int)g_var_mem[var_num]-(int)g_heap_mem;
	pointer>>=2;
	// Find stored block
	for (i=ALLOC_PERM_BLOCK;i<ALLOC_BLOCK_NUM;i++){
		if (0<g_var_size[i] && g_var_pointer[i]==pointer) break;
	}
	if (ALLOC_BLOCK_NUM<=i) err_unknown(); // Not found
	// Stored block found.
	// Replace pointer
	g_var_size[var_num]=g_var_size[i];
	g_var_pointer[var_num]=g_var_pointer[i];
	// Clear block
	g_var_size[i]=0;
}/*
   This file is provided under the LGPL license ver 2.1.
   Written by Katsumi.
   http://hp.vector.co.jp/authors/VA016157/
   kmorimatsu@users.sourceforge.jp
*/

#include <xc.h>
#include "compiler.h"
#include "api.h"

/*
	Timer3: 1/32 prescaler, toggle mode : 894886.25 Hz
	PR3=2047 <-> 437 Hz
	Timer4: 1/32 prescaler: 1789772.5 Hz
	Timer4 29737 counts: 262 NTSC lines.
*/

/*
	c:  1722
	B:  1825
	A#: 1933
	A:  2048
	G#: 2170
	G:  2299
	F#: 2435
	F:  2580
	E:  2734
	D#: 2896
	D:  3067
	C#: 3251
	C:  3444
	Cb:	3650
*/

const static int g_keys[]={
	1933,1722,3251,2896,2580,2435,2170,//  0 7# C# A#m
	1933,1825,3251,2896,2580,2435,2170,//  7 6# F# D#m
	1933,1825,3251,2896,2734,2435,2170,// 14 5# B  G#m
	2048,1825,3251,2896,2734,2435,2170,// 21 4# E  C#m
	2048,1825,3251,3067,2734,2435,2170,// 28 3# A  F#m
	2048,1825,3251,3067,2734,2435,2299,// 35 2# D  Bm
	2048,1825,3444,3067,2734,2435,2299,// 42 1# G  Em
	2048,1825,3444,3067,2734,2580,2299,// 49 0  C  Am
	2048,1933,3444,3067,2734,2580,2299,// 56 1b F  Dm
	2048,1933,3444,3067,2896,2580,2299,// 63 2b Bb Gm
	2170,1933,3444,3067,2896,2580,2299,// 70 3b Eb Cm
	2170,1933,3444,3251,2896,2580,2299,// 77 4b Ab Fm
	2170,1933,3444,3251,2896,2580,2435,// 84 5b Db Bbm
	2170,1933,3650,3251,2896,2580,2435,// 91 6b Gb Ebm
	2170,1933,3650,3251,2896,2734,2435 // 98 7b Cb Abm
};

/*
	2^(1/12)    ~= 69433/(2^16)
	1/(2^(1/12) ~= 1933/(2^11)
*/

#define toneFlat(x) ((((unsigned long)x)*69433)>>16)
#define toneSharp(x) ((((unsigned long)x)*1933)>>11)

/* local global vars */
static int* g_tones;
static int g_qvalue;
static int g_lvalue;
static int g_mpoint;
static char* g_mstr;
static int g_mspos;
static unsigned short g_music[32];
static unsigned short g_sound[32];
static unsigned short g_musiclen[32];
static unsigned char g_soundlen[32];
static int g_musicstart;
static int g_musicend;
static int g_musicwait;
static int g_soundstart;
static int g_soundend;
static int g_soundwait;
static int g_soundrepeat;

int musicRemaining(){
	return (g_musicend-g_musicstart)&31;
}

#pragma interrupt timer4int IPL3SOFT vector 16

void __attribute__((nomips16, interrupt)) timer4int(){
	unsigned int i;
	// This function is called every 1/60 sec.
	IFS0CLR=_IFS0_T4IF_MASK; //IFS0bits.T4IF=0;
	if (g_soundstart!=g_soundend){
		// Start timer & OC4
		i=g_sound[g_soundstart];
		if (i<0xffff) {
			T3CONSET=0x8000;
			PR3=i;
			if (i<TMR3) TMR3=0;
		} else {
			T3CONCLR=0x8000;
		}
		if ((--g_soundwait)<=0) {
			g_soundstart++;
			if (g_soundstart==g_soundend || 31<g_soundstart) {
				g_soundstart=0;
				g_soundrepeat--;
				if (0<g_soundrepeat) {
					g_soundwait=g_soundlen[g_soundstart];
				} else {
					g_soundend=g_soundrepeat=g_soundwait=0;
				}
			} else {
				g_soundwait=g_soundlen[g_soundstart];
			}
		}
		// Shift music data even though without output.
		if (g_musicstart!=g_musicend) {
			if ((--g_musicwait)<=0) {
				g_musicstart++;
				g_musicstart&=31;
				g_musicwait=g_musiclen[g_musicstart];
			}
		}
	} else if (g_musicstart!=g_musicend) {
		// Start timer & OC4
		i=g_music[g_musicstart];
		if (i<0xffff) {
			T3CONSET=0x8000;
			PR3=i;
			if (i<TMR3) TMR3=0;
		} else {
			T3CONCLR=0x8000;
		}
		if ((--g_musicwait)<=0) {
			g_musicstart++;
			g_musicstart&=31;
			g_musicwait=g_musiclen[g_musicstart];
		}
	} else {
		// Stop timer
		T3CONCLR=0x8000;
	}
}

int musicGetNum(){
	int i, ret;
	char b;
	// Skip non number character
	for(i=0;(b=g_mstr[g_mspos+i])<'0' && '9'<g_mstr[g_mspos+i];i++);
	// Determine the number
	ret=0;
	while('0'<=b && b<='9'){
		ret*=10;
		ret+=b-'0';
		i++;
		b=g_mstr[g_mspos+i];
	}
	g_mspos+=i;
	return ret;
}

void init_music(){
	// Use Timer3 and OC4 for sound.
	RPB13R=5;        //Use RPB13 for OC4
	OC4R=0;
	OC4CON=0x000b;   // Timer3, toggle mode
	OC4CONSET=0x8000;// Start OC4
	T3CON=0x0050;    // Prescaller: 1:32 (1.8 MHz), not yet started

	// Timer4 is used to intterupt every 1/60 sec, just after NTSC view.
	T4CON=0x0040;    // Prescaller: 1:16
	PR4=59473;       // 3632*262/16-1
	// Timer 4 interruption, IPL3
	IPC4bits.T4IP=3;
	IPC4bits.T4IS=0;
	IFS0bits.T4IF=0;
	IEC0bits.T4IE=1;
	// Wait until end of NTSC view.
	while(!drawing);
	while(drawing);
	T4CONSET=0x8000; // Start timer 4.
	
	// Initializations for music/sound.
	g_qvalue=160; // Q: 1/4=90
	g_lvalue=20;   // L: 1/8
	g_tones=(int*)&(g_keys[49]); // C major
	g_musicstart=g_musicend=g_musicwait=g_soundstart=g_soundend=g_soundwait=g_soundrepeat=0;
}

void musicSetL(){
	// Set length of a character.
	// Syntax: L:n/m, where n and m are numbers.
	int n,m;
	n=musicGetNum();
	g_mspos++;
	m=musicGetNum();
	g_lvalue=g_qvalue*n/m;
}

void musicSetQ(){
	int i;
	// Syntax: Q:1/4=n, where n is number.
	// Skip "1/4="
	for(i=0;g_mstr[g_mspos+i]!='=';i++);
	g_mspos+=i+1;
	i=musicGetNum();
	if      (i<48)  { g_qvalue=320; /* 1/4=45  */ }
	else if (i<53)  { g_qvalue=288; /* 1/4=50  */ }
	else if (i<60)  { g_qvalue=256; /* 1/4=56  */ }
	else if (i<70)  { g_qvalue=224; /* 1/4=64  */ }
	else if (i<83)  { g_qvalue=192; /* 1/4=75  */ }
	else if (i<102) { g_qvalue=160; /* 1/4=90  */ }
	else if (i<132) { g_qvalue=128; /* 1/4=113 */ }
	else if (i<188) { g_qvalue=96;  /* 1/4=150 */ }
	else            { g_qvalue=64;  /* 1/4=225 */ }
	g_lvalue=g_qvalue>>3;
}

void musicSetK(){
	// Syntax: K:xxx
	if (!strncmp((char*)&(g_mstr[g_mspos]),"A#m",3)) {
			g_mspos+=3;
			g_tones=(int*)&(g_keys[0]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"D#m",3)) {
			g_mspos+=3;
			g_tones=(int*)&(g_keys[7]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"G#m",3)) {
			g_mspos+=3;
			g_tones=(int*)&(g_keys[14]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"C#m",3)) {
			g_mspos+=3;
			g_tones=(int*)&(g_keys[21]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"F#m",3)) {
			g_mspos+=3;
			g_tones=(int*)&(g_keys[28]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"Bbm",3)) {
			g_mspos+=3;
			g_tones=(int*)&(g_keys[84]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"Ebm",3)) {
			g_mspos+=3;
			g_tones=(int*)&(g_keys[91]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"Abm",3)) {
			g_mspos+=3;
			g_tones=(int*)&(g_keys[98]);
			return;
	}
	if (!strncmp((char*)&(g_mstr[g_mspos]),"C#",2)) {
			g_mspos+=2;
			g_tones=(int*)&(g_keys[0]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"F#",2)) {
			g_mspos+=2;
			g_tones=(int*)&(g_keys[7]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"Bm",2)) {
			g_mspos+=2;
			g_tones=(int*)&(g_keys[35]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"Em",2)) {
			g_mspos+=2;
			g_tones=(int*)&(g_keys[42]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"Am",2)) {
			g_mspos+=2;
			g_tones=(int*)&(g_keys[49]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"Dm",2)) {
			g_mspos+=2;
			g_tones=(int*)&(g_keys[56]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"Gm",2) || !strncmp((char*)&(g_mstr[g_mspos]),"Bb",2)) {
			g_mspos+=2;
			g_tones=(int*)&(g_keys[63]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"Cm",2) || !strncmp((char*)&(g_mstr[g_mspos]),"Eb",2)) {
			g_mspos+=2;
			g_tones=(int*)&(g_keys[70]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"Fm",2) || !strncmp((char*)&(g_mstr[g_mspos]),"Ab",2)) {
			g_mspos+=2;
			g_tones=(int*)&(g_keys[77]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"Db",2)) {
			g_mspos+=2;
			g_tones=(int*)&(g_keys[84]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"Gb",2)) {
			g_mspos+=2;
			g_tones=(int*)&(g_keys[91]);
			return;
	} else if (!strncmp((char*)&(g_mstr[g_mspos]),"Cb",2)) {
			g_mspos+=2;
			g_tones=(int*)&(g_keys[98]);
			return;
	}
	switch(g_mstr[g_mspos]){
		case 'B':
			g_mspos++;
			g_tones=(int*)&(g_keys[14]);
			return;
		case 'E':
			g_mspos++;
			g_tones=(int*)&(g_keys[21]);
			return;
		case 'A':
			g_mspos++;
			g_tones=(int*)&(g_keys[28]);
			return;
		case 'D':
			g_mspos++;
			g_tones=(int*)&(g_keys[35]);
			return;
		case 'G':
			g_mspos++;
			g_tones=(int*)&(g_keys[42]);
			return;
		case 'C':
			g_mspos++;
			g_tones=(int*)&(g_keys[49]);
			return;
		case 'F':
			g_mspos++;
			g_tones=(int*)&(g_keys[56]);
			return;
		default:
			err_music(g_mstr);
			break;
	}
}
void musicSetM(){
	// Currently do nothing
	musicGetNum();
	musicGetNum();
}

void set_sound(unsigned long* data){
	int sound;
	int len;
	int pos;
	int datalen;
	IEC0bits.T4IE=0; // Stop interruption, first.
	// Initialize
	g_soundrepeat=g_soundstart=g_soundend=0;
	pos=0;
	do {
		while(data[1]!=0x00000020) data++; // Seek DATA statement
		datalen=(data[0]&0x00007FFF)-1;    // Use bgezal statement containing data length.
		data+=2;
		while(0<datalen){
			datalen--;
			len=data[0]>>16;
			sound=data[0]&0x0000FFFF;
			data++;
			if (len) {
				// Shift tone if graphic is used
				if (g_use_graphic) {
					// MUL_15 instead of MUL_16 for CPU clock.
					// sound=sound*15/16
					sound-=(sound+7)>>4;
				}
				g_sound[pos]=sound-1;
				g_soundlen[pos]=len;
				pos++;
				if (32<pos) {
					err_music("Sound data too long.");
					return;
				}
			} else {
				g_soundrepeat=sound;
				break;
			}
		}
	} while(len);
	g_soundend=pos;
	g_soundwait=g_soundlen[0];
	IEC0bits.T4IE=1; // Restart interrupt.
}

void set_music(char* str){
	char b;
	unsigned long tone,tonenatural;
	int len;
	g_mstr=str;
	g_mspos=0;
	while(0<(b=g_mstr[g_mspos])){
		if (g_mstr[g_mspos+1]==':') {
			// Set property
			g_mspos+=2;
			switch(b){
				case 'L':
					musicSetL();
					break;
				case 'Q':
					musicSetQ();
					break;
				case 'K':
					musicSetK();
					break;
				case 'M':
					musicSetM();
					break;
				default:
					err_music(str);
					break;
			}	
		} else if ('A'<=b && b<='G' || 'a'<=b && b<='g' || b=='z') {
			g_mspos++;
			if (b=='z') {
				tone=0;
			} else if (b<='G') {
				tone=g_tones[b-'A'];
				tonenatural=g_keys[b-'A'+49];
			} else {
				tone=g_tones[b-'a']>>1;
				tonenatural=g_keys[b-'a'+49]>>1;
			}
			// Check "'"s
			while(g_mstr[g_mspos]=='\''){
				g_mspos++;
				tone>>=1;
			}
			// Check ","s
			while(g_mstr[g_mspos]==','){
				g_mspos++;
				tone<<=1;
				tonenatural<<=1;
			}
			// Check "^","=","_"
			switch(g_mstr[g_mspos]){
				case '^':
					g_mspos++;
					tone=toneSharp(tone);
					break;
				case '_':
					g_mspos++;
					tone=toneFlat(tone);
					break;
				case '=':
					g_mspos++;
					tone=tonenatural;
					break;
				default:
					break;
			}
			// Check number for length
			b=g_mstr[g_mspos];
			if ('0'<=b && b<='9') {
				len=g_lvalue*musicGetNum();
			} else {
				len=g_lvalue;
			}
			if (g_mstr[g_mspos]=='/') {
				g_mspos++;
				len=len/musicGetNum();
			}
			// Shift tone if graphic is used
			if (g_use_graphic) {
				// MUL_15 instead of MUL_16 for CPU clock.
				// tone=tone*15/16
				tone-=(tone+7)>>4;
			}
			// Update music value array
			IEC0bits.T4IE=0; // Stop interruption, first.
			if (g_musicstart==g_musicend) {
				g_musicwait=len;
			}
			g_music[g_musicend]=(tone-1)&0x0000FFFF;
			g_musiclen[g_musicend]=len;
			g_musicend++;
			g_musicend&=31;
			IEC0bits.T4IE=1; // Restart interruption.
		} else {
			err_music(str);
		}
		// Go to next character
		while(0<g_mstr[g_mspos] && g_mstr[g_mspos]<=0x20 || g_mstr[g_mspos]=='|') g_mspos++;
	}
}
/*
   This file is provided under the LGPL license ver 2.1.
   Written by Katsumi.
   http://hp.vector.co.jp/authors/VA016157/
   kmorimatsu@users.sourceforge.jp
*/

#include "compiler.h"

/*
Operators: (upper ones have higher priority
()
* / %
+ -
<< >>
< <= > >=
= !=
XOR
AND
OR
*/


const unsigned char g_priority[]={
	0, // OP_VOID
	1, // OP_OR
	2, // OP_AND
	3, // OP_XOR
	4,4, // OP_EQ, OP_NEQ
	5,5,5,5, // OP_LT, OP_LTE, OP_MT, OP_MTE
	6,6, // OP_SHL, OP_SHR
	7,7, // OP_ADD, OP_SUB
	8,8,8 // OP_MUL, OP_DIV, OP_REM
};

enum operator g_last_op;

char* get_operator(void){
	char b1,b2,b3;
	next_position();
	b1=g_source[g_srcpos];
	b2=g_source[g_srcpos+1];
	b3=g_source[g_srcpos+2];
	switch(b1){
		case '%': g_last_op=OP_REM; break;
		case '/': g_last_op=OP_DIV; break;
		case '*': g_last_op=OP_MUL; break;
		case '-': g_last_op=OP_SUB; break;
		case '+': g_last_op=OP_ADD; break;
		case '>':
			if (b2=='>') {
				g_srcpos++;
				g_last_op=OP_SHR;
			} else if (b2=='=') {
				g_srcpos++;
				g_last_op=OP_MTE;
			} else {
				g_last_op=OP_MT;
			}
			break;
		case '<':
			if (b2=='<') {
				g_srcpos++;
				g_last_op=OP_SHL;
			} else if (b2=='=') {
				g_srcpos++;
				g_last_op=OP_LTE;
			} else {
				g_last_op=OP_LT;
			}
			break;
		case '!':
			if (b2!='=') return ERR_SYNTAX;
			g_srcpos++;
			g_last_op=OP_NEQ;
			break;
		case '=':
			if (b2=='=') g_srcpos++;
			g_last_op=OP_EQ;
			break;
		case 'X':
			if (b2!='O') return ERR_SYNTAX;
			if (b3!='R') return ERR_SYNTAX;
			g_srcpos++;
			g_srcpos++;
			g_last_op=OP_XOR;
			break;
		case 'O':
			if (b2!='R') return ERR_SYNTAX;
			g_srcpos++;
			g_last_op=OP_OR;
			break;
		case 'A':
			if (b2!='N') return ERR_SYNTAX;
			if (b3!='D') return ERR_SYNTAX;
			g_srcpos++;
			g_srcpos++;
			g_last_op=OP_AND;
			break;
		default:
			return ERR_SYNTAX;
	}
	g_srcpos++;
	return 0;
}

char* get_floatOperator(void){
	char* err;
	int spos;
	next_position();
	spos=g_srcpos;
	err=get_operator();
	if (err) return err;
	switch(g_last_op){
		// Following operators cannot be used for float values.
		case OP_XOR:
		case OP_REM:
		case OP_SHR:
		case OP_SHL:
			g_srcpos=spos;
			return ERR_SYNTAX;
		default:
			return 0;
	}
}

char* calculation(enum operator op){
	// $v0 = $v1 <op> $v0;
	switch(op){
		case OP_OR:
			check_obj_space(1);
			g_object[g_objpos++]=0x00621025; // or          v0,v1,v0
			break;
		case OP_AND:
			check_obj_space(1);
			g_object[g_objpos++]=0x00621024; // and         v0,v1,v0
			break;
		case OP_XOR:
			check_obj_space(1);
			g_object[g_objpos++]=0x00621026; // xor         v0,v1,v0
			break;
		case OP_EQ:
			check_obj_space(2);
			g_object[g_objpos++]=0x00621026; // xor         v0,v1,v0
			g_object[g_objpos++]=0x2C420001; // sltiu       v0,v0,1
			break;
		case OP_NEQ:
			check_obj_space(2);
			g_object[g_objpos++]=0x00621026; // xor         v0,v1,v0
			g_object[g_objpos++]=0x0002102B; // sltu        v0,zero,v0
			break;
		case OP_LT:
			check_obj_space(1);
			g_object[g_objpos++]=0x0062102A; // slt         v0,v1,v0
			break;
		case OP_LTE:
			check_obj_space(2);
			g_object[g_objpos++]=0x0043102A; // slt         v0,v0,v1
			g_object[g_objpos++]=0x38420001; // xori        v0,v0,0x1
			break;
		case OP_MT:
			check_obj_space(1);
			g_object[g_objpos++]=0x0043102A; // slt         v0,v0,v1
			break;
		case OP_MTE:
			check_obj_space(2);
			g_object[g_objpos++]=0x0062102A; // slt         v0,v1,v0
			g_object[g_objpos++]=0x38420001; // xori        v0,v0,0x1
			break;
		case OP_SHR:
			check_obj_space(1);
			g_object[g_objpos++]=0x00431006; // srlv        v0,v1,v0
			break;
		case OP_SHL:
			check_obj_space(1);
			g_object[g_objpos++]=0x00431004; // sllv        v0,v1,v0
			break;
		case OP_ADD:
			check_obj_space(1);
			g_object[g_objpos++]=0x00621021; // addu        v0,v1,v0
			break;
		case OP_SUB:
			check_obj_space(1);
			g_object[g_objpos++]=0x00621023; // subu        v0,v1,v0
			break;
		case OP_MUL:
			check_obj_space(1);
			g_object[g_objpos++]=0x70621002; // mul         v0,v1,v0
			break;
		case OP_DIV:
			// Note that intterupt functions do not use mflo and mfhi.
			// Probably using div does not cause delay of interrupt.
			check_obj_space(5);
			g_object[g_objpos++]=0x14400003;                                        // bne         v0,zero,label
			g_object[g_objpos++]=0x0062001A;                                        // div         v1,v0
			call_lib_code(LIB_DIV0); // 2 words
 			                                                                        // label:
			g_object[g_objpos++]=0x00001012;                                        // mflo        v0
			break;
		case OP_REM:
			check_obj_space(5);
			g_object[g_objpos++]=0x14400003;                                        // bne         v0,zero,label
			g_object[g_objpos++]=0x0062001A;                                        // div         v1,v0
			call_lib_code(LIB_DIV0); // 2 words
 			                                                                        // label:
			g_object[g_objpos++]=0x00001010;                                        // mfhi        v0
			break;
		default:
			return ERR_SYNTAX;
	}
	return 0;
}

char* calculation_float(enum operator op){
	// $v0 = $a0 <op> $v0;
	// All the calculations will be done in library code, lib_float function (see below).
	call_lib_code(LIB_FLOAT | op);
	return 0;
}

int lib_float(int ia0,int iv0, enum operator a1){
	// This function was called from _call_library().
	// Variable types must be all int.
	// Casting cannot be used.
	// Instead, by using pointer, put as int value, get as float value, 
	// calculate, put as float value, then get as int value for returning.
	volatile float a0,v0;
	((int*)(&a0))[0]=ia0;
	((int*)(&v0))[0]=iv0;
	switch(a1){
		case OP_EQ:
			v0= a0==v0?1:0;
			break;
		case OP_NEQ:
			v0= a0!=v0?1:0;
			break;
		case OP_LT:
			v0= a0<v0?1:0;
			break;
		case OP_LTE:
			v0= a0<=v0?1:0;
			break;
		case OP_MT:
			v0= a0>v0?1:0;
			break;
		case OP_MTE:
			v0= a0>=v0?1:0;
			break;
		case OP_ADD:
			v0= a0+v0;
			break;
		case OP_SUB:
			v0= a0-v0;
			break;
		case OP_MUL:
			v0= a0*v0;
			break;
		case OP_DIV:
			if (v0==0) err_div_zero();
			v0= a0/v0;
			break;
		case OP_OR:
			v0= a0||v0?1:0;
			break;
		case OP_AND:
			v0= a0&&v0?1:0;
			break;
		default:
			err_unknown();
			return 0;
	}
	return ((int*)(&v0))[0];
}; /*
   This file is provided under the LGPL license ver 2.1.
   Written by K.Tanaka & Katsumi
   http://www.ze.em-net.ne.jp/~kenken/index.html
   http://hp.vector.co.jp/authors/VA016157/
*/

#include <xc.h>
#include "api.h"
#include "compiler.h"
#include "editor.h"
#include "main.h"

char* printdec(int num){
	char str[11];
	int i;
	if (num<0) {
		printchar('-');
		num=0-num;
	}
	for(i=10;0<i;i--){
		if (num==0 && i<10) break;
		str[i]='0'+rem10_32(num);
		num=div10_32(num);
	}
	for(i++;i<11;i++) {
		printchar(str[i]);
	}
}

int runbasic(char *appname,int test){
// BASICソースのコンパイルと実行
// appname 実行するBASICソースファイル
// test 0:コンパイルと実行、0以外:コンパイルのみで終了
//
// 戻り値
//　　0:正常終了
//　　-1:ファイルエラー
//　　-2:リンクエラー
//　　1以上:コンパイルエラーの発生行（行番号ではなくファイル上の何行目か）
	int i;
	char* buff;
	char* err;

	// Set grobal pointer
	g_gp=get_gp();
	// Set source positions
	buff=(char*)&(RAM[RAMSIZE-512]);
	g_source=(char*)(&buff[0]);
	g_srcpos=0;
	// Set object positions
	g_object=(int*)(&RAM[0]);
	g_objpos=0;
	g_objmax=g_object+(RAMSIZE-512)/4; // Buffer area excluded.
	// Clear object area
	for(i=0;i<RAMSIZE/4;i++) g_object[i]=0x00000000;
	// Initialize SD card file system
	err=init_file(buff,appname);
	if (err) {
		setcursorcolor(COLOR_ERRORTEXT);
		printstr("Can't Open ");
		printstr(appname);
		printchar('\n');
		return -1;
	}

	// Initialize parameters
	g_pcg_font=0;
	g_use_graphic=0;
	g_graphic_area=0;
	clearscreen();
	setcursor(0,0,7);
	g_long_name_var_num=0;
	cmpdata_init();

	printstr("BASIC "BASVER"\n");
	wait60thsec(15);
	// Initialize music
	init_music();

	printstr("Compiling...");

	// Compile the file
	err=compile_file();
	close_file();
	if (err) {
		// Compile error
		printstr(err);
		printstr("\nAround: '");
		for(i=0;i<5;i++){
			printchar(g_source[g_srcpos-2+i]);
		}
		printstr("' in line ");
		printdec(g_line);
		printstr("\n");
		for(i=g_srcpos;0x20<=g_source[i];i++);
		g_source[i]=0x00;
		for(i=g_srcpos;0x20<=g_source[i];i--);
		printstr(g_source+i);
		return g_fileline;
	}

	// Link
	err=link();
	if (err) {
		// Link error
		printstr(err);
		printstr(resolve_label(g_label));
		return -2;
	}

	// All done
	printstr("done\n");
	if(test) return 0; //コンパイルのみの場合
	wait60thsec(15);

	// Initialize the other parameters
	// Random seed
	g_rnd_seed=0x92D68CA2; //2463534242
	// Clear variables
	for(i=0;i<ALLOC_BLOCK_NUM;i++){
		g_var_mem[i]=0;
		g_var_size[i]=0;
	}
	// Clear key input buffer
	for(i=0;i<256;i++){
		ps2keystatus[i]=0;
	}
	// Reset data/read.
	reset_dataread();
	// Initialize file system
	lib_file(FUNC_FINIT,0,0,0);

	// Assign memory
	set_free_area((void*)(g_object+g_objpos),(void*)(&RAM[RAMSIZE]));

	// Execute program
	// Start program from the beginning of RAM.
	// Work area (used for A-Z values) is next to the object code area.
	start_program((void*)(&(RAM[0])),(void*)(&g_var_mem[0]));
	printstr("\nOK\n");
	// Cool down
	set_graphmode(0);
	g_use_graphic=0;
	lib_file(FUNC_FINIT,0,0,0);

	return 0;
}
/*
   This file is provided under the LGPL license ver 2.1.
   Written by Katsumi.
   http://hp.vector.co.jp/authors/VA016157/
   kmorimatsu@users.sourceforge.jp
*/

#include "api.h"
#include "compiler.h"

char* rem_statement(){
	if (g_source[g_srcpos-4]<0x20) {
		// This line contains only "REM" statement
		// Delete $s6-setting command if exists.
		if ((g_object[g_objpos-1]&0xffff0000)==0x34160000) g_objpos--;
	}
	while(0x20<=g_source[g_srcpos]){
		g_srcpos++;
	}
	return 0;
}

char* sound_statement(){
	char *err;
	err=get_label();
	if (err) return err;
	if (g_label) {
		// Label/number is constant.
		// Linker will change following codes later.
		// Note that 0x0814xxxx and 0x0815xxxx are specific codes for these.
		check_obj_space(2);
		g_object[g_objpos++]=0x08140000|((g_label>>16)&0x0000FFFF); // lui   v0,xxxx
		g_object[g_objpos++]=0x08150000|(g_label&0x0000FFFF);       // ori v0,v0,xxxx
	} else {
		// Label/number will be dynamically set when executing code.
		err=get_value();
		if (err) return err;
		call_lib_code(LIB_LABEL);
	}
	call_lib_code(LIB_SOUND);
	return 0;
}
char* music_statement(){
	char *err;
	err=get_string();
	call_lib_code(LIB_MUSIC);
	return 0;
}

char* exec_statement(){
	char *err;
	char b1;
	int i,prevpos;
	b1=g_source[g_srcpos];
	while('0'<=b1 && b1<='9' || b1=='-' || b1=='$'){
		prevpos=g_objpos;
		g_valueisconst=1;
		err=get_simple_value();
		if (!g_valueisconst) err=ERR_SYNTAX;
		if (err) return err;
		check_obj_space(1);
		g_objpos=prevpos;
		g_object[g_objpos++]=g_intconst;
		next_position();
		b1=g_source[g_srcpos];
		if (b1!=',') break;
		g_srcpos++;
		next_position();
		b1=g_source[g_srcpos];
		if (b1==0x0d || b1==0x0a) {
			// Multiline DATA/EXEC statement
			g_line++;
			g_fileline++;
			if (b1==0x0D && g_source[g_srcpos+1]==0x0A) g_srcpos++;
			g_srcpos++;
			// Maintain at least 256 characters in cache.
			if (256<=g_srcpos) read_file(256);
			next_position();
			b1=g_source[g_srcpos];
		}			
	}
	return 0;
}

char* cdata_statement(){
	// 0x00000020, 0x00000021, 0x00000022, and 0x00000023 (add/addu/sub/subu zero,zero,zero) 
	// are the sign of data region
	int beginpos,prevpos;
	char* err;
	char b1;
	char* cpy;
	int shift=0;
	int i=0;
	beginpos=g_objpos;
	check_obj_space(2);
	g_object[g_objpos++]=0x04110000; // bgezal      zero,xxxx
	g_object[g_objpos++]=0x00000020; // add         zero,zero,zero
	next_position();
	b1=g_source[g_srcpos];
	while('0'<=b1 && b1<='9' || b1=='-' || b1=='$'){
		prevpos=g_objpos;
		g_valueisconst=1;
		err=get_simple_value();
		if (!g_valueisconst) err=ERR_SYNTAX;
		if (g_intconst<0x00 || 0xff<g_intconst) err=ERR_SYNTAX;
		if (err) return err;
		g_objpos=prevpos;
		i|=g_intconst<<shift;
		shift+=8;
		if (32<=shift) {
			check_obj_space(1);
			g_object[g_objpos++]=i;
			shift=0;
			i=0;
		}
		next_position();
		b1=g_source[g_srcpos];
		if (b1!=',') break;
		g_srcpos++;
		next_position();
		b1=g_source[g_srcpos];
		if (b1==0x0d || b1==0x0a) {
			// Multiline CDATA statement
			g_line++;
			g_fileline++;
			if (b1==0x0D && g_source[g_srcpos+1]==0x0A) g_srcpos++;
			g_srcpos++;
			// Maintain at least 256 characters in cache.
			if (256<=g_srcpos) read_file(256);
			next_position();
			b1=g_source[g_srcpos];
		}			
	}
	// Write the last 1-3 bytes and shift data if total # is not multipes of 4.
	if (0<shift) {
		// Convert shift value from bit-shift to data byte-shift.
		shift=4-shift/8;
		check_obj_space(1);
		g_object[g_objpos++]=i;
		for(cpy=(char*)&g_object[g_objpos]-1;(char*)&g_object[beginpos+2]<cpy;cpy--){
			cpy[0]=cpy[0-shift];
		}
	}
	// Determine the size of data
	i=g_objpos-beginpos-1;
	g_object[beginpos]  =0x04110000|i;     // bgezal zero,xxxx
	g_object[beginpos+1]=0x00000020|shift; // add         zero,zero,zero
	return 0;
}

char* data_statement(){
	// 0x00000020, 0x00000021, 0x00000022, and 0x00000023 (add/addu/sub/subu zero,zero,zero) 
	// are the sign of data region
	int i,prevpos;
	char* err;
	while(1){
		prevpos=g_objpos;
		check_obj_space(2);
		g_object[g_objpos++]=0x04110000; // bgezal      zero,xxxx
		g_object[g_objpos++]=0x00000020; // add         zero,zero,zero
		next_position();
		if (g_source[g_srcpos]=='"') {
			// Constant string
			// Store pointer to string. This is 3 words bellow of current position
			g_object[g_objpos]=(int)(&g_object[g_objpos+3]);
			g_objpos++;
			g_object[prevpos]=0x04110002; // bgezal zero,xxxx
			err=simple_string();
			if (err) return err;
			next_position();
			if (g_source[g_srcpos]==',') {
				g_srcpos++;
				continue;
			}
			return 0;
		}
		err=exec_statement();
		if (err) return err;
		// Determine the size of data
		i=g_objpos-prevpos-1;
		g_object[prevpos]=0x04110000|i; // bgezal zero,xxxx
		if (g_source[g_srcpos]=='"') {
			// Constant string
			continue;
		}
		return 0;
	}
}

char* clear_statement(){
	call_lib_code(LIB_CLEAR);
	return 0;
}

char* poke_statement(){
	char* err;
	err=get_value();
	if (err) return err;
	if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
	g_srcpos++;
	check_obj_space(2);
	g_object[g_objpos++]=0x27BDFFFC; // addiu       sp,sp,-4
	g_object[g_objpos++]=0xAFA20004; // sw          v0,4(sp)
	err=get_value();
	if (err) return err;
	check_obj_space(3);
	g_object[g_objpos++]=0x8FA30004; // lw          v1,4(sp)
	g_object[g_objpos++]=0x27BD0004; // addiu       sp,sp,4
	g_object[g_objpos++]=0xA0620000; // sb          v0,0(v1)
	return 0;
}

char* dim_statement(){
	char* err;
	char b1;
	int i;
	int spos;
	int stack;
	while(1){
		stack=0;
		next_position();
		i=get_var_number();
		if (i<0) return ERR_SYNTAX;
		if (g_source[g_srcpos]=='#') g_srcpos++;
		next_position();
		if (g_source[g_srcpos]!='(') return ERR_SYNTAX;
		check_obj_space(1);
		spos=g_objpos++;           // addiu       sp,sp,xxxx
		do {
			g_srcpos++;
			err=get_value();
			if (err) return err;
			stack+=4;
			check_obj_space(1);
			g_object[g_objpos++]=0xAFA20000|stack; // sw          v0,8(sp)
		} while (g_source[g_srcpos]==',');
		if (g_source[g_srcpos]!=')') return ERR_SYNTAX;
		g_srcpos++;
		check_obj_space(3);
		g_object[g_objpos++]=0x24040000|(i);       // addiu       a0,zero,xx
		g_object[g_objpos++]=0x24050000|(stack/4); // addiu       a1,zero,xxxx
		g_object[g_objpos++]=0x03A01025;           // or          v0,sp,zero
		call_lib_code(LIB_DIM);
		// Stack -/+
		check_obj_space(1);
		g_object[g_objpos++]=0x27BD0000|stack;     // addiu       sp,sp,xxxx
		stack=(0-stack)&0x0000FFFF;
		g_object[spos]=0x27BD0000|stack;           // addiu       sp,sp,xxxx
		next_position();
		if (g_source[g_srcpos]!=',') break;
		g_srcpos++;
	}
	return 0;
}

char* label_statement(){
	char* err;
	char b1;
	b1=g_source[g_srcpos];
	if (b1<'A' || 'Z'<b1) return ERR_SYNTAX; // Number is not allowed here.
	err=get_label();
	if (err) return err;
	// Check existing label with the same name here.
	if (search_label(g_label)) {
		// Error: duplicate labels
		printstr("Label ");
		printstr(resolve_label(g_label));
		return ERR_MULTIPLE_LABEL;
	}
	check_obj_space(2);
	g_object[g_objpos++]=0x3C160000|((g_label>>16)&0x0000FFFF); //lui s6,yyyy;
	g_object[g_objpos++]=0x36D60000|(g_label&0x0000FFFF);       //ori s6,s6,zzzz;
	return 0;
}

char* restore_statement(){
	char* err;
	err=get_label();
	if (err) return err;
	if (g_label) {
		// Constant label/number
		// Use 32 bit mode also for values<65536
		// This code will be replaced to code for v0 for pointer in linker.
		check_obj_space(2);
		g_object[g_objpos++]=0x3C020000|(g_label>>16);        // lui         v0,xxxx
		g_object[g_objpos++]=0x34420000|(g_label&0x0000FFFF); // ori         v0,v0,xxxx
	} else {
		// Dynamic number
		err=get_value();
		if (err) return err;
	}
	call_lib_code(LIB_RESTORE);
	return 0;
}

char* gosub_statement_sub(){
	char* err;
	err=get_label();
	if (err) return err;
	if (g_label) {
		// Label/number is constant.
		// Linker will change following codes later.
		// Note that 0x0812xxxx and 0x0813xxxx are specific codes for these.
		check_obj_space(6);
		g_object[g_objpos++]=0x04130003;                            // bgezall     zero,label1
		g_object[g_objpos++]=0x27BDFFFC;                            // addiu       sp,sp,-4
		g_object[g_objpos++]=0x10000003;                            // beq         zero,zero,label2
		g_object[g_objpos++]=0x08120000|((g_label>>16)&0x0000FFFF); // nop         
		                                                            // label1:
		g_object[g_objpos++]=0x08130000|(g_label&0x0000FFFF);       // j           xxxx
		g_object[g_objpos++]=0xAFBF0004;                            // sw          ra,4(sp)
		                                                            // label2:
	} else {
		// Label/number will be dynamically set when executing code.
		err=get_value();
		if (err) return err;
		call_lib_code(LIB_LABEL);
		check_obj_space(6);
		g_object[g_objpos++]=0x04130003; // bgezall     zero,label1
		g_object[g_objpos++]=0x27BDFFFC; // addiu       sp,sp,-4
		g_object[g_objpos++]=0x10000003; // beq         zero,zero,label2
		g_object[g_objpos++]=0x00000000; // nop         
		                                 // label1:
		g_object[g_objpos++]=0x00400008; // jr          v0
		g_object[g_objpos++]=0xAFBF0004; // sw          ra,4(sp)
		                                 // label2:
	}
	return 0;
}

char* gosub_statement(){
	char* err;
	int opos,spos,stack;
	opos=g_objpos;
	spos=g_srcpos;
	err=gosub_statement_sub();
	if (err) return err;
	next_position();
	// If there is no 2nd argument, return.
	if (g_source[g_srcpos]!=',') return 0;

	// There is (at least) 2nd argument.
	// Rewind object and construct argument-creating routine.
	g_objpos=opos;
	stack=4;
	g_object[g_objpos++]=0x27BD0000;           // addiu       sp,sp,-xx
	do {
		g_srcpos++;
		stack+=4;
		err=get_stringFloatOrValue();
		if (err) return err;
		check_obj_space(1);
		g_object[g_objpos++]=0xAFA20000|stack; // sw          v0,xx(sp)
		next_position();
	} while(g_source[g_srcpos]==',');
	check_obj_space(2);
	g_object[g_objpos++]=0xAFB50004;           // sw          s5,4(sp)
	g_object[g_objpos++]=0x03A0A821;           // addu        s5,sp,zero
	g_object[opos]|=((0-stack)&0xFFFF);        // addiu       sp,sp,-xx (See above)
	// Rewind source and construct GOSUB routine again.
	opos=spos;
	spos=g_srcpos;
	g_srcpos=opos;
	err=gosub_statement_sub();
	if (err) return err;
	// Remove stack
	check_obj_space(2);
	g_object[g_objpos++]=0x8FB50004;           // lw          s5,4(sp)
	g_object[g_objpos++]=0x27BD0000|stack;     // addiu       sp,sp,xx
	// All done, go back to wright source position
	g_srcpos=spos;
	return 0;
}

char* return_statement(){
	char* err;
	char b1;
	next_position();
	b1=g_source[g_srcpos];
	if (0x20<b1 && b1!=':') {
		// There is a return value.
		err=get_stringFloatOrValue();
		if (err) return err;
	}
	check_obj_space(3);
	g_object[g_objpos++]=0x8FA30004; // lw          v1,4(sp)
	g_object[g_objpos++]=0x00600008; // jr          v1
	g_object[g_objpos++]=0x27BD0004; // addiu       sp,sp,4
	return 0;
}

char* goto_statement(){
	char* err;
	err=get_label();
	if (err) return err;
	if (g_label) {
		// Label/number is constant.
		// Linker will change following codes later.
		// Note that 0x0810xxxx and 0x0811xxxx are specific codes for these.
		check_obj_space(2);
		g_object[g_objpos++]=0x08100000|((g_label>>16)&0x0000FFFF); // j xxxx
		g_object[g_objpos++]=0x08110000|(g_label&0x0000FFFF);       // nop
	} else {
		// Label/number will be dynamically set when executing code.
		err=get_value();
		if (err) return err;
		call_lib_code(LIB_LABEL);
		check_obj_space(2);
		g_object[g_objpos++]=0x00400008; // jr          v0
		g_object[g_objpos++]=0x00000000; // nop
	}
	return 0;
}

char* if_statement(){
	char* err;
	int prevpos,bpos;
	// Get value.
	err=get_floatOrValue();
	if (err) return err;
	// Check "THEN"
	if (!nextCodeIs("THEN")) return ERR_SYNTAX;
	// Check if statement follows after THEN statement
	next_position();
	if (nextCodeIs("REM")) {
		// If REM statement follows, skip comment words.
		rem_statement();
	}
	if (g_source[g_srcpos]<0x20) {
		// End of line.
		// Use IF-THEN-ENDIF mode (multiple line mode)
		check_obj_space(3);
		g_object[g_objpos++]=0x30000000; // nop (see linker)
		g_object[g_objpos++]=0x10400000; // beq         v0,zero,xxxx
		g_object[g_objpos++]=0x30000000; // nop (see linker)
		return 0;
	}
	// One line mode
	// If $v0=0 then skip.
	bpos=g_objpos;
	check_obj_space(2);
	g_object[g_objpos++]=0x10400000; // beq         v0,zero,xxxx
	g_object[g_objpos++]=0x00000000; // nop
	prevpos=g_srcpos;
	if (statement()) {
		// May be label
		g_srcpos=prevpos;
		err=goto_statement();
		if (err) return err;
	} else {
		// Must be statement(s)
		while(1) {
			if (g_source[g_srcpos]!=':') break;
			g_srcpos++;
			err=statement();
			if (err) return err;
		}
	}
	// Check if "ELSE" exists.
	if (!nextCodeIs("ELSE ")) {
		// "ELSE" not found. This is the end of "IF" statement.
		// Previous branch command must jump to this position.
		g_object[bpos]=0x10400000|(g_objpos-bpos-1); // beq         v0,zero,xxxx	
		return 0;
	}
	// Skip after ELSE if required.
	check_obj_space(2);
	g_object[g_objpos++]=0x10000000; // beq         zero,zero,xxxx
	g_object[g_objpos++]=0x00000000; // nop
	// Previous branch command must jump to this position.
	g_object[bpos]=0x10400000|(g_objpos-bpos-1); // beq         v0,zero,xxxx	
	bpos=g_objpos-2;
	// Next statement is either label or general statement
	prevpos=g_srcpos;
	if (statement()) {
		// May be label
		g_srcpos=prevpos;
		err=goto_statement();
		if (err) return err;
	} else {
		// Must be statement(s)
		while(1) {
			if (g_source[g_srcpos]!=':') break;
			g_srcpos++;
			err=statement();
			if (err) return err;
		}
	}
	// Previous branch command must jump to this position.
	g_object[bpos]=0x10000000|(g_objpos-bpos-1); // beq         zero,zero,xxxx	
	return 0;
}

char* elseif_statement(void){
	// Multiple line mode
	char* err;
	g_object[g_objpos++]=0x08160100; // breakif (see linker)
	g_object[g_objpos++]=0x30008000; // nop (see linker)
	// Get value.
	err=get_floatOrValue();
	if (err) return err;
	// Check "THEN"
	if (!nextCodeIs("THEN")) return ERR_SYNTAX;
	// Check if statement follows after THEN statement
	if (nextCodeIs("REM")) {
		// If REM statement follows, skip comment words.
		rem_statement();
	}
	if (0x20<=g_source[g_srcpos]) return ERR_SYNTAX;
	// Statement didn't follow after THEM statement (that is correct).
	g_object[g_objpos++]=0x10400000; // beq         v0,zero,xxxx
	g_object[g_objpos++]=0x30000000; // nop (see linker)
	return 0;
	
}

char* else_statement(void){
	// Multiple line mode
	g_object[g_objpos++]=0x08160100; // breakif (see linker)
	g_object[g_objpos++]=0x30008000; // nop (see linker)
	g_object[g_objpos++]=0x30000000; // nop (see linker)
	// Check if statement follows after THEN statement
	if (nextCodeIs("REM")) {
		// If REM statement follows, skip comment words.
		rem_statement();
	}
	if (0x20<=g_source[g_srcpos]) return ERR_SYNTAX;
	// Statement didn't follow after THEM statement (that is correct).
	return 0;
}

char* endif_statement(void){
	// Multiple line mode
	g_object[g_objpos++]=0x30008000; // nop (see linker)
	g_object[g_objpos++]=0x30008000; // nop (see linker)
	// Check if statement follows after THEN statement
	if (nextCodeIs("REM")) {
		// If REM statement follows, skip comment words.
		rem_statement();
	}
	if (0x20<=g_source[g_srcpos]) return ERR_SYNTAX;
	// Statement didn't follow after THEM statement (that is correct).
	return 0;
}

char* end_statement(void){
	int i;
	i=(int)&g_end_addr;
	i-=g_gp;
	check_obj_space(3);
	g_object[g_objpos++]=0x8F820000|(i&0x0000FFFF);       // lw v0,xxxx(gp)
	g_object[g_objpos++]=0x00400008;                      // jr v0
	g_object[g_objpos++]=0x00000000;                      // nop
	return 0;
}

char* let_dim_sub(int i){
	char* err;
	g_srcpos++;
	err=get_value();
	if (err) return err;
	check_obj_space(4);
	g_object[g_objpos++]=0x00021080;              // sll v0,v0,0x2
	g_object[g_objpos++]=0x8FC30000|(i*4);        // lw    v1,xx(s8)
	g_object[g_objpos++]=0x00621821;              // addu  v1,v1,v0
	g_object[g_objpos++]=0xAFA30004;              // sw    v1,4(sp)
	while(g_source[g_srcpos]==','){
		g_srcpos++;
		err=get_value();
		if (err) return err;
		check_obj_space(4);
		g_object[g_objpos++]=0x00021080;          // sll v0,v0,0x2
		g_object[g_objpos++]=0x8FA30004;          // lw    v1,4(sp)
		g_object[g_objpos++]=0x8C630000;          // lw    v1,0(v1)
		g_object[g_objpos++]=0x00621821;          // addu  v1,v1,v0
		g_object[g_objpos++]=0xAFA30004;          // sw    v1,4(sp)
	}
	if (g_source[g_srcpos]!=')') return ERR_SYNTAX;
	g_srcpos++;
	return 0;
};

char* let_statement(){
	char* err;
	char b2,b3;
	int i;
	next_position();
	i=get_var_number();
	if (i<0) return ERR_SYNTAX;
	b2=g_source[g_srcpos];
	b3=g_source[g_srcpos+1];
	if (b2=='#' && b3=='(') {
		// Float dimension
		g_srcpos++;
		check_obj_space(1);
		g_object[g_objpos++]=0x27BDFFFC;              // addiu sp,sp,-4
		let_dim_sub(i);
		next_position();
		if (g_source[g_srcpos]!='=') return ERR_SYNTAX;
		g_srcpos++;
		err=get_float();
		if (err) return err;
		check_obj_space(3);
		g_object[g_objpos++]=0x8FA30004;              // lw    v1,4(sp)
		g_object[g_objpos++]=0x27BD0004;              // addiu sp,sp,4
		g_object[g_objpos++]=0xAC620000;              // sw    v0,0(v1)
		return 0;
	} else if (b2=='#') {
		// Float A-Z
		g_srcpos++;
		next_position();
		if (g_source[g_srcpos]!='=') return ERR_SYNTAX;
		g_srcpos++;
		err=get_float();
		if (err) return err;
		check_obj_space(1);
		g_object[g_objpos++]=0xAFC20000|(i*4);        // sw v0,xxx(s8)
		return 0;
	} else 	if (b2=='$') {
		// String
		g_srcpos++;
		next_position();
		if (g_source[g_srcpos]!='=') return ERR_SYNTAX;
		g_srcpos++;
		err=get_string();
		if (err) return err;
		check_obj_space(1);
		g_object[g_objpos++]=0x24040000|(i);          //addiu       a0,zero,xx
		call_lib_code(LIB_LETSTR);
		return 0;
	} else if (b2=='(') {
		// Dimension
		check_obj_space(1);
		g_object[g_objpos++]=0x27BDFFFC;              // addiu sp,sp,-4
		let_dim_sub(i);
		next_position();
		if (g_source[g_srcpos]!='=') return ERR_SYNTAX;
		g_srcpos++;
		err=get_value();
		if (err) return err;
		check_obj_space(3);
		g_object[g_objpos++]=0x8FA30004;              // lw    v1,4(sp)
		g_object[g_objpos++]=0x27BD0004;              // addiu sp,sp,4
		g_object[g_objpos++]=0xAC620000;              // sw    v0,0(v1)
		return 0;
	} else {
		// Integer A-Z
		next_position();
		if (g_source[g_srcpos]!='=') return ERR_SYNTAX;
		g_srcpos++;
		err=get_value();
		if (err) return err;
		check_obj_space(1);
		g_object[g_objpos++]=0xAFC20000|(i*4);        // sw v0,xxx(s8)
	}
	return 0;
}

char* print_statement(enum libs lib_printstr, enum libs lib_string){
	char* err;
	char b1;
	int i;
	int status=0;// 1:',' 2:';' 0:none
	while(1){
		next_position();
		if (endOfStatement()) break;
		if (!strncmp(g_source+g_srcpos,"ELSE "  ,5)) break;	
		err=get_stringFloatOrValue();
		if (err) return err;
		switch(g_lastvar){
			case VAR_INTEGER:
				// Use DEC$() function.
				call_lib_code(LIB_DEC);
				break;
			case VAR_FLOAT:
				// Use FLOAT$() function.
				check_obj_space(2);
				g_object[g_objpos++]=0x00022021; //addu        a0,zero,v0
				g_object[g_objpos++]=0x34020000; //ori         v0,zero,0x0000
				call_lib_code(LIB_SPRINTF);
				break;
			case VAR_STRING:
			default:
				break;
		}
		// Call printstr() function
		// First argument is the pointer to string
		call_lib_code(lib_printstr);
		next_position();
		b1=g_source[g_srcpos];
		if (b1==',') {
			status=1;
			g_srcpos++;
			// Call lib_string() function for comma (,)
			check_obj_space(1);
			g_object[g_objpos++]=0x34020001;                      // ori   v0,zero,1
			call_lib_code(lib_string);
		} else if (b1==';') {
			status=2;
			g_srcpos++;
		} else {
			status=0;
		}
	}
	if (status==0) {
		// Call lib_string() function for CR (\n)
		check_obj_space(1);
		g_object[g_objpos++]=0x34020000;                      // ori   v0,zero,0
		call_lib_code(lib_string);
	}
	return 0;
}

char* break_statement(){
	check_obj_space(2);
	g_object[g_objpos++]=0x08160000; // j           xxxx     (See link() function)
	g_object[g_objpos++]=0x00000000; // nop
	return 0;
}

char* continue_statement(){
	check_obj_space(2);
	g_object[g_objpos++]=0x08160008; // j           xxxx     (See link() function)
	g_object[g_objpos++]=0x00000000; // nop
	return 0;
}

char* for_statement(){
	char* err;
//	char b1;
	int i;
	int prepos=g_srcpos;
	// Initialization of variable
//	next_position();
//	b1=g_source[g_srcpos];
	i=get_var_number();
//	if (b1<'A' || 'Z'<b1) return ERR_SYNTAX;
	if (i<0) return ERR_SYNTAX;
	g_srcpos=prepos;
	err=let_statement();
	if (err) return err;
	// Check if "TO" exists
	if (!nextCodeIs("TO ")) return ERR_SYNTAX;
	err=get_value();
	if (err) return err;
	// Usage of stack:
	//   12(sp): "TO" value
	//    8(sp): "STEP" value
	//    4(sp): Address to return to in "NEXT" statement.
	// Store "TO" value in stack
	check_obj_space(2);
	g_object[g_objpos++]=0x0820FFF4; // addiu sp,sp,-12 (see linker)
	g_object[g_objpos++]=0xAFA2000C; // sw v0,12(sp)
	// Check if "STEP" exists
	g_valueisconst=1;
	if (nextCodeIs("STEP ")) {
		// "STEP" exists. Get value
		err=get_value();
		if (err) return err;
	} else {
		// "STEP" not exist. Use "1".	
		check_obj_space(1);
		g_object[g_objpos++]=0x24020001; // addiu v0,zero,1
		g_intconst=1;
	}
	check_obj_space(14);
	g_object[g_objpos++]=0xAFA20008;              // sw          v0,8(sp)       (STEP value)
	g_object[g_objpos++]=0x04130004;              // bgezall     zero,check
//	g_object[g_objpos++]=0x8FC40000|((b1-'A')*4); // lw          a0,xx(s8)      (current var value)
	g_object[g_objpos++]=0x8FC40000|(i*4);        // lw          a0,xx(s8)      (current var value)
	// After executing "NEXT" statement, process reaches following line.
	// Update variable value by adding STEP value
	// Note that STEP value is loaded onto $v0 in NEXT statement
//	g_object[g_objpos++]=0x8FC40000|((b1-'A')*4); // lw          a0,xx(s8)      (current var value)
	g_object[g_objpos++]=0x8FC40000|(i*4);        // lw          a0,xx(s8)      (current var value)
	g_object[g_objpos++]=0x00822021;              // addu        a0,a0,v0
//	g_object[g_objpos++]=0xAFC40000|((b1-'A')*4); // sw          a0,xx(s8)      (new var value)
	g_object[g_objpos++]=0xAFC40000|(i*4);        // sw          a0,xx(s8)      (new var value)
	// Value-checking routine and storing ra in stack
	                                              // check:
	g_object[g_objpos++]=0x8FA3000C;              // lw          v1,12(sp)      (TO value)
	g_object[g_objpos++]=0x00641823;              // subu        v1,v1,a0
	g_object[g_objpos++]=0x04420001;              // bltzl       v0,negative
	g_object[g_objpos++]=0x00031823;              // subu        v1,zero,v1
	                                              // negative:
	g_object[g_objpos++]=0x04610003;              // bgez        v1,continue
	g_object[g_objpos++]=0xAFBF0004;              // sw          ra,4(sp)
	break_statement();                            // (2 words)
	                                              // continue:
	return 0;
}

char* next_statement(){
	// Return to address stored in 4($sp)
	// while set $v0 to 8($sp) (see for_statement)
	// Following assembly must be 4 words.
	// If the number of words will be changed, link.c must be reviced for CONTINUE statement.
	check_obj_space(4);
	g_object[g_objpos++]=0x8FBF0004; // lw          ra,4(sp)
	g_object[g_objpos++]=0x03E00008; // jr          ra
	g_object[g_objpos++]=0x8FA20008; // lw          v0,8(sp)       (STEP value)
	g_object[g_objpos++]=0x0830000C; // addiu       sp,sp,12 (see linker)
	return 0;
}

char* do_statement(){
	char* err;
	// Usage of stack:
	//    4(sp): Address to return to in "DO" statement.
	check_obj_space(3);
	g_object[g_objpos++]=0x04130001;//   bgezall     zero,label1:
	g_object[g_objpos++]=0x0822FFFC;//   addiu       sp,sp,-4 (see linker)
	                                //   label1:
	g_object[g_objpos++]=0xAFBF0004;//   sw          ra,4(sp)
	if (nextCodeIs("WHILE ")) {
		// DO WHILE
		err=get_floatOrValue();
		if (err) return err;
		check_obj_space(2);
		g_object[g_objpos++]=0x14400003; // bne         v0,zero,labe2
		g_object[g_objpos++]=0x00000000; // nop
		return break_statement();        // (2 words)
			                             // label2:

	} else if (nextCodeIs("UNTIL ")) {
		// DO UNTIL
		err=get_floatOrValue();
		if (err) return err;
		check_obj_space(2);
		g_object[g_objpos++]=0x10400003; // beq         v0,zero,label2
		g_object[g_objpos++]=0x00000000; // nop
		return break_statement();        // (2 words)
			                             // label2:
	} else {
		// DO statement without WHILE/UNTIL
		return 0;
	}
}

char* loop_statement(){
	char* err;
	int opos;
	opos=g_objpos;
	if (nextCodeIs("WHILE ")) {
		// LOOP WHILE
		err=get_floatOrValue();
		if (err) return err;
		check_obj_space(1);
		g_object[g_objpos++]=0x10400003; // beq         v0,zero,label1
	} else if (nextCodeIs("UNTIL ")) {
		// LOOP UNTIL
		err=get_floatOrValue();
		if (err) return err;
		check_obj_space(1);
		g_object[g_objpos++]=0x14400003; // bne         v0,zero,label
	} else {
		// LOOP statement without WHILE/UNTIL
	}
	check_obj_space(4);
	g_object[g_objpos++]=0x8FBF0004;      // lw          ra,4(sp)
	g_object[g_objpos++]=0x03E00008;      // jr          ra
	opos=g_objpos+1-opos;
	g_object[g_objpos++]=0x3000F000|opos; // nop                 (See linker, used for CONTINUE statement)
	                                      // label1:
	g_object[g_objpos++]=0x08320004;      // addiu       sp,sp,4       (See link() function)
	return 0;
}

char* while_statement(){
	char* err;
	check_obj_space(3);
	g_object[g_objpos++]=0x04130001; // bgezall     zero,label1:
	g_object[g_objpos++]=0x0821FFFC; // addiu       sp,sp,-4 (see linker)
	                                 // label1:
	g_object[g_objpos++]=0xAFBF0004; // sw          ra,4(sp)
	err=get_floatOrValue();
	if (err) return err;
	check_obj_space(2);
	g_object[g_objpos++]=0x14400003; // bne         v0,zero,label2
	g_object[g_objpos++]=0x00000000; // nop
	return break_statement();        // (2 words)
		                             // label2:
}

char* wend_statement(){
	check_obj_space(4);
	g_object[g_objpos++]=0x8FBF0004; // lw          ra,4(sp)
	g_object[g_objpos++]=0x03E00008; // jr          ra
	g_object[g_objpos++]=0x3000F003; // nop                 (See linker, used for CONTINUE statement)
	                                 // label1:
	g_object[g_objpos++]=0x08310004; // addiu       sp,sp,4 (See link() function)
	return 0;
}

char* param4_statement(enum libs lib){
	// lib is either LIB_PALETTE or LIB_GPALETTE
	// PALETTE N,R,G,B
	char* err;
	// Get N
	err=get_value();
	if (err) return err;
	if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
	g_srcpos++;
	check_obj_space(2);
	g_object[g_objpos++]=0x27BDFFF4; // addiu       sp,sp,-12
	g_object[g_objpos++]=0xAFA20004; // sw          v0,4(sp)
	// Get R
	err=get_value();
	if (err) return err;
	if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
	g_srcpos++;
	check_obj_space(1);
	g_object[g_objpos++]=0xAFA20008; // sw          v0,8(sp)
	// Get G
	err=get_value();
	if (err) return err;
	if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
	g_srcpos++;
	check_obj_space(1);
	g_object[g_objpos++]=0xAFA2000C; // sw          v0,12(sp)
	// Get B
	err=get_value();
	if (err) return err;
	call_lib_code(lib);
	check_obj_space(1);
	g_object[g_objpos++]=0x27BD000C; // addiu       sp,sp,12
	return 0;
}

char* param3_statement(enum libs lib){
	char* err;
	// Get 1st parameter
	err=get_value();
	if (err) return err;
	if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
	g_srcpos++;
	check_obj_space(2);
	g_object[g_objpos++]=0x27BDFFF8; // addiu       sp,sp,-8
	g_object[g_objpos++]=0xAFA20004; // sw          v0,4(sp)
	// Get 2nd parameter
	err=get_value();
	if (err) return err;
	if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
	g_srcpos++;
	check_obj_space(1);
	g_object[g_objpos++]=0xAFA20008; // sw          v0,8(sp)
	// Get 3rd parameter
	err=get_value();
	if (err) return err;
	call_lib_code(lib);
	check_obj_space(1);
	g_object[g_objpos++]=0x27BD0008; // addiu       sp,sp,8
	return 0;
}

char* bgcolor_statement(){
	// BGCOLOR R,G,B
	return param3_statement(LIB_BGCOLOR);
}

char* pcg_statement(){
	// PCG ASCII,D1,D2
	return param3_statement(LIB_PCG);
}

char* usepcg_statement(){
	int objpos=g_objpos;
	if (get_value()) {
		// Getting integer failed.
		// It supporsed to be not parameter
		// and same as parameter=1.
		g_objpos=objpos;
		check_obj_space(1);
		g_object[g_objpos++]=0x34020001; //ori         v0,zero,0x01
	}
	call_lib_code(LIB_USEPCG);
	return 0;
}

char* usegraphic_statement(){
	int objpos=g_objpos;
	if (get_value()) {
		// Getting integer failed.
		// It supporsed to be not parameter
		// and same as parameter=1.
		g_objpos=objpos;
		check_obj_space(1);
		g_object[g_objpos++]=0x34020001; //ori         v0,zero,0x01
	}
	call_lib_code(LIB_USEGRAPHIC);
	return 0;
}

char* cls_statement(){
	call_lib_code(LIB_CLS);
	return 0;
}

char* gcls_statement(){
	call_lib_code(LIB_GCLS);
	return 0;
}

char* color_statement(){
	char* err;
	err=get_value();
	if (err) return err;
	call_lib_code(LIB_COLOR);
	return 0;
}

char* gcolor_statement(){
	char* err;
	err=get_value();
	if (err) return err;
	call_lib_code(LIB_GCOLOR);
	return 0;
}

char* param2_statement(enum libs lib){
	char* err;
	// Get 1st
	err=get_value();
	if (err) return err;
	if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
	g_srcpos++;
	check_obj_space(2);
	g_object[g_objpos++]=0x27BDFFFC; // addiu       sp,sp,-4
	g_object[g_objpos++]=0xAFA20004; // sw          v0,4(sp)
	// Get 2nd
	err=get_value();
	if (err) return err;
	call_lib_code(lib);
	check_obj_space(1);
	g_object[g_objpos++]=0x27BD0004; // addiu       sp,sp,4
	return 0;
}

char* system_statement(){
	// SYSTEM X,Y
	char* err;
	// Get 1st
	err=get_value();
	if (err) return err;
	if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
	g_srcpos++;
	check_obj_space(2);
	g_object[g_objpos++]=0x27BDFFFC; // addiu       sp,sp,-4
	g_object[g_objpos++]=0xAFA20004; // sw          v0,4(sp)
	// Get 2nd
	err=get_value();
	if (err) return err;
	check_obj_space(2);
	g_object[g_objpos++]=0x8FA40004; // lw          a0,4(sp)
	g_object[g_objpos++]=0x27BD0004; // addiu       sp,sp,4
	call_lib_code(LIB_SYSTEM);
	return 0;
}

char* cursor_statement(){
	// CURSOR X,Y
	return param2_statement(LIB_CURSOR);
}

char* scroll_statement(){
	// SCROLL X,Y
	return param2_statement(LIB_SCROLL);
}

char* drawcount_statement(){
	char* err;
	err=get_value();
	if (err) return err;
	call_lib_code(LIB_SETDRAWCOUNT);
	return 0;
}

char* wait_statement(){
	char* err;
	err=get_value();
	if (err) return err;
	call_lib_code(LIB_WAIT);
	return 0;
}

char* width_statement(){
	char* err;
	err=get_value();
	if (err) return err;
	call_lib_code(LIB_WIDTH);
	return 0;
}

char* var_statement_sub(int a0, int a1){
	// Construct parameter-setting scripts
	if (a0&0xffff0000) {
		check_obj_space(1);
		g_object[g_objpos++]=0x3C040000|(a0>>16);        // lui         a0,XXXX
		if (a0&0x0000ffff) {
			check_obj_space(1);
			g_object[g_objpos++]=0x34840000|(a0&0xffff); // ori         a0,a0,XXXX
		}
	} else if (a0&0x0000ffff) {
		check_obj_space(1);
		g_object[g_objpos++]=0x34040000|(a0&0xffff);     // ori         a0,zero,xxxx
	}
	if (a1&0xffff0000) {
		check_obj_space(1);
		g_object[g_objpos++]=0x3C050000|(a1>>16);        // lui         a1,XXXX
		if (a1&0x0000ffff) {
			check_obj_space(1);
			g_object[g_objpos++]=0x34A50000|(a1&0xffff); // ori         a1,a1,XXXX
		}
	} else if (a1&0x0000ffff) {
		check_obj_space(1);
		g_object[g_objpos++]=0x34050000|(a1&0xffff);     // ori         a1,zero,xxxx
	} else if (a0&0xff000000) {
		// # of variables is 4. Reset $a1 to let lib_var() know that there is no more variables to store.
		check_obj_space(1);
		g_object[g_objpos++]=0x34050000;                 // ori         a1,zero,0
	}
	return 0;
}

char* var_statement(){
	char* err;
	int i,j,a0,a1;
	static int prevpos;
	short stack;
	do {
		// For stack, 4 bytes are used for return address,
		// 4 bytes are used in lib_var(),
		// and additinal bytes are used for storing variable values.
		stack=8;
		a0=a1=0;
		for (i=0;i<8;i++){
			// Determine the variable number from source code
			j=get_var_number();
			if (j<0) return ERR_SYNTAX;
			stack+=4;
			// Create parameters in $a0, or $a1
			if (i<4) {
				a0=(a0<<8)|(j+1);
			} else {
				a1=(a1<<8)|(j+1);
			}
			// Check remaining variable(s) 
			if (g_source[g_srcpos]=='#' || g_source[g_srcpos]=='$') g_srcpos++;
			next_position();
			if (g_source[g_srcpos]!=',') break;
			g_srcpos++;
		}
		// Jump to push routine, first
		check_obj_space(2);
		prevpos=g_objpos;
		g_object[g_objpos++]=0x04130000;                    // bgezall     zero,label1
		g_object[g_objpos++]=0x27BD0000|((0-stack)&0xffff); // addiu       sp,sp,-xx
		// Process will be here after RETURN statement
		// Pop routine
		err=var_statement_sub(a0,a1);                       // Prepare a0, and a1
		if (err) return err;
		call_lib_code(LIB_VAR_POP);
		// Restore stack and return
		check_obj_space(3);
		g_object[g_objpos++]=0x8FA30000|stack;              // lw          v1,xx(sp)
		g_object[g_objpos++]=0x00600008;                    // jr          v1
		g_object[g_objpos++]=0x27BD0000|stack;              // addiu       sp,sp,xx
		// Push rotine
		g_object[prevpos]|=g_objpos-prevpos-1;              // label1:
		check_obj_space(1);
		g_object[g_objpos++]=0xAFBF0004;                    // sw          ra,4(sp)
		err=var_statement_sub(a0,a1);                       // Prepare a0, and a1
		if (err) return err;
		call_lib_code(LIB_VAR_PUSH);

	} while (g_source[g_srcpos-1]==',');
	return 0;
}


char* graphic_statement(enum functions func){
	/*
		PSET X1,Y1[,C]
		LINE X1,Y1,X2,Y2[,C]
		BOXFILL X1,Y1,X2,Y2[,C]
		CIRCLE X1,Y1,R[,C]
		CIRCLEFILL X1,Y1,R[,C]
		GPRINT X1,Y1,C,BC,S$
		PUTBMP X1,Y1,M,N,BMP
		4(sp): X1
		8(sp): Y1
		12(sp): X2/R/M
		16(sp): Y2/N
		v0: C/S$/BMP
	*/
	char* err;
	int paramnum;
	switch(func){
		case FUNC_PSET:// X1,Y1[,C]
		case FUNC_GCOLOR:// X1,Y1
		case FUNC_POINT:// X1,Y1
			paramnum=2;
			break;
		case FUNC_CIRCLE:// X1,Y1,R[,C]
		case FUNC_CIRCLEFILL:// X1,Y1,R[,C]
			paramnum=3;
			break;
		case FUNC_LINE:// X1,Y1,X2,Y2[,C]
		case FUNC_BOXFILL:// X1,Y1,X2,Y2[,C]
			paramnum=4;
			break;
		case FUNC_GPRINT:// X1,Y1,C,BC,S$
		case FUNC_PUTBMP:// X1,Y1,M,N,BMP
			paramnum=5;
			break;
		default:
			return ERR_UNKNOWN;
	}

	next_position();
	if (g_source[g_srcpos]==',') {
		// X1 and Y1 is omitted. Set 0x80000000 for both.
		check_obj_space(4);
		g_object[g_objpos++]=0x27BDFFF0;              // addiu       sp,sp,-16
		g_object[g_objpos++]=0x3C028000;              // lui         v0,0x0080
		g_object[g_objpos++]=0xAFA20004;              // sw          v0,4(sp)
		g_object[g_objpos++]=0xAFA20008;              // sw          v0,8(sp)
	} else {
		// X1
		err=get_value();
		if (err) return err;
		check_obj_space(2);
		g_object[g_objpos++]=0x27BDFFF0;              // addiu       sp,sp,-16
		g_object[g_objpos++]=0xAFA20004;              // sw          v0,4(sp)
		// Y1
		if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
		g_srcpos++;
		err=get_value();
		if (err) return err;
		check_obj_space(1);
		g_object[g_objpos++]=0xAFA20008;              // sw          v0,8(sp)
	}
	if (2<paramnum) {
		// X2, R, or M
		if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
		g_srcpos++;
		err=get_value();
		if (err) return err;
		check_obj_space(1);
		g_object[g_objpos++]=0xAFA2000C;          // sw          v0,12(sp)
		if (3<paramnum) {
			// Y2, BC, or N
			if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
			g_srcpos++;
			err=get_value();
			if (err) return err;
			check_obj_space(1);
			g_object[g_objpos++]=0xAFA20010;      // sw          v0,16(sp)
		}
	}
	if (func==FUNC_GPRINT) {
		// S$
		if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
		g_srcpos++;
		err=get_string();
		if (err) return err;
	} else if (func==FUNC_PUTBMP) {
		// BMP
		if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
		g_srcpos++;
		err=get_label();
		if (g_label && !err) {
			// Label/number is constant.
			// Linker will change following codes later.
			// Note that 0x0814xxxx and 0x0815xxxx are specific codes for these.
			check_obj_space(2);
			g_object[g_objpos++]=0x08140000|((g_label>>16)&0x0000FFFF); // lui   v0,xxxx
			g_object[g_objpos++]=0x08150000|(g_label&0x0000FFFF);       // ori v0,v0,xxxx
			// Change func to FUNC_PUTBMP2 (label mode).
			func=FUNC_PUTBMP2;
		} else {
			err=get_value();
			if (err) return err;
		}
	} else {
		// [,C]
		if (g_source[g_srcpos]==',') {
			g_srcpos++;
			err=get_value();
			if (err) return err;
		} else {
			// If C is omitted, use -1.
			check_obj_space(1);
			g_object[g_objpos++]=0x2402FFFF;      // addiu       v0,zero,-1
		}
	}
	// Call library
	call_lib_code(LIB_GRAPHIC | func);
	// Restore stack pointer
	check_obj_space(1);
	g_object[g_objpos++]=0x27BD0010;              // addiu       sp,sp,16
	return 0;
}

char* fopen_statement(enum functions func){
	// func is either FUNC_FOPENST or FUNC_FOPEN
	char* err;
	// Get 1st
	err=get_string();
	if (err) return err;
	if (g_source[g_srcpos]!=',') return ERR_SYNTAX;
	g_srcpos++;
	check_obj_space(2);
	g_object[g_objpos++]=0x27BDFFF8; // addiu       sp,sp,-8
	g_object[g_objpos++]=0xAFA20004; // sw          v0,4(sp)
	// Get 2nd
	err=get_string();
	if (err) return err;
	check_obj_space(1);
	g_object[g_objpos++]=0xAFA20008; // sw          v0,8(sp)
	// Get 3rd
	if (g_source[g_srcpos]==',') {
		g_srcpos++;
		err=get_value();
		if (err) return err;
	} else {
		// If 3rd parameter is omitted, use 0.
		check_obj_space(1);
		g_object[g_objpos++]=0x24020000;      // addiu       v0,zero,0
	}
	call_lib_code(LIB_FILE | func);
	check_obj_space(1);
	g_object[g_objpos++]=0x27BD0008; // addiu       sp,sp,8
	return 0;
}

char* file_statement(){
	char* err;
	err=get_value();
	if (err) return err;
	call_lib_code(LIB_FILE | FUNC_FILE);
	return 0;
}

char* fclose_statement(){
	char* err;
	int orgpos=g_srcpos;
	if (endOfStatement()) {
		// If no argument, use 0
		check_obj_space(1);
		g_object[g_objpos++]=0x24020000;      // addiu       v0,zero,0
	} else {
		err=get_value();
		if (err) return err;
	}
	call_lib_code(LIB_FILE | FUNC_FCLOSE);
	return 0;
}

char* fprint_statement(){
	return print_statement(LIB_FILE | FUNC_FPRINTSTR,LIB_FILE | FUNC_FSTRING);
}

char* fget_statement(){
	return param2_statement(LIB_FILE | FUNC_FGET);
}

char* fput_statement(){
	return param2_statement(LIB_FILE | FUNC_FPUT);
}

char* fseek_statement(){
	char* err;
	err=get_value();
	if (err) return err;
	call_lib_code(LIB_FILE | FUNC_FSEEK);
	return 0;
}

char* fputc_statement(){
	char* err;
	err=get_value();
	if (err) return err;
	call_lib_code(LIB_FILE | FUNC_FPUTC);
	return 0;
}

char* fremove_statement(){
	char* err;
	err=get_string();
	if (err) return err;
	call_lib_code(LIB_FILE | FUNC_FREMOVE);
	return 0;
}

char* usevar_statement(){
	char* err;
	int i;
	do {
		next_position();
		i=check_var_name();
		if (i<65536) return ERR_SYNTAX;
		err=register_var_name(i);
		if (err) return err;
		if (g_source[g_srcpos]=='#' || g_source[g_srcpos]=='$') g_srcpos++;
		next_position();
		if (g_source[g_srcpos]==',') {
			g_srcpos++;
		} else {
			break;
		}
	} while(1);
	return 0;
}

#ifdef __DEBUG
	char* debug_statement(){
		call_lib_code(LIB_DEBUG);
		return 0;
	}
#endif


char* statement(void){
	char* err;
	int prevpos;
	// Clear flag for temp area usage.
	g_temp_area_used=0;
	// Initialize stack handler used for value
	g_sdepth=g_maxsdepth=0;
	if (nextCodeIs("REM")) {
		err=rem_statement();
	} else if (nextCodeIs("SOUND ")) {
		err=sound_statement();
	} else if (nextCodeIs("MUSIC ")) {
		err=music_statement();
	} else if (nextCodeIs("DRAWCOUNT ")) {
		err=drawcount_statement();
	} else if (nextCodeIs("CURSOR ")) {
		err=cursor_statement();
	} else if (nextCodeIs("PALETTE ")) {
		err=param4_statement(LIB_PALETTE);
	} else if (nextCodeIs("GPALETTE ")) {
		err=param4_statement(LIB_GPALETTE);
	} else if (nextCodeIs("BGCOLOR ")) {
		err=bgcolor_statement();
	} else if (nextCodeIs("CLS")) {
		err=cls_statement();
	} else if (nextCodeIs("GCLS")) {
		err=gcls_statement();
	} else if (nextCodeIs("COLOR ")) {
		err=color_statement();
	} else if (nextCodeIs("GCOLOR ")) {
		err=gcolor_statement();
	} else if (nextCodeIs("RESTORE ")) {
		err=restore_statement();
	} else if (nextCodeIs("DATA ")) {
		err=data_statement();
	} else if (nextCodeIs("CDATA ")) {
		err=cdata_statement();
	} else if (nextCodeIs("LABEL ")) {
		err=label_statement();
	} else if (nextCodeIs("DIM ")) {
		err=dim_statement();
	} else if (nextCodeIs("CLEAR")) {
		err=clear_statement();
	} else if (nextCodeIs("PRINT")) {
		err=print_statement(LIB_PRINTSTR,LIB_STRING);
	} else if (nextCodeIs("IF ")) {
		err=if_statement();
	} else if (nextCodeIs("ELSEIF ")) {
		err=elseif_statement();
	} else if (nextCodeIs("ELSE")) {
		err=else_statement();
	} else if (nextCodeIs("ENDIF")) {
		err=endif_statement();
	} else if (nextCodeIs("END")) {
		err=end_statement();
	} else if (nextCodeIs("EXEC ")) {
		err=exec_statement();
	} else if (nextCodeIs("GOTO ")) {
		err=goto_statement();
	} else if (nextCodeIs("GOSUB ")) {
		err=gosub_statement();
	} else if (nextCodeIs("RETURN")) {
		err=return_statement();
	} else if (nextCodeIs("POKE ")) {
		err=poke_statement();
	} else if (nextCodeIs("FOR ")) {
		err=for_statement();
	} else if (nextCodeIs("NEXT")) {
		err=next_statement();
	} else if (nextCodeIs("LET ")) {
		err=let_statement();
	} else if (nextCodeIs("PCG ")) {
		err=pcg_statement();
	} else if (nextCodeIs("USEPCG")) {
		err=usepcg_statement();
	} else if (nextCodeIs("SCROLL ")) {
		err=scroll_statement();
	} else if (nextCodeIs("WAIT ")) {
		err=wait_statement();
	} else if (nextCodeIs("USEGRAPHIC")) {
		err=usegraphic_statement();
	} else if (nextCodeIs("PSET ")) {
		err=graphic_statement(FUNC_PSET);
	} else if (nextCodeIs("LINE ")) {
		err=graphic_statement(FUNC_LINE);
	} else if (nextCodeIs("BOXFILL ")) {
		err=graphic_statement(FUNC_BOXFILL);
	} else if (nextCodeIs("CIRCLE ")) {
		err=graphic_statement(FUNC_CIRCLE);
	} else if (nextCodeIs("CIRCLEFILL ")) {
		err=graphic_statement(FUNC_CIRCLEFILL);
	} else if (nextCodeIs("GPRINT ")) {
		err=graphic_statement(FUNC_GPRINT);
	} else if (nextCodeIs("PUTBMP ")) {
		err=graphic_statement(FUNC_PUTBMP);
	} else if (nextCodeIs("POINT ")) {
		err=graphic_statement(FUNC_POINT);
	} else if (nextCodeIs("VAR ")) {
		err=var_statement();
	} else if (nextCodeIs("DO")) {
		err=do_statement();
	} else if (nextCodeIs("LOOP")) {
		err=loop_statement();
	} else if (nextCodeIs("WHILE ")) {
		err=while_statement();
	} else if (nextCodeIs("WEND")) {
		err=wend_statement();
	} else if (nextCodeIs("BREAK")) {
		err=break_statement();
	} else if (nextCodeIs("CONTINUE")) {
		err=continue_statement();
	} else if (nextCodeIs("SYSTEM")) {
		err=system_statement();
	} else if (nextCodeIs("WIDTH ")) {
		err=width_statement();
	} else if (nextCodeIs("FOPEN ")) {
		err=fopen_statement(FUNC_FOPENST);
	} else if (nextCodeIs("FILE ")) {
		err=file_statement();
	} else if (nextCodeIs("FCLOSE")) {
		err=fclose_statement();
	} else if (nextCodeIs("FPRINT ")) {
		err=fprint_statement();
	} else if (nextCodeIs("FGET ")) {
		err=fget_statement();
	} else if (nextCodeIs("FPUT ")) {
		err=fput_statement();
	} else if (nextCodeIs("FPUTC ")) {
		err=fputc_statement();
	} else if (nextCodeIs("FSEEK ")) {
		err=fseek_statement();
	} else if (nextCodeIs("FREMOVE ")) {
		err=fremove_statement();
	} else if (nextCodeIs("USEVAR ")) {
		err=usevar_statement();
#ifdef __DEBUG
	} else if (nextCodeIs("DEBUG")) {
		err=debug_statement();
#endif
	} else {
		err=let_statement();
	}
	if (err) return err;
	// Stack handler must be zero here.
	if (g_sdepth!=0) return ERR_UNKNOWN;
	// Check if temp area is used
	if (g_temp_area_used) {
		// Temp area is used. Insert a garbage collection flag setting routine.
		check_obj_space(1);
		g_object[g_objpos++]=0x7ED6F000;//   ext         s6,s6,0,31
	}
	return 0;
}
/*
   This file is provided under the LGPL license ver 2.1.
   Written by Katsumi.
   http://hp.vector.co.jp/authors/VA016157/
   kmorimatsu@users.sourceforge.jp
*/

/*
  Public functions:
    char* get_string(void);
	char* simple_string(void);
*/

#include "api.h"
#include "compiler.h"

char* simple_string(void){
	char* err;
	unsigned char b1,b2;
	int i,j;
	next_position();
	b1=g_source[g_srcpos];
	b2=g_source[g_srcpos+1];
	if (b1=='"') {
		// Constant string
		// Count character number (+1 for \0)
		// This may be more than actual character number due to escape sequence.
		i=0;
		while(1){
			i++;
			b1=g_source[g_srcpos+i];
			if (b1=='"') {
				break;
			} else if (b1=='\\') {
				i++;
			} else if (b1<0x20) {
				// This is an error, that will be detected later again.
				break;
			}
		};
		g_srcpos++;
		// Determine required word number
		i=(i+3)/4;
		// Determine address containing the string
		j=(int)(&(g_object[g_objpos+3]));
		// Note that using "bgezal zero," must be used to skip some region.
		// This is to find embed string in the code.
		check_obj_space(2+i);
		g_object[g_objpos++]=0x04110000|((i+1)&0x0000FFFF);   // bgezal zero,xxxx
		g_object[g_objpos++]=0x03E01021;                      // addu   v0,ra,zero
		for(j=0;(b1=g_source[g_srcpos++])!='"';j++) {
			if (b1=='\\') {
				b1=g_source[g_srcpos++];
				if (b1=='x' || b1=='X') {
					// Hexadecimal
					b1=g_source[g_srcpos++];
					if ('0'<=b1 && b1<='9') b1=b1-'0';
					else if ('A'<=b1 && b1<='F') b1=b1-'A'+10;
					else if ('a'<=b1 && b1<='f') b1=b1-'a'+10;
					else return ERR_SYNTAX;
					b2=g_source[g_srcpos++];
					if ('0'<=b2 && b2<='9') b2=b2-'0';
					else if ('A'<=b2 && b2<='F') b2=b2-'A'+10;
					else if ('a'<=b2 && b2<='f') b2=b2-'a'+10;
					else return ERR_SYNTAX;
					b1=(b1<<4)|b2;
				} else if (b1<0x20) {
					return ERR_SYNTAX;
				} else {
					// \\ or \"
				}
			} else if (b1<0x20) {
				return ERR_SYNTAX;
			}
			((char*)(&g_object[g_objpos]))[j]=b1;
		}
		((char*)(&g_object[g_objpos]))[j]=0x00;
		g_objpos+=i;
	} else if ('A'<=b1 && b1<='Z') {
		i=get_var_number();
		if (i<0) {
			// Function
			// String would be pointed by $v0
			// Otherwise, it will be assinged in xxx_function() function.
			err=str_function();
			if (err) return err;
			// Temp area would be used when executing.
			g_temp_area_used=1;
			return 0;
		}
		if (g_source[g_srcpos]!='$') return ERR_SYNTAX;
		g_srcpos++;
		// String variable
		next_position();
		if (g_source[g_srcpos]=='(') {
			// A part of string
			g_srcpos++;
			err=get_value();
			if (err) return err;
			if (g_source[g_srcpos]==')') {
				g_srcpos++;
				// Put -1 to $a0
				check_obj_space(1);
				g_object[g_objpos++]=0x2404FFFF;          // addiu a0,zero,-1
			} else if (g_source[g_srcpos]==',') {
				g_srcpos++;
				// Store $v0 in stack
				g_sdepth+=4;
				if (g_maxsdepth<g_sdepth) g_maxsdepth=g_sdepth;
				check_obj_space(1);
				g_object[g_objpos++]=0xAFA20000|g_sdepth; // sw v0,xx(sp)
				// Get next value
				err=get_value();
				if (err) return err;
				// Copy $v0 to $a0 and get value from stack to $a0.
				check_obj_space(2);
				g_object[g_objpos++]=0x00402021;          // addu a0,v0,zero
				g_object[g_objpos++]=0x8FA20000|g_sdepth; // lw v0,xx(sp)
				g_sdepth-=4;
				if (g_source[g_srcpos]!=')') return ERR_SYNTAX;
				g_srcpos++;
				// Temp area will be used when executing.
				g_temp_area_used=1;
			} else {
				return ERR_SYNTAX;
			}
			// $a1 is var number, $v0 is position, $a0 is length
			check_obj_space(1);
			g_object[g_objpos++]=0x24050000|(i);          // addiu a1,zero,xx
			call_lib_code(LIB_MIDSTR);
		} else {
			// Simple string
			check_obj_space(1);
			g_object[g_objpos++]=0x8FC20000|(i*4);        // lw v0,xx(s8)
			// String is pointed by $v0
		}
	} else {
		return ERR_SYNTAX;
	}
	return 0;
}

char* get_string_sub(){
	char* err;
	char b1;
	// Obtain initial string
	err=simple_string();
	if (err) return err;
	// Check if connection operator exists
	next_position();
	b1=g_source[g_srcpos];
	if (b1!='+' && b1!='&') return 0; // Exit if connection operator does not exist.
	g_srcpos++;
	// Connection required.
	// Prepare one level of stack for handling
	g_sdepth+=4;
	if (g_maxsdepth<g_sdepth) g_maxsdepth=g_sdepth;
	while(1) {
		// Store current pointer in stack
		check_obj_space(1);
		g_object[g_objpos++]=0xAFA20000|g_sdepth; // sw v0,xx(sp)
		// Obtain next string (pointer will be in $v0)
		err=simple_string();
		if (err) return err;
		// Restore previous pointer from stack in $a0 and copy $v0 to $a1
		// Call library
		check_obj_space(2);
		g_object[g_objpos++]=0x8FA40000|g_sdepth;             // lw    a0,xx(sp)
		call_lib_code(LIB_CONNECT_STRING);
		// Temp area will be used when executing.
		g_temp_area_used=1;
		// Check if further connection operator exists
		next_position();
		b1=g_source[g_srcpos];
		if (b1!='+' && b1!='&') break;
		g_srcpos++;
	}
	g_sdepth-=4;
	return 0;
}

char* get_string(){
	// This is only the public function.
	// Note that this can be called recursively.
	// String may contain a function with a parameter of value
	// that is a function with a parameter of string.
	// Result will be in $v0 as a pointer.
	char* err;
	char b1;
	int i,prevpos;
	if (g_sdepth==0) {
		// Initialize stack handler
		g_maxsdepth=0;
		prevpos=g_objpos;
		// Stack decrement command will be filled later
		check_obj_space(1);
		g_objpos++;
	}
	err=get_string_sub();
	if (err) return err;
	if (g_sdepth==0) {
		if (g_maxsdepth==0) {
			// Stack was not used.
			shift_obj(&g_object[prevpos+1],&g_object[prevpos],g_objpos-prevpos-1);
			g_objpos--;
		} else {
			// Stack was used.
			check_obj_space(1);
			g_object[prevpos]=0x27BD0000 | (0-g_maxsdepth) & 0x0000FFFF; // addiu sp,sp,-xx
			g_object[g_objpos++]=0x27BD0000 | g_maxsdepth & 0x0000FFFF;  // addiu sp,sp,xx
		}
	}
	g_lastvar=VAR_STRING;
	return 0;
}

/*
   This file is provided under the LGPL license ver 2.1.
   Written by Katsumi.
   http://hp.vector.co.jp/authors/VA016157/
   kmorimatsu@users.sourceforge.jp
*/

/*
  Public function is only get_value().
*/

#include "compiler.h"

char* get_value();
char* get_value_sub(int pr);

char* get_dim_value(int i){
	char* err;
	err=get_value_sub(priority(OP_VOID));
	if (err) return err;
	check_obj_space(4);
	g_object[g_objpos++]=0x00021080;              // sll v0,v0,0x2
	g_object[g_objpos++]=0x8FC30000|(i*4);        // lw v1,xx(s8)
	g_object[g_objpos++]=0x00621821;              // addu v1,v1,v0
	g_object[g_objpos++]=0x8C620000;              // lw v0,0(v1)
	next_position();
	if (g_source[g_srcpos]==','){
		// 2D, 3D or more
		// Use a stack
		g_sdepth+=4;
		if (g_maxsdepth<g_sdepth) g_maxsdepth=g_sdepth;
		check_obj_space(1);
		do {
			g_srcpos++;
			g_object[g_objpos++]=0xAFA20000|g_sdepth;      // sw v0,xx(sp)
			err=get_value_sub(priority(OP_VOID));
			if (err) return err;
			check_obj_space(5);
			g_object[g_objpos++]=0x00021080;               // sll v0,v0,0x2
			g_object[g_objpos++]=0x8FA30000|g_sdepth;      // lw v1,xx(sp)
			g_object[g_objpos++]=0x00621821;               // addu v1,v1,v0
			g_object[g_objpos++]=0x8C620000;               // lw v0,0(v1)
		} while (g_source[g_srcpos]==',');
		g_sdepth-=4;
	}
	if (g_source[g_srcpos]!=')') return ERR_SYNTAX;
	g_srcpos++;
	return 0;
}

char* get_simple_value(void){
	int i;
	char* err;
	char b1,b2;
	next_position();
	b1=g_source[g_srcpos];
	if (b1=='(') {
		// (...)
		// Parenthesis
		g_srcpos++;
		next_position();
		err=get_value_sub(priority(OP_VOID));
		if (err) return err;
		next_position();
		if (g_source[g_srcpos]!=')') return ERR_SYNTAX;
		g_srcpos++;
	} else if (b1=='-') {
		// Unary '-' operator
		// Note that unary operators ( + and - ) have higher priority than the other operators
		g_srcpos++;
		err=get_simple_value();
		if (err) return err;
		check_obj_space(1);
		g_object[g_objpos++]=0x00021023; // subu v0,zero,v0
		g_intconst=-g_intconst;
	} else {
		// Main routine of getting value here
		if (b1=='+') g_srcpos++; // Ignore unary '+' operator
		next_position();
		b1=g_source[g_srcpos];
		b2=g_source[g_srcpos+1];
		if (b1=='0' && b2=='X' || b1=='$') {
			// Starts with '0x' or '$'
			// Hex number
			g_srcpos++;
			if (b1=='0') g_srcpos++;
			i=0;
			while(b1=g_source[g_srcpos]) {
				if ('0'<=b1 && b1<='9') {
					i*=16;
					i+=b1-'0';
				} else if ('A'<=b1 && b1<='F') {
					i*=16;
					i+=b1-'A'+0x0A;
				} else {
					break;
				}
				g_srcpos++;
			}
			g_intconst=i;
			if (i&0xFFFF0000) {
				// 32 bit
				check_obj_space(2);
				g_object[g_objpos++]=0x3C020000|((i>>16)&0x0000FFFF); // lui   v0,xxxx
				g_object[g_objpos++]=0x34420000|(i&0x0000FFFF);       // ori v0,v0,xxxx
			} else {
				// 16 bit
				check_obj_space(1);
				g_object[g_objpos++]=0x34020000|(i&0x0000FFFF); // ori v0,zero,xxxx
			}
		} else if ('0'<=b1 && b1<='9') {
			// Starts with 0-9
			// Decimal number
			i=0;
			while(b1=g_source[g_srcpos]) {
				if ('0'<=b1 && b1<='9') {
					i*=10;
					i+=b1-'0';
				} else {
					break;
				}
				g_srcpos++;
			}
			// The next character should not be '.' or 'E'.
			// Or, it must be recognized as a float value.
			if (b1=='.' || b1=='E') return ERR_SYNTAX;
			g_intconst=i;
			if (i&0xFFFF0000) {
				// 32 bit
				check_obj_space(2);
				g_object[g_objpos++]=0x3C020000|((i>>16)&0x0000FFFF); // lui   v0,xxxx
				g_object[g_objpos++]=0x34420000|(i&0x0000FFFF);       // ori v0,v0,xxxx
			} else {
				// 16 bit
				check_obj_space(1);
				g_object[g_objpos++]=0x34020000|(i&0x0000FFFF); // ori v0,zero,xxxx
			}
		} else {
			g_valueisconst=0;
			i=get_var_number();
			if (i<0) {
				// Must be a function.
				return function();
			}
			if (g_source[g_srcpos]=='(') {
				// Dimension
				g_srcpos++;
				return get_dim_value(i);
			}
			// Simple value
			check_obj_space(1);
			g_object[g_objpos++]=0x8FC20000|(i*4); // lw v0,xx(s8)
		}
	}
	// No error 
	return 0;
}

char* get_value_sub(int pr){
	char* err;
	enum operator op;
	char b1,b2,b3;
	int prevpos;
	// Get a value in $v0.
	err=get_simple_value();
	if (err) return err;
	while(1){
		// Get the operator in op. If not valid operator, simply return without error.
		prevpos=g_srcpos;
		err=get_operator();
		if (err) return 0;
		op=g_last_op;
		// Compair current and previous operators.
		// If the previous operator has higher priolity, return.
		if (pr>=priority(op)) {
			g_srcpos=prevpos;
			return 0;
		}
		// Store $v0 in stack
		g_sdepth+=4;
		if (g_maxsdepth<g_sdepth) g_maxsdepth=g_sdepth;
		check_obj_space(1);
		g_object[g_objpos++]=0xAFA20000|g_sdepth; // sw v0,xx(sp)
		// Get next value.
		err=get_value_sub(priority(op));
		if (err) return err;
		// Get value from stack to $v1.
		check_obj_space(1);
		g_object[g_objpos++]=0x8FA30000|g_sdepth; // lw v1,xx(sp)
		g_sdepth-=4;
		// Calculation. Result will be in $v0.
		err=calculation(op);
		if (err) return err;
	}
}

char* get_value(){
	// This is only the public function.
	// Note that this can be called recursively.
	// Value may contain function with a parameter of another value.
	char* err;
	int prevpos;
	if (g_sdepth==0) {
		// Initialize stack handler
		g_maxsdepth=0;
		prevpos=g_objpos;
		// Stack decrement command will be filled later
		check_obj_space(1);
		g_objpos++;
	}
	err=get_value_sub(priority(OP_VOID));
	if (err) return err;
	if (g_sdepth==0) {
		if (g_maxsdepth==0) {
			// Stack was not used.
			shift_obj(&g_object[prevpos+1],&g_object[prevpos],g_objpos-prevpos-1);
			g_objpos--;
		} else {
			// Stack was used.
			check_obj_space(1);
			g_object[prevpos]=0x27BD0000 | (0-g_maxsdepth) & 0x0000FFFF; // addiu sp,sp,-xx
			g_object[g_objpos++]=0x27BD0000 | g_maxsdepth & 0x0000FFFF;  // addiu sp,sp,xx
		}
	}
	g_lastvar=VAR_INTEGER;
	return 0;
}

char* get_floatOrValue(){
	char* err;
	char b;
	int opos,spos,sdpt;
	sdpt=g_sdepth;
	opos=g_objpos;
	spos=g_srcpos;
	// First try integer.
	// Integer value has the higher priolity than float value.
	err=get_value();
	b=g_source[g_srcpos];
	if (err || b=='#') {
		// Value is not integer. Let's try float.
		g_sdepth=sdpt;
		g_objpos=opos;
		g_srcpos=spos;
		return get_float();
	} else {
		// Value was recognized as an integer.
		return 0;
	}
}

char* get_stringFloatOrValue(){
	char* err;
	int opos,spos;
	opos=g_objpos;
	spos=g_srcpos;
	// First try string, float, then integer.
	err=get_string();
	if (err) {
		g_objpos=opos;
		g_srcpos=spos;
		return get_floatOrValue();
	} else {
		return 0;
	}
}

/*
   This file is provided under the LGPL license ver 2.1.
   Written by Katsumi.
   http://hp.vector.co.jp/authors/VA016157/
   kmorimatsu@users.sourceforge.jp
*/

#include "compiler.h"

/*
	static const int reserved_var_names[];
	This dimension contains var name integers of reserved var names.
	To make following structure, execute "reservednames.js" in Windows.
*/

static const int reserved_var_names[]={
	0x000106b8, //ABS
	0x0001f67c, //ACOS
	0x0002414c, //ARGS
	0x0001090c, //ASC
	0x0002469f, //ASIN
	0x00024a8f, //ATAN
	0x002f7c1e, //ATAN2
	0x0047c31c, //BREAK
	0x00575afe, //CDATA
	0x00036c3d, //CEIL
	0x000111af, //CHR
	0x0cb1b682, //CIRCLE
	0x005d1ea3, //CLEAR
	0x00011240, //CLS
	0x005f66cb, //COLOR
	0x000112ac, //COS
	0x0003a041, //COSH
	0x00616415, //CREAD
	0x0de593fb, //CURSOR
	0x00040fbe, //DATA
	0x00011644, //DEC
	0x000116de, //DIM
	0x000100a8, //DO
	0x0004fd8e, //ELSE
	0x1434a177, //ELSEIF
	0x00011c99, //END
	0x0091c927, //ENDIF
	0x00053854, //EXEC
	0x00011e0d, //EXP
	0x000579c8, //FABS
	0x16e3d4be, //FCLOSE
	0x00058fcf, //FEOF
	0x00059895, //FGET
	0x00a67500, //FGETC
	0x0005a3a2, //FILE
	0x177f0ca5, //FINPUT
	0x0005b1df, //FLEN
	0x00aa3445, //FLOAT
	0x00aa363b, //FLOOR
	0x0005b84d, //FMOD
	0x00ac5c9f, //FOPEN
	0x000121db, //FOR
	0x18352839, //FPRINT
	0x0005c865, //FPUT
	0x00ad2e40, //FPUTC
	0x00aefdec, //FSEEK
	0x00063b90, //GCLS
	0x1a808bcb, //GCOLOR
	0x00c60f03, //GOSUB
	0x0006796c, //GOTO
	0x1bcfcc39, //GPRINT
	0x00012a99, //HEX
	0x00010153, //IF
	0x00f8701a, //INKEY
	0x00f88ba5, //INPUT
	0x000130e9, //INT
	0x00092084, //KEYS
	0x013be43d, //LABEL
	0x00013ecf, //LEN
	0x00013ed5, //LET
	0x0009e96a, //LINE
	0x00014030, //LOG
	0x0145f324, //LOG10
	0x000a07f9, //LOOP
	0x000abca3, //MODF
	0x016418d4, //MUSIC
	0x000b4321, //NEXT
	0x00014a5d, //NOT
	0x000152c0, //PCG
	0x000cacec, //PEEK
	0x00010252, //PI
	0x01ac8479, //POINT
	0x000ce05e, //POKE
	0x00015480, //POW
	0x01aea739, //PRINT
	0x000cf3d5, //PSET
	0x3cc0fe21, //PUTBMP
	0x000e18d5, //READ
	0x00015d2e, //REM
	0x425c9703, //RETURN
	0x00015e69, //RND
	0x45c26d49, //SCROLL
	0x00016287, //SGN
	0x000162cf, //SIN
	0x000ee52d, //SINH
	0x01f9a429, //SOUND
	0x000f0e49, //SQRT
	0x47f711de, //SYSTEM
	0x000166bf, //TAN
	0x000f72ed, //TANH
	0x02182fee, //TVRAM
	0x022c2a2d, //UNTIL
	0x4e8887d0, //USEPCG
	0x4e88a5f3, //USEVAR
	0x000170dd, //VAL
	0x000170e3, //VAR
	0x00119505, //WAIT
	0x0011a9e9, //WEND
	0x025aef62, //WHILE
	0x025b8d75, //WIDTH
};

/*
	check_var_name();
	This function reads the current position of source code and check if
	it contains valid var name, the function returns 0 or plus value.
	If not, it returns -1;
*/

int check_var_name(){
	char b1;
	int j;
	int i=0;
	int prevpos=g_srcpos;
	next_position();
	b1=g_source[g_srcpos];
	if (b1<'A' || 'Z'<b1) return -1;
	do {
		// First character must be A-Z
		// From second, A-Z and 0-9 can be used.
		i*=36;
		if ('0'<=b1 && b1<='9') {
			i+=b1-'0';
		} else if (g_srcpos==prevpos) {
			// First character must be A-Z.
			// Subtract 9, resulting 1-26 but not 10-35.
			// This subtraction is required to maintain
			// final number being <0x80000000.
			i+=b1-'A'+1;
		} else {
			i+=b1-'A'+10;
		}
		g_srcpos++;
		b1=g_source[g_srcpos];
	} while ('0'<= b1 && b1<='9' || 'A'<=b1 && b1<='Z');
	// Length of the label must be between 2 and 6.
	if (g_srcpos-prevpos<2) {
		// One letter var name, A-Z
		return i-1;
	}
	if (6<g_srcpos-prevpos) {
		// Too long. This is not var name.
		g_srcpos=prevpos;
		return -1;
	}
	i+=65536;
	// Check if this is reserved var name.
	for(j=0;j<sizeof reserved_var_names/sizeof reserved_var_names[0];j++){
		if (reserved_var_names[j]==i) {
			// This var name is reserved as used for function or statement.
			g_srcpos=prevpos;
			return -1;
		}
	}
	// Reserved var names table was checked. This must be a long var name.
	return i;
}

/*
	int get_var_number();
	This function returns variable number that can be used as the index of $s8
*/

int get_var_number(){
	int i;
	// This must be a short or long var name.
	i=check_var_name();
	if (i<0) return -1;
	// If it is a short name, immediately return.
	if (i<26) return i;
	// Search long var names registered by USEVAR statement.
	// If found, returns the value that can be used as the index of $s8
	i=search_var_name(i);
	if (i<0) return -1;
	// This var name is defined by USEVAR statement.
	return i+ALLOC_LNV_BLOCK;
	
}

/*
	int search_var_name(int nameint);
	This function searchs registered long var name in compile data table.
	If not found, this function returns -1.
	If found, it retunrs var number, beginning 0.
*/

int search_var_name(int nameint){
	int* cmpdata;
	cmpdata_reset();
	while(cmpdata=cmpdata_find(CMPDATA_USEVAR)){
		if (cmpdata[1]==nameint) return cmpdata[0]&0x0000ffff;
	}
	return -1;
}

/*
	char* register_var_name(int nameint);
	This function is called when compiler detects "USEVAR" statement.
	It registers the long file name in compile data table.
*/

char* register_var_name(int nameint){
	// Check if registered before. If did, cause error.
	if (search_var_name(nameint)!=-1) return ERR_INVALID_VAR_NAME;
	// Number of long var name is restricted
	if (ALLOC_LNV_NUM<=g_long_name_var_num) return ERR_INVALID_VAR_NAME;
	// Register var name as a compile data
	g_temp=nameint;
	return cmpdata_insert(CMPDATA_USEVAR,g_long_name_var_num++,&g_temp,1);
}
